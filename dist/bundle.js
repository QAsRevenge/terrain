(function () {
'use strict';

(function() {
    const env = {"MAPRAY_ACCESS_TOKEN":"MTY4NDIyNjYwODllY2U2Njk2YzgyODNjNzliYjE3","BINGMAP_ACCESS_TOKEN":"Alg8vgLF4ksNTmcrFk_7XL9nhke5A7o3mwka8F7d6kq7TIWdcRq44xLcEsq9J9o6"};
    try {
        if (process) {
            process.env = Object.assign({}, process.env);
            Object.assign(process.env, env);
            return;
        }
    } catch (e) {} // avoid ReferenceError: process is not defined
    globalThis.process = { env:env };
})();

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = "@import url(\"https://fonts.googleapis.com/css?family=Noto+Sans+JP&display=swap\");.control-bottom-left,.control-bottom-right,.control-top-left,.control-top-right{position:absolute;pointer-events:none;z-index:2}.control-top-left{top:0;left:0}.control-top-right{top:0;right:0}.control-bottom-left{bottom:0;left:0}.control-bottom-right{right:0;bottom:0}.control{clear:both;pointer-events:auto;transform:translate(0)}.control-top-left .control{margin:10px 0 0 10px;float:left}.control-top-right .control{margin:10px 10px 0 0;float:right}.control-bottom-left .control{margin:0 0 10px 10px;float:left}.control-bottom-right .control{margin:0 10px 10px 0;float:right}a.mapray-logo{width:160px;height:28px;display:block;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' id='svg1481' version='1.1' viewBox='0 0 119.56 21.24'%3E%3Cdefs id='defs1315'%3E%3Cstyle id='style1313'%3E.cls-1{fill:%23b5b5b6}.cls-2,.cls-4{fill:%23fff}.cls-3{fill:%230086d1}.cls-4{stroke:%23999}%3C/style%3E%3C/defs%3E%3Cg data-name='レイヤー2' id='レイヤー2'%3E%3Cg id='layer1'%3E%3Cpath id='polygon1319' class='cls-1' d='M11.24 10.4l-.77-1.92-1.9-.77h-.01l-1.94.73-.73 1.96.73 1.96 1.94.73h.01l1.89-.78.78-1.91z'/%3E%3Cpath id='polygon1321' class='cls-2' d='M4.28 5.38V0L2.45 4.26l1.83 1.12z'/%3E%3Cpath id='polygon1323' class='cls-1' d='M2.45 4.26L.82 6.1l3.46-.72-1.83-1.12z'/%3E%3Cpath id='polygon1325' class='cls-3' d='M4.28 5.38z'/%3E%3Cpath id='polygon1327' class='cls-2' d='M4.28 5.38L.82 6.1 0 10.4l4.28-5.02z'/%3E%3Cpath id='polygon1329' class='cls-1' d='M0 10.4h4.28V5.38L0 10.4z'/%3E%3Crect id='rect1331' transform='rotate(-45.1 4.288 5.38)' y='5.38' x='4.28' class='cls-3'/%3E%3Cpath id='polygon1333' class='cls-1' d='M4.28 5.38v5.02l1.24-3.05-1.24-1.97z'/%3E%3Cpath id='polygon1335' class='cls-1' d='M4.28 5.38l1.24 1.97L8.56 6.1l-4.28-.72z'/%3E%3Cpath id='polygon1337' class='cls-1' d='M4.28 5.38L8.56 1.8 4.28 0v5.38z'/%3E%3Cpath id='polygon1339' class='cls-1' d='M8.56 6.1V1.8L4.28 5.38l4.28.72z'/%3E%3Cpath id='polygon1341' class='cls-2' d='M13.66 5.66l-.17-2.79L8.56 1.8l5.1 3.86z'/%3E%3Cpath id='polygon1343' class='cls-1' d='M8.56 1.8v4.3l5.1-.44-5.1-3.86z'/%3E%3Cpath id='polygon1345' class='cls-3' d='M13.66 5.66z'/%3E%3Cpath id='polygon1347' class='cls-1' d='M13.66 5.66l-5.1.44 3.13 1.16 1.97-1.6z'/%3E%3Cpath id='polygon1349' class='cls-1' d='M11.69 7.26l1.16 3.14.81-4.74-1.97 1.6z'/%3E%3Crect id='rect1351' transform='rotate(-45.1 13.66 5.658)' y='5.66' x='13.66' class='cls-3'/%3E%3Cpath id='polygon1353' class='cls-1' d='M13.66 5.66l-.81 4.74 4.28-.28-3.47-4.46z'/%3E%3Cpath id='polygon1355' class='cls-2' d='M13.66 5.66l3.47-1-3.64-1.79.17 2.79z'/%3E%3Cpath id='polyline1357' class='cls-2' d='M13.66 5.66l3.47 4.46V4.66l-3.47 1'/%3E%3Cpath id='polygon1359' class='cls-1' d='M4.28 15.41V10.4H0l4.28 5.01z'/%3E%3Cpath id='polygon1361' class='cls-2' d='M0 10.4l.82 4.3 3.46.71L0 10.4z'/%3E%3Cpath id='polygon1363' class='cls-3' d='M4.28 15.41z'/%3E%3Cpath id='polygon1365' class='cls-2' d='M4.28 15.41L.82 14.7l1.66 1.8 1.8-1.09z'/%3E%3Cpath id='polygon1367' class='cls-2' d='M2.48 16.5l1.8 1.41v-2.5l-1.8 1.09z'/%3E%3Crect id='rect1369' transform='rotate(-45.1 4.285 15.417)' y='15.41' x='4.28' class='cls-3'/%3E%3Cpath id='polygon1371' class='cls-2' d='M4.28 15.41v2.5l4.28 1.08-4.28-3.58z'/%3E%3Cpath id='polygon1373' class='cls-1' d='M4.28 15.41l4.28 3.58V14.7l-4.28.71z'/%3E%3Cpath id='polygon1375' class='cls-1' d='M4.28 15.41l1.26-1.97-1.26-3.04v5.01z'/%3E%3Cpath id='polygon1377' class='cls-1' d='M8.56 14.7l-3.02-1.26-1.26 1.97 4.28-.71z'/%3E%3Cpath id='polygon1379' class='cls-1' d='M13.48 17.2l-.63-6.8-1.29 3 1.92 3.8z'/%3E%3Cpath id='polygon1381' class='cls-1' d='M11.56 13.4l-3 1.3 4.92 2.5-1.92-3.8z'/%3E%3Cpath id='polygon1383' class='cls-3' d='M13.48 17.2z'/%3E%3Cpath id='polygon1385' class='cls-1' d='M13.48 17.2l-4.92-2.5v4.29l4.92-1.79z'/%3E%3Crect id='rect1387' transform='rotate(-45.1 13.47 17.198)' y='17.2' x='13.48' class='cls-3'/%3E%3Cpath id='polygon1389' class='cls-1' d='M13.48 17.2l3.65-7.08-4.28.28.63 6.8z'/%3E%3Cpath id='polygon1391' class='cls-2' d='M17.13 21.24V10.12l-3.65 7.08 3.65 4.04z'/%3E%3Cpath id='polygon1393' class='cls-1' d='M23.02 10.4l.76-1.92 1.91-.77h.01l1.94.73.73 1.96-.73 1.96-1.94.73h-.01l-1.9-.78-.77-1.91z'/%3E%3Cpath id='polygon1395' class='cls-2' d='M29.98 5.38V0l1.83 4.26-1.83 1.12z'/%3E%3Cpath id='polygon1397' class='cls-1' d='M31.81 4.26l1.63 1.84-3.46-.72 1.83-1.12z'/%3E%3Cpath id='polygon1399' class='cls-3' d='M29.98 5.38z'/%3E%3Cpath id='polygon1401' class='cls-2' d='M29.98 5.38l3.46.72.82 4.3-4.28-5.02z'/%3E%3Cpath id='polygon1403' class='cls-1' d='M34.26 10.4h-4.28V5.38l4.28 5.02z'/%3E%3Crect id='rect1405' transform='rotate(-44.9 29.975 5.387)' y='5.38' x='29.98' class='cls-3'/%3E%3Cpath id='polygon1407' class='cls-1' d='M29.98 5.38v5.02l-1.25-3.05 1.25-1.97z'/%3E%3Cpath id='polygon1409' class='cls-1' d='M29.98 5.38l-1.25 1.97-3.04-1.25 4.29-.72z'/%3E%3Cpath id='polygon1411' class='cls-1' d='M29.98 5.38L25.69 1.8 29.98 0v5.38z'/%3E%3Cpath id='polygon1413' class='cls-1' d='M25.69 6.1V1.8l4.29 3.58-4.29.72z'/%3E%3Cpath id='polygon1415' class='cls-2' d='M20.6 5.66l.16-2.79 4.93-1.07-5.09 3.86z'/%3E%3Cpath id='polygon1417' class='cls-1' d='M25.69 1.8v4.3l-5.09-.44 5.09-3.86z'/%3E%3Cpath id='polygon1419' class='cls-3' d='M20.6 5.66z'/%3E%3Cpath id='polygon1421' class='cls-1' d='M20.6 5.66l5.09.44-3.12 1.16-1.97-1.6z'/%3E%3Cpath id='polygon1423' class='cls-1' d='M22.57 7.26l-1.16 3.14-.81-4.74 1.97 1.6z'/%3E%3Crect id='rect1425' transform='rotate(-44.9 20.596 5.663)' y='5.66' x='20.6' class='cls-3'/%3E%3Cpath id='polygon1427' class='cls-1' d='M20.6 5.66l.81 4.74-4.28-.28 3.47-4.46z'/%3E%3Cpath id='polygon1429' class='cls-2' d='M20.6 5.66l-3.47-1 3.63-1.79-.16 2.79z'/%3E%3Cpath id='polyline1431' class='cls-2' d='M20.6 5.66l-3.47 4.46V4.66l3.47 1'/%3E%3Cpath id='polygon1433' class='cls-1' d='M29.98 15.41V10.4h4.28l-4.28 5.01z'/%3E%3Cpath id='polygon1435' class='cls-2' d='M34.26 10.4l-.82 4.3-3.46.71 4.28-5.01z'/%3E%3Cpath id='polygon1437' class='cls-3' d='M29.98 15.41z'/%3E%3Cpath id='polygon1439' class='cls-2' d='M29.98 15.41l3.46-.71-1.66 1.8-1.8-1.09z'/%3E%3Cpath id='polygon1441' class='cls-2' d='M31.78 16.5l-1.8 1.41v-2.5l1.8 1.09z'/%3E%3Crect id='rect1443' transform='rotate(-44.9 29.981 15.42)' y='15.41' x='29.98' class='cls-3'/%3E%3Cpath id='polygon1445' class='cls-2' d='M29.98 15.41v2.5l-4.29 1.08 4.29-3.58z'/%3E%3Cpath id='polygon1447' class='cls-1' d='M29.98 15.41l-4.29 3.58V14.7l4.29.71z'/%3E%3Cpath id='polygon1449' class='cls-1' d='M29.98 15.41l-1.26-1.97 1.26-3.04v5.01z'/%3E%3Cpath id='polygon1451' class='cls-1' d='M25.69 14.7l3.03-1.26 1.26 1.97-4.29-.71z'/%3E%3Cpath id='polygon1453' class='cls-1' d='M20.72 17.2l.69-6.8 1.29 3-1.98 3.8z'/%3E%3Cpath id='polygon1455' class='cls-1' d='M22.7 13.4l2.99 1.3-4.97 2.5 1.98-3.8z'/%3E%3Cpath id='polygon1457' class='cls-3' d='M20.72 17.2z'/%3E%3Cpath id='polygon1459' class='cls-1' d='M20.72 17.2l4.97-2.5v4.29l-4.97-1.79z'/%3E%3Crect id='rect1461' transform='rotate(-44.9 20.716 17.202)' y='17.2' x='20.72' class='cls-3'/%3E%3Cpath id='polygon1463' class='cls-1' d='M20.72 17.2l-3.59-7.08 4.28.28-.69 6.8z'/%3E%3Cpath id='polygon1465' class='cls-2' d='M17.13 21.24V10.12l3.59 7.08-3.59 4.04z'/%3E%3Cpath id='path1467' d='M65.89 5.37L63.45 6l-1 .76-.92 1-.53 2.49.47 2.44.94 1 1 .8 2.44.61 2.43-.64 2.43.64V5.37L68.32 6zm1.7 6.63l-1.7.73-1.72-.73-.72-1.72.71-1.73 1.73-.71 1.77.66.66 1.78z' class='cls-4'/%3E%3Cpath id='path1469' d='M83.54 7.81l-.92-1L81.57 6l-2.43-.63-2.43.63-2.43-.6v15.04h2.43v-5.95l2.43.64 2.43-.61 1-.8.94-1 .49-2.47zM80.86 12l-1.72.72-1.7-.72-.73-1.71.66-1.78 1.77-.66 1.73.71.7 1.73z' class='cls-4'/%3E%3Cpath id='polygon1471' class='cls-4' d='M41.5 15.13h2.43v-4.88l.66-1.78 1.77-.66 1.73.71.7 1.73v4.88h2.44v-4.88l.73-1.73 1.73-.71 1.77.66.66 1.78v4.88h2.43V7.81l-1.2-1.05L56.12 6v-.03l-2.43-.6-2.44.63-1.23.29L48.79 6l-2.43-.63-2.43.6-2.43-.6v9.76z'/%3E%3Cpath id='path1473' d='M103.52 6l-2.43-.6-2.43.6-1 .76-.92 1-.47 2.44.47 2.44.94 1 1 .8 2.43.61 2.43-.64 2.44.64V5.37zm-.73 6l-1.7.73-1.72-.73-.71-1.72.7-1.73 1.73-.71 1.78.66.65 1.78z' class='cls-4'/%3E%3Cpath id='polygon1475' class='cls-4' d='M91.46 5.37l-2.43.6-2.43-.6v9.76h2.43v-4.88l.66-1.78 1.77-.66 1.73.71.87-.88.88-.88L93.89 6l-2.43-.63z'/%3E%3Cpath id='polygon1477' class='cls-4' d='M116.62 5.97v4.28l-.73 1.71-1.7.73-1.72-.72-.71-1.72V5.97l-2.44-.6v4.88l.47 2.44.94 1.03 1.03.8 2.43.61 2.43-.64v1.07l-.67 1.78-1.78.66-1.73-.71-.8.81-.94.95 1.04.76 2.43.63 2.43-.63 1.05-.76.92-1.05.49-2.44V5.37l-2.44.6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E\");background-repeat:no-repeat;background-size:160px 28px}a.mapray-logo.mapray-logo-compact{width:45px;height:28px;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' id='svg1133' version='1.1' viewBox='0 0 34.26 21.24'%3E%3Cdefs id='defs979'%3E%3Cstyle id='style977'%3E.cls-1{fill:%23b5b5b6}.cls-2{fill:%23fff}.cls-3{fill:%230086d1}%3C/style%3E%3C/defs%3E%3Cg data-name='レイヤー2' id='レイヤー2'%3E%3Cg id='layer1'%3E%3Cpath id='polygon983' class='cls-1' d='M11.24 10.4l-.77-1.92-1.9-.77h-.01l-1.94.73-.73 1.96.73 1.96 1.94.73h.01l1.89-.78.78-1.91z'/%3E%3Cpath id='polygon985' class='cls-2' d='M4.28 5.38V0L2.45 4.26l1.83 1.12z'/%3E%3Cpath id='polygon987' class='cls-1' d='M2.45 4.26L.82 6.1l3.46-.72-1.83-1.12z'/%3E%3Cpath id='polygon989' class='cls-3' d='M4.28 5.38z'/%3E%3Cpath id='polygon991' class='cls-2' d='M4.28 5.38L.82 6.1 0 10.4l4.28-5.02z'/%3E%3Cpath id='polygon993' class='cls-1' d='M0 10.4h4.28V5.38L0 10.4z'/%3E%3Crect id='rect995' transform='rotate(-45.1 4.288 5.38)' y='5.38' x='4.28' class='cls-3'/%3E%3Cpath id='polygon997' class='cls-1' d='M4.28 5.38v5.02l1.24-3.05-1.24-1.97z'/%3E%3Cpath id='polygon999' class='cls-1' d='M4.28 5.38l1.24 1.97L8.56 6.1l-4.28-.72z'/%3E%3Cpath id='polygon1001' class='cls-1' d='M4.28 5.38L8.56 1.8 4.28 0v5.38z'/%3E%3Cpath id='polygon1003' class='cls-1' d='M8.56 6.1V1.8L4.28 5.38l4.28.72z'/%3E%3Cpath id='polygon1005' class='cls-2' d='M13.66 5.66l-.17-2.79L8.56 1.8l5.1 3.86z'/%3E%3Cpath id='polygon1007' class='cls-1' d='M8.56 1.8v4.3l5.1-.44-5.1-3.86z'/%3E%3Cpath id='polygon1009' class='cls-3' d='M13.66 5.66z'/%3E%3Cpath id='polygon1011' class='cls-1' d='M13.66 5.66l-5.1.44 3.13 1.16 1.97-1.6z'/%3E%3Cpath id='polygon1013' class='cls-1' d='M11.69 7.26l1.16 3.14.81-4.74-1.97 1.6z'/%3E%3Crect id='rect1015' transform='rotate(-45.1 13.66 5.658)' y='5.66' x='13.66' class='cls-3'/%3E%3Cpath id='polygon1017' class='cls-1' d='M13.66 5.66l-.81 4.74 4.28-.28-3.47-4.46z'/%3E%3Cpath id='polygon1019' class='cls-2' d='M13.66 5.66l3.47-1-3.64-1.79.17 2.79z'/%3E%3Cpath id='polyline1021' class='cls-2' d='M13.66 5.66l3.47 4.46V4.66l-3.47 1'/%3E%3Cpath id='polygon1023' class='cls-1' d='M4.28 15.41V10.4H0l4.28 5.01z'/%3E%3Cpath id='polygon1025' class='cls-2' d='M0 10.4l.82 4.3 3.46.71L0 10.4z'/%3E%3Cpath id='polygon1027' class='cls-3' d='M4.28 15.41z'/%3E%3Cpath id='polygon1029' class='cls-2' d='M4.28 15.41L.82 14.7l1.66 1.8 1.8-1.09z'/%3E%3Cpath id='polygon1031' class='cls-2' d='M2.48 16.5l1.8 1.41v-2.5l-1.8 1.09z'/%3E%3Crect id='rect1033' transform='rotate(-45.1 4.285 15.417)' y='15.41' x='4.28' class='cls-3'/%3E%3Cpath id='polygon1035' class='cls-2' d='M4.28 15.41v2.5l4.28 1.08-4.28-3.58z'/%3E%3Cpath id='polygon1037' class='cls-1' d='M4.28 15.41l4.28 3.58V14.7l-4.28.71z'/%3E%3Cpath id='polygon1039' class='cls-1' d='M4.28 15.41l1.26-1.97-1.26-3.04v5.01z'/%3E%3Cpath id='polygon1041' class='cls-1' d='M8.56 14.7l-3.02-1.26-1.26 1.97 4.28-.71z'/%3E%3Cpath id='polygon1043' class='cls-1' d='M13.48 17.2l-.63-6.8-1.29 3 1.92 3.8z'/%3E%3Cpath id='polygon1045' class='cls-1' d='M11.56 13.4l-3 1.3 4.92 2.5-1.92-3.8z'/%3E%3Cpath id='polygon1047' class='cls-3' d='M13.48 17.2z'/%3E%3Cpath id='polygon1049' class='cls-1' d='M13.48 17.2l-4.92-2.5v4.29l4.92-1.79z'/%3E%3Crect id='rect1051' transform='rotate(-45.1 13.47 17.198)' y='17.2' x='13.48' class='cls-3'/%3E%3Cpath id='polygon1053' class='cls-1' d='M13.48 17.2l3.65-7.08-4.28.28.63 6.8z'/%3E%3Cpath id='polygon1055' class='cls-2' d='M17.13 21.24V10.12l-3.65 7.08 3.65 4.04z'/%3E%3Cpath id='polygon1057' class='cls-1' d='M23.02 10.4l.76-1.92 1.91-.77h.01l1.94.73.73 1.96-.73 1.96-1.94.73h-.01l-1.9-.78-.77-1.91z'/%3E%3Cpath id='polygon1059' class='cls-2' d='M29.98 5.38V0l1.83 4.26-1.83 1.12z'/%3E%3Cpath id='polygon1061' class='cls-1' d='M31.81 4.26l1.63 1.84-3.46-.72 1.83-1.12z'/%3E%3Cpath id='polygon1063' class='cls-3' d='M29.98 5.38z'/%3E%3Cpath id='polygon1065' class='cls-2' d='M29.98 5.38l3.46.72.82 4.3-4.28-5.02z'/%3E%3Cpath id='polygon1067' class='cls-1' d='M34.26 10.4h-4.28V5.38l4.28 5.02z'/%3E%3Crect id='rect1069' transform='rotate(-44.9 29.975 5.387)' y='5.38' x='29.98' class='cls-3'/%3E%3Cpath id='polygon1071' class='cls-1' d='M29.98 5.38v5.02l-1.25-3.05 1.25-1.97z'/%3E%3Cpath id='polygon1073' class='cls-1' d='M29.98 5.38l-1.25 1.97-3.04-1.25 4.29-.72z'/%3E%3Cpath id='polygon1075' class='cls-1' d='M29.98 5.38L25.69 1.8 29.98 0v5.38z'/%3E%3Cpath id='polygon1077' class='cls-1' d='M25.69 6.1V1.8l4.29 3.58-4.29.72z'/%3E%3Cpath id='polygon1079' class='cls-2' d='M20.6 5.66l.16-2.79 4.93-1.07-5.09 3.86z'/%3E%3Cpath id='polygon1081' class='cls-1' d='M25.69 1.8v4.3l-5.09-.44 5.09-3.86z'/%3E%3Cpath id='polygon1083' class='cls-3' d='M20.6 5.66z'/%3E%3Cpath id='polygon1085' class='cls-1' d='M20.6 5.66l5.09.44-3.12 1.16-1.97-1.6z'/%3E%3Cpath id='polygon1087' class='cls-1' d='M22.57 7.26l-1.16 3.14-.81-4.74 1.97 1.6z'/%3E%3Crect id='rect1089' transform='rotate(-44.9 20.596 5.663)' y='5.66' x='20.6' class='cls-3'/%3E%3Cpath id='polygon1091' class='cls-1' d='M20.6 5.66l.81 4.74-4.28-.28 3.47-4.46z'/%3E%3Cpath id='polygon1093' class='cls-2' d='M20.6 5.66l-3.47-1 3.63-1.79-.16 2.79z'/%3E%3Cpath id='polyline1095' class='cls-2' d='M20.6 5.66l-3.47 4.46V4.66l3.47 1'/%3E%3Cpath id='polygon1097' class='cls-1' d='M29.98 15.41V10.4h4.28l-4.28 5.01z'/%3E%3Cpath id='polygon1099' class='cls-2' d='M34.26 10.4l-.82 4.3-3.46.71 4.28-5.01z'/%3E%3Cpath id='polygon1101' class='cls-3' d='M29.98 15.41z'/%3E%3Cpath id='polygon1103' class='cls-2' d='M29.98 15.41l3.46-.71-1.66 1.8-1.8-1.09z'/%3E%3Cpath id='polygon1105' class='cls-2' d='M31.78 16.5l-1.8 1.41v-2.5l1.8 1.09z'/%3E%3Crect id='rect1107' transform='rotate(-44.9 29.981 15.42)' y='15.41' x='29.98' class='cls-3'/%3E%3Cpath id='polygon1109' class='cls-2' d='M29.98 15.41v2.5l-4.29 1.08 4.29-3.58z'/%3E%3Cpath id='polygon1111' class='cls-1' d='M29.98 15.41l-4.29 3.58V14.7l4.29.71z'/%3E%3Cpath id='polygon1113' class='cls-1' d='M29.98 15.41l-1.26-1.97 1.26-3.04v5.01z'/%3E%3Cpath id='polygon1115' class='cls-1' d='M25.69 14.7l3.03-1.26 1.26 1.97-4.29-.71z'/%3E%3Cpath id='polygon1117' class='cls-1' d='M20.72 17.2l.69-6.8 1.29 3-1.98 3.8z'/%3E%3Cpath id='polygon1119' class='cls-1' d='M22.7 13.4l2.99 1.3-4.97 2.5 1.98-3.8z'/%3E%3Cpath id='polygon1121' class='cls-3' d='M20.72 17.2z'/%3E%3Cpath id='polygon1123' class='cls-1' d='M20.72 17.2l4.97-2.5v4.29l-4.97-1.79z'/%3E%3Crect id='rect1125' transform='rotate(-44.9 20.716 17.202)' y='17.2' x='20.72' class='cls-3'/%3E%3Cpath id='polygon1127' class='cls-1' d='M20.72 17.2l-3.59-7.08 4.28.28-.69 6.8z'/%3E%3Cpath id='polygon1129' class='cls-2' d='M17.13 21.24V10.12l3.59 7.08-3.59 4.04z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E\");background-repeat:no-repeat;background-size:45px 28px}.control.mapray-attribution{padding:0 5px;background-color:hsla(0,0%,100%,.5);margin:0}.mapray-attribution.mapray-attribution-compact{min-height:24px;padding:2px 0;margin:10px;position:relative;background-color:#fff;border-radius:3px 12px 12px 3px}.mapray-attribution.mapray-attribution-compact:hover{padding:2px 24px 2px 4px;visibility:visible}.control-bottom-left>.mapray-attribution.mapray-attribution-compact:hover,.control-top-left>.mapray-attribution.mapray-attribution-compact:hover{padding:2px 4px 2px 24px;border-radius:12px 3px 3px 12px}.mapray-attribution.mapray-attribution-compact .mapray-attribution-container{display:none}.mapray-attribution.mapray-attribution-compact:hover .mapray-attribution-container{margin:0 10px;display:block}.mapray-attribution.mapray-attribution-compact:after{content:\"\";cursor:pointer;position:absolute;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16.933 16.933' height='64' width='64'%3E%3Ccircle stroke-width='.051' stroke='%23999' fill='%237f7f7f' r='8.309' cy='288.53' cx='8.467' transform='translate(0 -280.07)'/%3E%3Cg style='font-feature-settings:normal;font-variant-caps:normal;font-variant-ligatures:normal;font-variant-numeric:normal'%3E%3Cpath d='M9.7 6.393v8.469q0 .395-.242.665-.366.425-1.032.425-.752 0-1.1-.53-.154-.242-.154-.56v-8.47q0-.578.502-.877.347-.212.762-.212.492 0 .868.28.395.308.395.81zM8.444.97q.425 0 .81.242.763.453.763 1.34 0 .618-.425 1.071-.463.511-1.167.511-.396 0-.752-.193-.82-.463-.82-1.398 0-.733.55-1.196Q7.856.97 8.444.97z' aria-label='i' fill='%23fff'/%3E%3C/g%3E%3C/svg%3E\");background-size:contain;width:24px;height:24px;margin:2px 0;box-sizing:border-box;border-radius:12px}.control-top-left>.mapray-attribution.mapray-attribution-compact:after{top:0;left:0}.control-top-right>.mapray-attribution.mapray-attribution-compact:after{top:0;right:0}.control-bottom-left>.mapray-attribution.mapray-attribution-compact:after{bottom:0;left:0}.control-bottom-right>.mapray-attribution.mapray-attribution-compact:after{bottom:0;right:0}.mapray-attribution a{font-family:Noto Sans JP,sans-serif;font-size:12px;color:#000;text-decoration:none;padding:0 5px}.mapray-attribution a:hover{color:inherit;text-decoration:underline}";
styleInject(css_248z);

class r$C extends Error{constructor(r){super(r),this.name="mapray.animation.AnimationError";}}

class t$F{constructor(t){this._ntime=t;}static get MIN_TIME(){return n$14}static get MAX_TIME(){return s$w}static get MIN_NTIME(){return e$B}static get MAX_NTIME(){return r$B}static fromNumber(e){return new t$F(e)}toNumber(){return this._ntime}equals(t){return this._ntime==t._ntime}lessThan(t){return this._ntime<t._ntime}lessEqual(t){return this._ntime<=t._ntime}}const e$B=-Number.MAX_VALUE,r$B=+Number.MAX_VALUE,n$14=t$F.fromNumber(e$B),s$w=t$F.fromNumber(r$B);

class t$E{constructor(e,t,s=!1,r=!1){this._lower=e,this._upper=t,this._l_open=s,this._u_open=r;}static get UNIVERSAL(){return s$v}get lower(){return this._lower}get upper(){return this._upper}get l_open(){return this._l_open}get u_open(){return this._u_open}isEmpty(){let e=this._lower,t=this._upper;return t.lessThan(e)||t.equals(e)&&(this._l_open||this._u_open)}isSingle(){return this._lower.equals(this._upper)&&!(this._l_open||this._u_open)}isProper(){return this._lower.lessThan(this._upper)}precedes(e){if(this.isEmpty()||e.isEmpty())return !0;{let t=this._upper,s=this._u_open,r=e._lower,n=e._l_open;return t.lessThan(r)||t.equals(r)&&(s||n)}}includes(e){if(e.isEmpty())return !0;{let t=this._lower,s=e._lower,r=this._l_open,n=e._l_open,_=t.lessThan(s)||t.equals(s)&&(!r||n),i=this._upper,p=e._upper,u=this._u_open,l=e._u_open,h=p.lessThan(i)||p.equals(i)&&(l||!u);return _&&h}}includesTime(e){let t=this._lower,s=t.lessThan(e)||t.equals(e)&&!this._l_open,r=this._upper,n=e.lessThan(r)||e.equals(r)&&!this._u_open;return s&&n}hasIntersection(e){return !this.getIntersection(e).isEmpty()}getPrecedings(){return this.isEmpty()?s$v:new t$E(t$F.MIN_TIME,this._lower,!1,!this._l_open)}getFollowings(){return this.isEmpty()?s$v:new t$E(this._upper,t$F.MAX_TIME,!this._u_open,!1)}getIntersection(e){return this._getIntersectionByLower(e._lower,e._l_open)._getIntersectionByUpper(e._upper,e._u_open)}getUnion(e){if(this.isEmpty())return e.isEmpty()?[]:[e];if(e.isEmpty())return [this];let s=this._lower,r=this._upper,n=this._l_open,_=this._u_open,i=e._lower,p=e._upper,u=e._l_open,l=e._u_open;if(r.lessThan(i)||r.equals(i)&&_&&u)return [this,e];if(p.lessThan(s)||s.equals(p)&&n&&l)return [e,this];let[h,o]=s.lessThan(i)||s.equals(i)&&u?[s,n]:[i,u],[a,w]=p.lessThan(r)||p.equals(r)&&l?[r,_]:[p,l];return [new t$E(h,a,o,w)]}getDifference(e){let t=this._getIntersectionByUpper(e._lower,!e._l_open),s=this._getIntersectionByLower(e._upper,!e._u_open);return t.getUnion(s)}getComplement(){return s$v.getDifference(this)}_getIntersectionByLower(e,s){return e.lessThan(this._lower)||e.equals(this._lower)&&this._l_open?this:new t$E(e,this._upper,s,this._u_open)}_getIntersectionByUpper(e,s){return this._upper.lessThan(e)||this._upper.equals(e)&&this._u_open?this:new t$E(this._lower,e,this._l_open,s)}}const s$v=new t$E(t$F.MIN_TIME,t$F.MAX_TIME);

let _$c;class e$A{constructor(e){this._compare=e,this._root=_$c,this._size=0;}get size(){return this._size}clone(){let i=new e$A(this._compare);return this._root!==_$c&&(i._root=this._root._clone(_$c)),i._size=this._size,i}isEmpty(){return this._root===_$c}findFirst(){return this._root!==_$c?this._root._findMinimum():null}findLast(){return this._root!==_$c?this._root._findMaximum():null}findLower(_){return this._root._findLowerBound(_,this._compare)}findUpper(_){return this._root._findUpperBound(_,this._compare)}findEqual(_){return this._root._findEqual(_,this._compare)}clear(){this._root=_$c,this._size=0;}insert(i,r){let t=this._root,n=_$c;const d=this._compare;for(;t!==_$c;)if(n=t,d(i,t.key))t=t._child_L;else {if(!d(t.key,i))return t._value=r,t;t=t._child_R;}const h=new e$A.Item(n,i,r);return h._is_red=!0,n===_$c?this._root=h:d(i,n.key)?n._child_L=h:n._child_R=h,++this._size,this._insert_fixup(h),h}_insert_fixup(_){let e=_;for(;e._parent._is_red;)if(e._parent===e._parent._parent._child_L){let _=e._parent._parent._child_R;_._is_red?(e._parent._is_red=!1,_._is_red=!1,e._parent._parent._is_red=!0,e=e._parent._parent):(e===e._parent._child_R&&(e=e._parent,this._rotate_L(e)),e._parent._is_red=!1,e._parent._parent._is_red=!0,this._rotate_R(e._parent._parent));}else {let _=e._parent._parent._child_L;_._is_red?(e._parent._is_red=!1,_._is_red=!1,e._parent._parent._is_red=!0,e=e._parent._parent):(e===e._parent._child_L&&(e=e._parent,this._rotate_R(e)),e._parent._is_red=!1,e._parent._parent._is_red=!0,this._rotate_L(e._parent._parent));}this._root._is_red=!1;}remove(_,e){if(void 0===e)return this._remove(_);for(let i=_;i!=e;)i=this._remove(i);return e}_remove(e){const i=e.findSuccessor();let r,t;if(e._child_L===_$c)r=e._is_red,t=e._child_R,this._replace(e._child_R,e);else if(e._child_R===_$c)r=e._is_red,t=e._child_L,this._replace(e._child_L,e);else {const _=i;r=_._is_red,t=_._child_R,_._parent===e?t._parent=_:(this._replace(_._child_R,_),_._child_R=e._child_R,_._child_R._parent=_),this._replace(_,e),_._child_L=e._child_L,_._child_L._parent=_,_._is_red=e._is_red;}return --this._size,r||this._remove_fixup(t),i}_remove_fixup(_){let e=_;for(;e!==this._root&&!e._is_red;)if(e===e._parent._child_L){let _=e._parent._child_R;_._is_red&&(_._is_red=!1,e._parent._is_red=!0,this._rotate_L(e._parent),_=e._parent._child_R),_._child_L._is_red||_._child_R._is_red?(_._child_R._is_red||(_._child_L._is_red=!1,_._is_red=!0,this._rotate_R(_),_=e._parent._child_R),_._is_red=e._parent._is_red,e._parent._is_red=!1,_._child_R._is_red=!1,this._rotate_L(e._parent),e=this._root):(_._is_red=!0,e=e._parent);}else {let _=e._parent._child_L;_._is_red&&(_._is_red=!1,e._parent._is_red=!0,this._rotate_R(e._parent),_=e._parent._child_L),_._child_R._is_red||_._child_L._is_red?(_._child_L._is_red||(_._child_R._is_red=!1,_._is_red=!0,this._rotate_L(_),_=e._parent._child_L),_._is_red=e._parent._is_red,e._parent._is_red=!1,_._child_L._is_red=!1,this._rotate_R(e._parent),e=this._root):(_._is_red=!0,e=e._parent);}e._is_red=!1;}_replace(e,i){let r=i._parent;r!==_$c?r._child_L===i?r._child_L=e:r._child_R=e:this._root=e,e._parent=r;}_rotate_L(e){let i=e._child_R;e._child_R=i._child_L,i._child_L!==_$c&&(i._child_L._parent=e),i._parent=e._parent,e._parent===_$c?this._root=i:e===e._parent._child_L?e._parent._child_L=i:e._parent._child_R=i,i._child_L=e,e._parent=i;}_rotate_R(e){let i=e._child_L;e._child_L=i._child_R,i._child_R!==_$c&&(i._child_R._parent=e),i._parent=e._parent,e._parent===_$c?this._root=i:e===e._parent._child_R?e._parent._child_R=i:e._parent._child_L=i,i._child_R=e,e._parent=i;}}!function(e){class i{constructor(e,i,r){this._parent=e,this._child_L=_$c,this._child_R=_$c,this._is_red=!1,this._key=i,this._value=r;}get key(){return this._key}get value(){return this._value}_clone(e){let r=new i(e,this._key,this._value);return this._child_L!==_$c&&(r._child_L=this._child_L._clone(r)),this._child_R!==_$c&&(r._child_R=this._child_R._clone(r)),r._is_red=this._is_red,r}_findMinimum(){let e=this;for(;e._child_L!==_$c;)e=e._child_L;return e}_findMaximum(){let e=this;for(;e._child_R!==_$c;)e=e._child_R;return e}findPredecessor(){if(this._child_L!==_$c)return this._child_L._findMaximum();let e=this,i=e._parent;for(;i!==_$c&&e===i._child_L;)e=i,i=e._parent;return i!==_$c?i:null}findSuccessor(){if(this._child_R!==_$c)return this._child_R._findMinimum();let e=this,i=e._parent;for(;i!==_$c&&e===i._child_R;)e=i,i=e._parent;return i!==_$c?i:null}_findLowerBound(e,i){let r=this;for(;r!==_$c;){if(i(e,r._key)){if(r._child_L!==_$c){let _=r._child_L._findLowerBound(e,i);if(null!==_)return _}return r}if(!i(r._key,e))return r;r=r._child_R;}return null}_findUpperBound(e,i){let r=this;for(;r!==_$c;){if(i(e,r._key)){if(r._child_L!==_$c){let _=r._child_L._findUpperBound(e,i);if(null!==_)return _}return r}r=r._child_R;}return null}_findEqual(e,i){let r=this;for(;r!==_$c;)if(i(e,r._key))r=r._child_L;else {if(!i(r._key,e))return r;r=r._child_R;}return null}_findLowerBoundR(e,i){let r=this;if(r._parent!==_$c)return r._findLowerBound(e,i);let t=r._findMinimum(),n=r._findMaximum();do{if(!i(e,t._key)&&!i(n._key,e))break;r._parent._child_L===r?n=r._findMaximum():t=r._findMinimum(),r=r._parent;}while(r._parent!==_$c);return r._findLowerBound(e,i)}}e.Item=i,_$c=new i;}(e$A||(e$A={}));var i$y=e$A;

class i$x{constructor(){this._imap=t$D();}clone(){let e=new i$x;return e._imap=this._imap.clone(),e}write(e){return this.remove(e),this._insert(e),this}remove(e){if(e.isEmpty())return this;let r=e.l_open?this._imap.findUpper(e.lower):this._imap.findLower(e.lower),i=null!==r?r.findPredecessor():this._imap.findLast();if(this._chopItem(i,e),null!==r&&e.includes(r.value)){let i=e.u_open?this._imap.findLower(e.upper):this._imap.findUpper(e.upper),n=null!==i?i.findPredecessor():this._imap.findLast(),t=e.includes(n.value)?i:n;this._imap.remove(r,t||void 0),this._chopItem(t,e);}else this._chopItem(r,e);return this}getNarrowed(e){const r=new i$x;if(e.isEmpty())return r;const n=this._imap.findUpper(e.lower),t=null!==n?n.findPredecessor():this._imap.findLast(),l=null!==t&&t.value.hasIntersection(e)?t:n,s=e.u_open?this._imap.findLower(e.upper):this._imap.findUpper(e.upper);for(let e=l;e!==s;e=e.findSuccessor())r._imap.insert(e.key,e.value);return r}static merge(r){let n=new i$x;n.write(t$E.UNIVERSAL);for(let e of r)n._merge_from_invariance(e);return n}_$getArray(){let e=[];for(let r=this._imap.findFirst();null!==r;r=r.findSuccessor())e.push(r.value);return e}_$modify(r){let i=r._imap.findFirst();if(null===i)return;let n=r._imap.findLast(),t=i.value,l=n.value;this.remove(new t$E(t.lower,l.upper,t.l_open,l.u_open));for(let e=i;null!==e;e=e.findSuccessor())this._insert(e.value);}_$expandIntervalByAlignment(r){const i=this._imap;let n,t;{const t=i.findLower(r.lower);if(null===t||!t.value.lower.equals(r.lower)||!r.l_open&&t.value.l_open){const l=null!==t?t.findPredecessor():i.findLast();n=null!==l?l.value.hasIntersection(r)?r:l.value.getFollowings():t$E.UNIVERSAL;}else n=r;}{const n=i.findLower(r.upper);if(null===n||!r.upper.equals(n.value.lower)||r.u_open&&n.value.l_open){const l=null!==n?n.findPredecessor():i.findLast();t=null!==l&&l.value.hasIntersection(r)&&(r.upper.lessThan(l.value.upper)||r.upper.equals(l.value.upper)&&(r.u_open||!l.value.u_open))?r:null!==n?n.value.getPrecedings():t$E.UNIVERSAL;}else t=r;}return new t$E(n.lower,t.upper,n.l_open,t.u_open)}_chopItem(e,r){if(null===e)return;let i=e.value.getDifference(r);this._imap.remove(e);for(let e of i)e.isProper()&&this._imap.insert(e.lower,e);}_insert(e){e.isProper()&&this._imap.insert(e.lower,e);}_merge_from_invariance(e){let r=t$D();for(let i=this._imap.findFirst();null!==i;i=i.findSuccessor())n$13(i.value,e,r);this._imap=r;}}function n$13(e,r,i){let n=r._imap,t=n.findLower(e.lower),l=null!==t?t.findPredecessor():null;null===l&&(l=n.findFirst());let s=n.findUpper(e.upper);for(let r=l;r!==s;r=r.findSuccessor()){let n=r.value,t=e.getIntersection(n);t.isProper()&&i.insert(t.lower,t);}}function t$D(){return new i$y(((e,r)=>e.lessThan(r)))}

class r$A{constructor(e){this._name=e;}get name(){return this._name}static register(e,s){if(t$C.has(e))throw new r$A.AlreadyRegisteredError("specified name ("+e+") has already been registered");return t$C.set(e,s),s}static find(e){let s=t$C.get(e);if(void 0===s)throw new r$A.NotRegisteredError("type with the specified name ("+e+") is not registered");return s}}!function(r){r.AlreadyRegisteredError=class extends r$C{constructor(e){super(e),this.name="mapray.animation.Type.AlreadyRegisteredError";}};r.NotRegisteredError=class extends r$C{constructor(e){super(e),this.name="mapray.animation.Type.NotRegisteredError";}};}(r$A||(r$A={}));const t$C=new Map;var s$u=r$A;

class t$B{constructor(){}static createMatrix(t){return t?new Float64Array(t):new Float64Array(16)}static createMatrixf(t){return t?new Float32Array(t):new Float32Array(16)}static createVector4(t){return t?new Float64Array(t):new Float64Array(4)}static createVector4f(t){return t?new Float32Array(t):new Float32Array(4)}static createVector3(t){return t?new Float64Array(t):new Float64Array(3)}static createVector3f(t){return t?new Float32Array(t):new Float32Array(3)}static createVector2(t){return t?new Float64Array(t):new Float64Array(2)}static createVector2f(t){return t?new Float32Array(t):new Float32Array(2)}static copyMatrix(t,r){for(var a=0;a<16;++a)r[a]=t[a];return r}static copyVector4(t,r){for(var a=0;a<4;++a)r[a]=t[a];return r}static copyVector3(t,r){for(var a=0;a<3;++a)r[a]=t[a];return r}static copyVector2(t,r){return r[0]=t[0],r[1]=t[1],r}static setIdentity(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static lengthSquared2(t){return t[0]*t[0]+t[1]*t[1]}static lengthSquared3(t){return t[0]*t[0]+t[1]*t[1]+t[2]*t[2]}static length2(r){return Math.sqrt(t$B.lengthSquared2(r))}static length3(r){return Math.sqrt(t$B.lengthSquared3(r))}static add2(t,r,a){return a[0]=t[0]+r[0],a[1]=t[1]+r[1],a}static add3(t,r,a){return a[0]=t[0]+r[0],a[1]=t[1]+r[1],a[2]=t[2]+r[2],a}static sub2(t,r,a){return a[0]=t[0]-r[0],a[1]=t[1]-r[1],a}static sub3(t,r,a){return a[0]=t[0]-r[0],a[1]=t[1]-r[1],a[2]=t[2]-r[2],a}static dot3(t,r){return t[0]*r[0]+t[1]*r[1]+t[2]*r[2]}static cross3(t,r,a){const e=t[1]*r[2]-t[2]*r[1],s=t[2]*r[0]-t[0]*r[2],i=t[0]*r[1]-t[1]*r[0];return a[0]=e,a[1]=s,a[2]=i,a}static normalize2(r,a){return t$B.scale2(1/t$B.length2(r),r,a)}static normalize3(r,a){return t$B.scale3(1/t$B.length3(r),r,a)}static scale2(t,r,a){return a[0]=t*r[0],a[1]=t*r[1],a}static scale3(t,r,a){return a[0]=t*r[0],a[1]=t*r[1],a[2]=t*r[2],a}static linearInterpolate2(t,r,a,e){const s=1-a;return e[0]=s*t[0]+a*r[0],e[1]=s*t[1]+a*r[1],e}static linearInterpolate3(t,r,a,e){const s=1-a;return e[0]=s*t[0]+a*r[0],e[1]=s*t[1]+a*r[1],e[2]=s*t[2]+a*r[2],e}static linearInterpolate4(t,r,a,e){const s=1-a;return e[0]=s*t[0]+a*r[0],e[1]=s*t[1]+a*r[1],e[2]=s*t[2]+a*r[2],e[3]=s*t[3]+a*r[3],e}static mul_AA(t,r,a){var e=t[0],s=t[4],i=t[8],n=t[12],c=t[1],o=t[5],h=t[9],l=t[13],u=t[2],E=t[6],M=t[10],d=t[14],g=r[0],A=r[4],R=r[8],D=r[12],G=r[1],_=r[5],m=r[9],v=r[13],y=r[2],x=r[6],V=r[10],w=r[14];return a[0]=e*g+s*G+i*y,a[1]=c*g+o*G+h*y,a[2]=u*g+E*G+M*y,a[3]=0,a[4]=e*A+s*_+i*x,a[5]=c*A+o*_+h*x,a[6]=u*A+E*_+M*x,a[7]=0,a[8]=e*R+s*m+i*V,a[9]=c*R+o*m+h*V,a[10]=u*R+E*m+M*V,a[11]=0,a[12]=e*D+s*v+i*w+n,a[13]=c*D+o*v+h*w+l,a[14]=u*D+E*v+M*w+d,a[15]=1,a}static mul_GA(t,r,a){var e=t[0],s=t[4],i=t[8],n=t[12],c=t[1],o=t[5],h=t[9],l=t[13],u=t[2],E=t[6],M=t[10],d=t[14],g=t[3],A=t[7],R=t[11],D=t[15],G=r[0],_=r[4],m=r[8],v=r[12],y=r[1],x=r[5],V=r[9],w=r[13],F=r[2],f=r[6],I=r[10],p=r[14];return a[0]=e*G+s*y+i*F,a[1]=c*G+o*y+h*F,a[2]=u*G+E*y+M*F,a[3]=g*G+A*y+R*F,a[4]=e*_+s*x+i*f,a[5]=c*_+o*x+h*f,a[6]=u*_+E*x+M*f,a[7]=g*_+A*x+R*f,a[8]=e*m+s*V+i*I,a[9]=c*m+o*V+h*I,a[10]=u*m+E*V+M*I,a[11]=g*m+A*V+R*I,a[12]=e*v+s*w+i*p+n,a[13]=c*v+o*w+h*p+l,a[14]=u*v+E*w+M*p+d,a[15]=g*v+A*w+R*p+D,a}static mul_PzA(t,r,a){var e=t[0],s=t[8],i=t[12],n=t[5],c=t[9],o=t[13],h=t[10],l=t[14],u=t[11],E=t[15],M=r[0],d=r[4],g=r[8],A=r[12],R=r[1],D=r[5],G=r[9],_=r[13],m=r[2],v=r[6],y=r[10],x=r[14];return a[0]=e*M+s*m,a[1]=n*R+c*m,a[2]=h*m,a[3]=u*m,a[4]=e*d+s*v,a[5]=n*D+c*v,a[6]=h*v,a[7]=u*v,a[8]=e*g+s*y,a[9]=n*G+c*y,a[10]=h*y,a[11]=u*y,a[12]=e*A+s*x+i,a[13]=n*_+c*x+o,a[14]=h*x+l,a[15]=u*x+E,a}static inverse_A(t,r){var a=t[0],e=t[4],s=t[8],i=t[12],n=t[1],c=t[5],o=t[9],h=t[13],l=t[2],u=t[6],E=t[10],M=t[14],d=c*E-u*o,g=l*o-n*E,A=n*u-l*c,R=u*s-e*E,D=a*E-l*s,G=l*e-a*u,_=e*o-c*s,m=n*s-a*o,v=a*c-n*e,y=-(i*d+h*R+M*_),x=-(i*g+h*D+M*m),V=-(i*A+h*G+M*v),w=1/(a*d+e*g+s*A);return r[0]=d*w,r[1]=g*w,r[2]=A*w,r[3]=0,r[4]=R*w,r[5]=D*w,r[6]=G*w,r[7]=0,r[8]=_*w,r[9]=m*w,r[10]=v*w,r[11]=0,r[12]=y*w,r[13]=x*w,r[14]=V*w,r[15]=1,r}static transformPosition_A(t,r,a){var e;const s=t,i=r[0],n=r[1],c=null!==(e=r[2])&&void 0!==e?e:0;return a[0]=i*s[0]+n*s[4]+c*s[8]+s[12],a[1]=i*s[1]+n*s[5]+c*s[9]+s[13],this.isVector3(a)&&(a[2]=i*s[2]+n*s[6]+c*s[10]+s[14]),a}static transformDirection_A(t,r,a){const e=t,s=r[0],i=r[1],n=r[2];return a[0]=s*e[0]+i*e[4]+n*e[8],a[1]=s*e[1]+i*e[5]+n*e[9],a[2]=s*e[2]+i*e[6]+n*e[10],a}static transformPlane_A(t,r,a){var e=t,s=r[0],i=r[1],n=r[2],c=r[3];return a[0]=s*e[0]+i*e[1]+n*e[2],a[1]=s*e[4]+i*e[5]+n*e[6],a[2]=s*e[8]+i*e[9]+n*e[10],a[3]=s*e[12]+i*e[13]+n*e[14]+c,a}static normalizePlane(t,r){const a=t[0],e=t[1],s=t[2],i=1/Math.sqrt(a*a+e*e+s*s);for(let a=0;a<4;++a)r[a]=t[a]*i;return r}static iscs_to_gocs_matrix(r,a){var e=r.longitude*t$B.DEGREE,s=r.latitude*t$B.DEGREE,i=Math.sin(e),n=Math.cos(e),c=Math.sin(s),o=Math.cos(s),h=t$B.EARTH_RADIUS+r.height;return a[0]=-i,a[1]=n,a[2]=0,a[3]=0,a[4]=-n*c,a[5]=-i*c,a[6]=o,a[7]=0,a[8]=o*n,a[9]=o*i,a[10]=c,a[11]=0,a[12]=h*o*n,a[13]=h*o*i,a[14]=h*c,a[15]=1,a}static gocs_to_iscs(r,a){var e=r[0],s=r[1],i=r[2],n=e*e,c=s*s,o=i*i;return 0!=e||0!=s?(a.latitude=Math.atan(i/Math.sqrt(n+c))/t$B.DEGREE,a.longitude=Math.atan2(s,e)/t$B.DEGREE):(a.latitude=i>0?90:i<0?-90:0,a.longitude=0),a.height=Math.sqrt(n+c+o)-t$B.EARTH_RADIUS,a}static frustum_matrix(t,r,a,e,s,i,n){return n[0]=2*s/(r-t),n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=2*s/(e-a),n[6]=0,n[7]=0,n[8]=(r+t)/(r-t),n[9]=(e+a)/(e-a),n[10]=(i+s)/(s-i),n[11]=-1,n[12]=0,n[13]=0,n[14]=2*i*s/(s-i),n[15]=0,n}static lookat_matrix(r,a,e,s){var i=t$B._xaxis,n=t$B._yaxis,c=t$B._zaxis;return c[0]=r[0]-a[0],c[1]=r[1]-a[1],c[2]=r[2]-a[2],t$B.normalize3(c,c),t$B.cross3(e,c,i),t$B.normalize3(i,i),t$B.cross3(c,i,n),s[0]=i[0],s[1]=i[1],s[2]=i[2],s[3]=0,s[4]=n[0],s[5]=n[1],s[6]=n[2],s[7]=0,s[8]=c[0],s[9]=c[1],s[10]=c[2],s[11]=0,s[12]=r[0],s[13]=r[1],s[14]=r[2],s[15]=1,s}static rotation_matrix(r,a,e){var s=a*t$B.DEGREE,i=Math.sin(s),n=Math.cos(s),c=r[0],o=r[1],h=r[2];return e[0]=c*c*(1-n)+n,e[1]=c*o*(1-n)+h*i,e[2]=c*h*(1-n)-o*i,e[3]=0,e[4]=c*o*(1-n)-h*i,e[5]=o*o*(1-n)+n,e[6]=o*h*(1-n)+c*i,e[7]=0,e[8]=c*h*(1-n)+o*i,e[9]=o*h*(1-n)-c*i,e[10]=h*h*(1-n)+n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}static kml_model_matrix(r,a,e,s,i){var n=r*t$B.DEGREE,c=a*t$B.DEGREE,o=e*t$B.DEGREE,h=Math.sin(n),l=Math.cos(n),u=Math.sin(c),E=Math.cos(c),M=Math.sin(o),d=Math.cos(o),g=s[0],A=s[1],R=s[2];return i[0]=g*(h*M*u+l*d),i[1]=g*(l*M*u-h*d),i[2]=g*M*E,i[3]=0,i[4]=A*h*E,i[5]=A*l*E,i[6]=-A*u,i[7]=0,i[8]=R*(h*d*u-l*M),i[9]=R*(l*d*u+h*M),i[10]=R*d*E,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}static gudermannian(t){return 2*Math.atan(Math.exp(t))-Math.PI/2}static invGudermannian(t){return Math.log(Math.tan(t/2+Math.PI/4))}static clamp(t,r,a){return Math.min(Math.max(t,r),a)}static isVector2(t){return 2===t.length}static isVector3(t){return 3===t.length}static isVector4(t){return 4===t.length}}t$B.EARTH_RADIUS=6378137,t$B.DEGREE=.017453292519943295,t$B.LOG2PI=1.6514961294723187,t$B._xaxis=t$B.createVector3(),t$B._yaxis=t$B.createVector3(),t$B._zaxis=t$B.createVector3(),function(t){t.maprayLog2=Math.log2||(t=>1.4426950408889634*Math.log(t));}(t$B||(t$B={}));class r$z{constructor(t=0,r=0,a=0){this.longitude=t,this.latitude=r,this.altitude=a;}clone(){return new r$z(this.longitude,this.latitude,this.altitude)}assign(t){return this.longitude=t.longitude,this.latitude=t.latitude,this.altitude=t.altitude,this}setFromArray(t){return this.longitude=t[0],this.latitude=t[1],this.altitude=t.length>2?t[2]:0,this}setFromGocs(r){var a=r[0],e=r[1],s=r[2],i=a*a,n=e*e,c=s*s;return 0!=a||0!=e?(this.latitude=Math.atan(s/Math.sqrt(i+n))/t$B.DEGREE,this.longitude=Math.atan2(e,a)/t$B.DEGREE):(this.latitude=s>0?90:s<0?-90:0,this.longitude=0),this.altitude=Math.sqrt(i+n+c)-t$B.EARTH_RADIUS,this}getAsGocs(r){var a=this.longitude*t$B.DEGREE,e=this.latitude*t$B.DEGREE,s=t$B.EARTH_RADIUS+this.altitude,i=Math.cos(e);return r[0]=s*i*Math.cos(a),r[1]=s*i*Math.sin(a),r[2]=s*Math.sin(e),r}getMlocsToGocsMatrix(r){var a=this.longitude*t$B.DEGREE,e=this.latitude*t$B.DEGREE,s=Math.sin(a),i=Math.cos(a),n=Math.sin(e),c=Math.cos(e),o=t$B.EARTH_RADIUS+this.altitude;return r[0]=-s,r[1]=i,r[2]=0,r[3]=0,r[4]=-i*n,r[5]=-s*n,r[6]=c,r[7]=0,r[8]=c*i,r[9]=c*s,r[10]=n,r[11]=0,r[12]=o*c*i,r[13]=o*c*s,r[14]=o*n,r[15]=1,r}getUpwardVector(r){var a=this.longitude*t$B.DEGREE,e=this.latitude*t$B.DEGREE,s=Math.cos(e);return r[0]=s*Math.cos(a),r[1]=s*Math.sin(a),r[2]=Math.sin(e),r}getGeographicalDistance(r){var a=this.getAsGocs(t$B.createVector3()),e=r.getAsGocs(t$B.createVector3()),s=t$B.cross3(a,e,t$B.createVector3());return t$B.EARTH_RADIUS*Math.atan2(Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]),t$B.dot3(a,e))}static toGocsArray(r,a,e){for(var s=t$B.DEGREE,i=t$B.EARTH_RADIUS,n=0;n<a;++n){var c=3*n,o=r[c]*s,h=r[c+1]*s,l=i+r[c+2],u=Math.cos(h);e[c]=l*u*Math.cos(o),e[c+1]=l*u*Math.sin(o),e[c+2]=l*Math.sin(h);}return e}}class a$n{constructor(t=0,r=0,a=0){this.heading=t,this.tilt=r,this.roll=a;}clone(){return new a$n(this.heading,this.tilt,this.roll)}assign(t){return this.heading=t.heading,this.tilt=t.tilt,this.roll=t.roll,this}getTransformMatrix(r,a){var e=this.heading*t$B.DEGREE,s=this.tilt*t$B.DEGREE,i=this.roll*t$B.DEGREE,n=Math.sin(e),c=Math.cos(e),o=Math.sin(s),h=Math.cos(s),l=Math.sin(i),u=Math.cos(i),E=r[0],M=r[1],d=r[2];return a[0]=E*(n*l*o+c*u),a[1]=E*(c*l*o-n*u),a[2]=E*l*h,a[3]=0,a[4]=M*n*h,a[5]=M*c*h,a[6]=-M*o,a[7]=0,a[8]=d*(n*u*o-c*l),a[9]=d*(c*u*o+n*l),a[10]=d*u*h,a[11]=0,a[12]=0,a[13]=0,a[14]=0,a[15]=1,a}}var e$z=t$B;

class r$y extends s$u{constructor(){super("boolean"),this._convertibles=new Set([this]);}postinit(){this._number_type=s$u.find("number"),this._convertibles.add(this._number_type);}isConvertible(e){return this._convertibles.has(e)}convertValue(e,t){return e===this?t:t>=.5}getDefaultValue(){return !1}getCloneValue(e){return e}}class n$12 extends s$u{constructor(){super("number"),this._convertibles=new Set([this]);}postinit(){this._boolean_type=s$u.find("boolean"),this._convertibles.add(this._boolean_type);}isConvertible(e){return this._convertibles.has(e)}convertValue(e,t){return e===this?t:t?1:0}getDefaultValue(){return 0}getCloneValue(e){return e}}class s$t extends s$u{constructor(){super("string");}postinit(){}isConvertible(e){return e===this}convertValue(e,t){return t}getDefaultValue(){return ""}getCloneValue(e){return e}}class o$x extends s$u{constructor(){super("vector2");}postinit(){}isConvertible(e){return e===this}convertValue(e,t){return t}getDefaultValue(){return e$z.createVector2()}getCloneValue(e){return e$z.createVector2(e)}}class u$d extends s$u{constructor(){super("vector3");}postinit(){}isConvertible(e){return e===this}convertValue(e,t){return t}getDefaultValue(){return e$z.createVector3()}getCloneValue(e){return e$z.createVector3(e)}}class i$w extends s$u{constructor(){super("vector4");}postinit(){}isConvertible(e){return e===this}convertValue(e,t){return t}getDefaultValue(){return e$z.createVector4()}getCloneValue(e){return e$z.createVector4(e)}}class l$b extends s$u{constructor(){super("matrix");}postinit(){}isConvertible(e){return e===this}convertValue(e,t){return t}getDefaultValue(){return e$z.setIdentity(e$z.createMatrix())}getCloneValue(e){return e$z.createMatrix(e)}}function a$m(){const t=[r$y,n$12,s$t,u$d,o$x,i$w,l$b],a=[];for(let r of t){let t=new r;s$u.register(t.name,t),a.push(t);}for(let e of a)e.postinit();}

a$m();

class e$y{constructor(){this._value_change_listeners=new Set;}notifyValueChange(e){if(!e.isEmpty())for(let a of this._value_change_listeners)a(e);}addValueChangeListener(e){this._value_change_listeners.add(e);}removeValueChangeListener(e){this._value_change_listeners.delete(e);}}

class s$s{constructor(){this._prev_time=null,this._track_binders=new Map,this._dirty_binders=new Set,this._vary_curves=new i$v;}update(e){if(this._update_dirty_binders(e),null!==this._prev_time){const t=this._vary_curves.getVaryCurves(this._prev_time,e);for(let s of t){this._track_binders.get(s).updateBinders(e);}}this._flush_dirty_binders(),this._prev_time=e;}_$register(e){this._dirty_binders.add(e);}_$unregister(e){if(this._dirty_binders.delete(e));else {this._track_binders.get(e._$curve).unregister(e);}}get _$track_binders(){return this._track_binders}get _$dirty_binders(){return this._dirty_binders}get _$prev_time(){return this._prev_time}get _$vary_curves(){return this._vary_curves}_update_dirty_binders(e){for(let t of this._dirty_binders)t._$update(e);}_flush_dirty_binders(){for(let e of Array.from(this._dirty_binders)){this._dirty_binders.delete(e);let t=e._$curve,s=this._track_binders.get(t);void 0===s?(s=new r$x(this,t,e),this._track_binders.set(t,s)):s.register(e);}}}class r$x{constructor(t,s,r){this._updater=t,this._curve=s,this._binders=new Set([r]),this._invariance=s.getInvariance(t$E.UNIVERSAL),this._listener=e=>{this._onValueChange(e);},s.addValueChangeListener(this._listener),t._$vary_curves.addCurve(s,this._invariance);}register(e){this._binders.add(e);}unregister(e){this._binders.delete(e),this._binders.size>0||(this._updater._$vary_curves.removeCurve(this._curve,this._invariance),this._curve.removeValueChangeListener(this._listener),this._updater._$track_binders.delete(this._curve));}updateBinders(e){for(let t of this._binders)t._$update(e);}_onValueChange(e){if(e.includesTime(this._updater._$prev_time))this._move_to_dirty_binders();else {let t=this._curve.getInvariance(e);this._updater._$vary_curves.modifyCurve(this._curve,e,t,this._invariance),this._invariance._$modify(t);}}_move_to_dirty_binders(){for(let e of Array.from(this._binders))this.unregister(e),this._updater._$dirty_binders.add(e);}}class i$v{constructor(){this._continuous=o$w(),this._oneshot=o$w(),this._oneshot_L=o$w(),this._oneshot_R=o$w();}addCurve(t,s,r=t$E.UNIVERSAL){const i=s.getNarrowed(r)._$getArray();if(0==i.length)this._addToGeneric(t,r);else {const e=i.length-1;{const e=i[0],s=r.getIntersection(e.getPrecedings());s.isEmpty()?_$b(r,e)&&!this._hasContiguous_L(e,t)&&(e.l_open?this._addToOneshotGroup(t,e,this._oneshot_R):e.getPrecedings().isEmpty()||this._addToOneshotGroup(t,e,this._oneshot_L)):this._addToGeneric(t,s);}for(let s=0;s<e;++s){const e=i[s].getFollowings(),r=i[s+1].getPrecedings(),n=e.getIntersection(r);n.isEmpty()?this._addToOneshotGroup(t,e,e.l_open?this._oneshot_R:this._oneshot_L):this._addToGeneric(t,n);}{const s=i[e],n=r.getIntersection(s.getFollowings());n.isEmpty()?u$c(r,s)&&!this._hasContiguous_R(s,t)&&(s.u_open?this._addToOneshotGroup(t,s,this._oneshot_L):s.getFollowings().isEmpty()||this._addToOneshotGroup(t,s,this._oneshot_R)):this._addToGeneric(t,n);}}}_hasContiguous_L(e,t){const s=this._continuous,r=s.findLower(e.lower),i=null!==r?r.findPredecessor():s.findLast();if(null!==i){const s=i.value,r=s.interval;if(r.upper.equals(e.lower)&&(e.l_open&&!r.u_open||!e.l_open&&r.u_open)&&s.curves.has(t))return !0}return !1}_hasContiguous_R(e,t){const s=this._continuous.findLower(e.upper);if(null===s)return !1;const r=s.value,i=r.interval;return !!i.lower.equals(e.upper)&&(!(i.l_open&&e.u_open||!i.l_open&&!e.u_open)&&r.curves.has(t))}removeCurve(t,s,r=t$E.UNIVERSAL){const i=s.getNarrowed(r)._$getArray();if(0==i.length)this._removeForGeneric(t,r);else {const s=i.length-1;{const e=i[0],s=r.getIntersection(e.getPrecedings());s.isEmpty()?_$b(r,e)&&this._removeForOneshotGroup(t,r):this._removeForGeneric(t,s);}for(let e=0;e<s;++e){const s=i[e].getFollowings(),r=i[e+1].getPrecedings(),n=s.getIntersection(r);n.isEmpty()?this._removeForOneshotGroup(t,s):this._removeForGeneric(t,n);}{const n=i[s],o=r.getIntersection(n.getFollowings());if(o.isEmpty()){if(u$c(r,n)){const s=r.upper;this._removeForOneshotGroup(t,new t$E(s,s));}}else this._removeForGeneric(t,o);}}}modifyCurve(e,t,s,r){const i=r._$expandIntervalByAlignment(t);this.removeCurve(e,r,i),this.addCurve(e,s,i);}getVaryCurves(e,t){return e.lessThan(t)?this._collectCurves(e,t):t.lessThan(e)?this._collectCurves(t,e):[]}_addToGeneric(e,t){t.isProper()?this._addToContinuous(e,t):t.isSingle()&&this._addToOneshotGroup(e,t,this._oneshot);}_addToOneshotGroup(e,t,s){let r=t.lower,i=s.findEqual(r);null===i&&(i=s.insert(r,new Set)),i.value.add(e);}_addToContinuous(e,t){let s=t,r=e;for(;;){let e=this._removeFirstCrossInContinuous(s);if(null!==e){let t=e.cc.interval,i=e.cc.curves,n=e.cross,o=s.getPrecedings().getIntersection(t);if(o.isEmpty()){let e=s.getIntersection(t.getPrecedings());e.isEmpty()||this._addForContinuous(e,r);}else this._addForContinuous(o,new Set(i));let _=s.getFollowings().getIntersection(t);if(_.isEmpty()){this._addForContinuous(n,i.add(r));let e=s.getIntersection(t.getFollowings());if(!e.isEmpty()){s=e;continue}}else this._addForContinuous(_,new Set(i)),this._addForContinuous(n,i.add(r));}else this._addForContinuous(s,r);break}}_removeFirstCrossInContinuous(e){let t=this._continuous,s=t.findUpper(e.lower),r=null!==s?s.findPredecessor():t.findLast();if(null!==r){let s=e.getIntersection(r.value.interval);if(!s.isEmpty()){let e=r.value;return t.remove(r),{cc:e,cross:s}}}if(null!==s){let r=e.getIntersection(s.value.interval);if(!r.isEmpty()){let e=s.value;return t.remove(s),{cc:e,cross:r}}}return null}_addForContinuous(e,t){let s=e.lower;if(e.isSingle()){let e=this._oneshot.findEqual(s);null===e&&(e=this._oneshot.insert(s,new Set));let r=e.value;if(t instanceof Set)for(let e of t)r.add(e);else r.add(t);}else this._continuous.insert(s,new n$11(e,t));}_removeForGeneric(e,t){t.isProper()?this._removeForContinuous(e,t):t.isSingle()&&this._removeForOneshotGroup(e,t);}_removeForOneshotGroup(e,t){const s=t.lower;for(const t of [this._oneshot,this._oneshot_L,this._oneshot_R]){const r=t.findEqual(s);if(null!==r){const s=r.value;s.has(e)&&(s.delete(e),0==s.size&&t.remove(r));break}}}_removeForContinuous(e,t){{const s=this._continuous,r=s.findUpper(t.lower),i=null!==r?r.findPredecessor():s.findLast(),n=s.findUpper(t.upper);for(let t=i||r;t!==n;){let r=t.value.curves;r.delete(e),t=0==r.size?s.remove(t):t.findSuccessor();}}{let s=this._oneshot,r=s.findLower(t.lower),i=s.findUpper(t.upper);for(let t=r;t!==i;){let r=t.value;r.delete(e),t=0==r.size?s.remove(t):t.findSuccessor();}}}_collectCurves(e,t){let s=new Set;return this._collectContinuousCurves(e,t,s),this._collectOneshotCurves(e,t,this._oneshot,!0,!0,s),this._collectOneshotCurves(e,t,this._oneshot_L,!1,!0,s),this._collectOneshotCurves(e,t,this._oneshot_R,!0,!1,s),s}_collectContinuousCurves(e,t,s){let r=this._continuous.findLower(e);if(null!==r){let t=r.findPredecessor();null!==t&&t.value.interval.includesTime(e)&&(r=t);}else {let t=this._continuous.findLast();null!==t&&t.value.interval.includesTime(e)&&(r=t);}let i=this._continuous.findLower(t);if(null!==i){let e=i.value.interval;e.lower.equals(t)&&!e.l_open&&(i=i.findSuccessor());}for(let e=r;e!==i;e=e.findSuccessor())for(let t of e.value.curves)s.add(t);}_collectOneshotCurves(e,t,s,r,i,n){let o=r?s.findLower(e):s.findUpper(e),_=r?s.findUpper(t):s.findLower(t);for(let e=o;e!==_;e=e.findSuccessor())for(let t of e.value)n.add(t);}}class n$11{constructor(e,t){this.interval=e,this.curves=new Set(t instanceof Set?t:[t]);}}function o$w(){return new i$y(((e,t)=>e.lessThan(t)))}function _$b(e,t){return e.lower.equals(t.lower)&&(e.l_open&&t.l_open||!e.l_open&&!t.l_open)}function u$c(e,t){return e.upper.equals(t.upper)&&(e.u_open&&t.u_open||!e.u_open&&!t.u_open)}

class a$l extends r$C{constructor(r){super(r),this.name="mapray.animation.TypeMismatchError";}}

class e$x{constructor(e,r,s,i){if(!r.isTypeSupported(s))throw new a$l("type mismatch error");this._updater=e,this._curve=r,this._type=s,this._setter=i,e._$register(this);}get updater(){return this._updater}get curve(){return this._curve}get type(){return this._type}get setter(){return this._setter}unbind(){this._updater._$unregister(this);}get _$curve(){return this._curve}_$update(t){let e=this._curve.getValue(t,this._type);(0, this._setter)(e);}}

class t$A{constructor(){}}!function(t){t.Parameter=class{constructor(t,s){this._id=t,this._types=s.concat();}get id(){return this._id}get types(){return this._types}};}(t$A||(t$A={}));var s$r=t$A;

class r$w extends s$r{constructor(){super(),this._entries=new Map,this._bounds=new Map,this._descendant_unbinders=[];}addEntry(t,e,n,s){this._entries.set(t,new r$w.Entry(e,n,s));const i=this._bounds.get(t);i&&(i.unbind(),this._bounds.delete(t));}addDescendantUnbinder(t){this._descendant_unbinders.push(t);}enumSupportedParameters(){let e=[];for(let[n,s]of this._entries)e.push(new s$r.Parameter(n,s.types));return e}isBound(t){return this._bounds.has(t)}getBoundUpdater(t){const e=this._bounds.get(t);return void 0!==e?e.updater:void 0}getBoundCurve(t){const e=this._bounds.get(t);return void 0!==e?e.curve:void 0}bind(t,r,i){const o=this._entries.get(t);if(void 0===o)throw new r$C("unsupported parameter");this.unbind(t);const d=o.types,u=1===d.length?d[0]:(()=>{if(!o.type_solver)throw new a$l("");return o.type_solver(i)})();if(null==u||!i.isTypeSupported(u))throw new a$l("type mismatch error");this._bounds.set(t,new e$x(r,i,u,o.setter));}unbind(t){let e=this._bounds.get(t);void 0!==e&&(e.unbind(),this._bounds.delete(t));}unbindAll(){for(let[,t]of this._bounds)t.unbind();this._bounds.clear();}unbindAllRecursively(){for(let t of this._descendant_unbinders)t();this.unbindAll();}}!function(t){t.Entry=class{constructor(t,e,s){if(t.length<1||t.length>=2&&!e)throw new r$C("bad parameter entry");this.types=t.slice(),this.type_solver=e||void 0,this.setter=s;}};}(r$w||(r$w={}));var i$u=r$w;

class t$z{static getDimension(t){return s$u.find("number")===t?1:s$u.find("vector2")===t?2:s$u.find("vector3")===t?3:s$u.find("vector4")===t?4:0}static findKeyFrameIndex(e,t,r,i){let n=r,s=i;for(;;){if(!(s-n>=2)){let r=t[n];return e.lessThan(r)?n:s}{let r=Math.floor((n+s)/2),i=t[r];if(i.lessThan(e))n=r;else {if(!e.lessThan(i))return r+1;s=r;}}}return 0}static findFirstTypeSupported(e,t){for(let r of t)if(e.isTypeSupported(r))return r;return null}}

class a$k extends e$y{constructor(e,s){super();const r=t$z.getDimension(e);if(0==r)throw new r$C("unsupported type");if(this._value_type=e,this._dimension=r,void 0!==s)this.setKeyFrames(s);else {const s=t$F.fromNumber(0),r=t$F.fromNumber(1),i=e.getDefaultValue();this.setKeyFrames([s,i,r,i]);}}setKeyFrames(e){const t=this._dimension;this._num_keyframes=e.length/2,this._key_times=new Array(this._num_keyframes),this._key_values=new Float64Array(this._num_keyframes*t);for(let s=0,r=0;s<this._num_keyframes;++s,r+=t){const i=e[2*s],n=e[2*s+1];if(this._key_times[s]=i,1==t)this._key_values[r]=n;else for(let e=0;e<t;++e)this._key_values[r+e]=n[e];}this.notifyValueChange(t$E.UNIVERSAL);}isTypeSupported(e){const t=this._value_type;return e.isConvertible(t)}getValue(e,t){const s=this._value_type,r=this._getInterpolatedValue(e);return t.convertValue(s,r)}getInvariance(e){const t=this._key_times[0],i=this._key_times[this._num_keyframes-1],n=new t$E(t,i,!0,!0),a=new i$x;return a.write(n.getPrecedings()),a.write(n.getFollowings()),a.getNarrowed(e)}_getInterpolatedValue(e){const t=t$z.findKeyFrameIndex(e,this._key_times,0,this._num_keyframes);return 0==t?this._createKeyFrameValue(0):t==this._num_keyframes?this._createKeyFrameValue(t-1):this._createValueBy2Keys(t-1,t,e)}_createKeyFrameValue(e){const t=this._dimension,s=this._key_values;if(1==t)return s[e];{const r=t*e,i=new Float64Array(t);for(let e=0;e<t;++e)i[e]=s[r+e];return i}}_createValueBy2Keys(e,t,s){const r=this._key_times[e].toNumber(),i=this._key_times[t].toNumber(),n=(s.toNumber()-r)/(i-r),a=1-n,o=this._dimension,m=this._key_values;if(1==o)return a*m[e]+n*m[t];{let s=o*e,r=o*t,i=new Float64Array(o);for(let e=0;e<o;++e)i[e]=a*m[s+e]+n*m[r+e];return i}}}

s$u.find("number");

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class e$w{static get(r,i,s={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.fetch(e$w.METHOD.GET,r,i,void 0,s)}))}static post(r,i,s,o={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.fetch(e$w.METHOD.POST,r,i,s,o)}))}static patch(r,i,s,o={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.fetch(e$w.METHOD.PATCH,r,i,s,o)}))}static put(r,i,s,o={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.fetch(e$w.METHOD.PUT,r,i,s,o)}))}static delete(r,i,s={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.fetch(e$w.METHOD.DELETE,r,i,void 0,s)}))}static fetch(r,i,s,o,c={}){return __awaiter(this,void 0,void 0,(function*(){const t=s?"?"+Object.keys(s).map((t=>t+"="+s[t])).join("&"):"";let n;c.method=r,o&&(c.body="object"==typeof o?JSON.stringify(o):o);try{n=yield fetch(i+t,c);}catch(t){throw new e$w.FetchError("Failed to fetch",i,void 0,t)}if(!n.ok)throw new e$w.FetchError("Failed to fetch: "+n.statusText,i,n);return n}))}static isJson(t){return t.startsWith("application/json")||"model/gltf+json"===t}}!function(t){var e,r;(e=t.METHOD||(t.METHOD={})).GET="GET",e.POST="POST",e.PATCH="PATCH",e.PUT="PUT",e.DELETE="DELETE",t.CONTENT_TYPE="Content-Type",(r=t.RESPONSE_STATUS||(t.RESPONSE_STATUS={}))[r.NO_CONTENT=204]="NO_CONTENT";class i extends Error{constructor(t,e,r,s){super(t+" "+e),Error.captureStackTrace&&Error.captureStackTrace(this,i),this.name="FetchError",this.url=e,this.response=r,this.cause=s;let o=!1;s&&(o="The user aborted a request."===s.message,this.stack+="\nCaused-By: "+(s.stack||s)),this.is_aborted=o;}}t.FetchError=i;}(e$w||(e$w={}));var r$v=e$w;

class e$v{constructor(t){this._api=t;}getId(){return this._id}getOwnerId(){return this._owner_id}getName(){return this._name}getDescription(){return this._description}getCreatedAt(){return this._created_at}getUpdatedAt(){return this._updated_at}_restoreFromJson(t){this._id=t.id,this._owner_id=t.owner_id,this._name=t.name,this._description=t.description,this._created_at=new Date(t.created_at),this._updated_at=new Date(t.updated_at);}}class r$u extends e$v{constructor(t){super(t);}_restoreFromJson(t){super._restoreFromJson(t);}static createFromJson(t,e){const s=new r$u(t);return s._restoreFromJson(e),s}}class s$q extends e$v{constructor(t){super(t);}getOrigin(){return this._origin}getUrl(){return this._url}getSceneId(){return this._scene_id}getPath(){return this._path}getSRID(){return this._srid}getSrcFileType(){return this._src_file_type}getDstFileType(){return this._dst_file_type}getExtensions(){return this._extensions}_restoreFromJson(e){super._restoreFromJson(e),this._url=e.url,this._scene_id=e.scene_id,this._path=e.path,this._srid=e.srid,this._origin=new r$z(e.x,e.y,e.z),this._src_file_type=e.src_file_type,this._dst_file_type=e.dst_file_type,this._extensions=e.extensions;}static createFromJson(t,e){const r=new s$q(t);return r._restoreFromJson(e),r}}class o$v extends e$v{constructor(t){super(t);}getUrl(){return this._url}getBoundingBox(){return this._bounding_box}getContentRoot(){return this._content_root}getFormat(){return this._format}_restoreFromJson(t){if(super._restoreFromJson(t),this._url=t.url,!t.fileinfo)return;const e=t.fileinfo.bbox;this._bounding_box=n$10.isBBox3d(e)?e:[e[0],e[1],0,e[2],e[3],0],this._content_root=Array.isArray(t.fileinfo.content_root)?t.fileinfo.content_root.join("/"):t.fileinfo.content_root,this._format=t.fileinfo.format;}static createFromJson(t,e){const r=new o$v(t);return r._restoreFromJson(e),r}}var n$10;!function(t){t.isBBox3d=function(t){return 6===t.length};}(n$10||(n$10={}));class i$t extends e$v{constructor(t){super(t);}_restoreFromJson(t){super._restoreFromJson(t),this._x=t.x,this._y=t.y,this._z=t.z;}static createFromJson(t,e){const r=new i$t(t);return r._restoreFromJson(e),r}}

const e$u=new RegExp("^data:"),n$$=new RegExp("^https?://");var o$u;!function(o){function r(t,e){const n=document.createElement("canvas");n.width=t,n.height=e;const o=n.getContext("2d");if(!o)throw new Error("Cannot get context of canvas");return o}function a(t){const e=t.naturalWidth,n=t.naturalHeight,o=r(e,n);return o.drawImage(t,0,0,e,n),o.canvas.toDataURL()}function i(t){return t.toDataURL()}o.createCanvasContext=r,o.createCanvasContextFromImage=function(t){const e=o.createCanvasContext(t.width,t.height);return e.drawImage(t,0,0),e},o.copyTo2dCanvasContext=function(t,e){const n=e?e.canvas:document.createElement("canvas");n.width!==t.width&&(n.width=t.width),n.height!==t.height&&(n.height=t.height);const o=n.getContext("2d");if(!o)throw new Error("Cannot get context of canvas");return o.drawImage(t,0,0),o},o.loadImage=function(e,n={}){return __awaiter(this,void 0,void 0,(function*(){return yield new Promise(((t,o)=>{const r=new Image;r.onload=e=>t(r),r.onerror=t=>o(new Error("Failed to load image")),"omit"!==n.credentials&&(r.crossOrigin="include"===n.credentials?"use-credentials":"anonymous"),r.src=e instanceof Blob?URL.createObjectURL(e):e;}))}))},o.waitForLoad=function(e){return __awaiter(this,void 0,void 0,(function*(){if(!e.src)throw new Error("src was not set");return e.complete?e:yield new Promise(((t,n)=>{const o=e.onload,r=e.onerror;e.onload=n=>{"function"==typeof o&&o(n),t(e);},e.onerror=t=>{r&&r(t),n(new Error("Failed to load image"));};}))}))},o.convertSVGToDataURL=function(t){return "data:image/svg+xml;charset=utf-8,"+encodeURIComponent(t)},o.toBase64String=function(t){return t instanceof HTMLImageElement?a(t):i(t)},o.convertImageToBase64String=a,o.convertCanvasToBase64String=i,o.resolveUrl=function(t,o){return e$u.test(o)||n$$.test(o)?o:t+o},o.SYSTEM_FONT_FAMILY="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'";}(o$u||(o$u={}));var r$t=o$u;

class o$t{load(e={}){return __awaiter(this,void 0,void 0,(function*(){throw new Error("Not Implemented")}))}loadAsJson(e={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.load(Object.assign(Object.assign({},e),{type:o$t.Type.JSON}))}))}loadAsBinary(e={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.load(Object.assign(Object.assign({},e),{type:o$t.Type.BINARY}))}))}loadAsImage(e={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.load(Object.assign(Object.assign({},e),{type:o$t.Type.IMAGE}))}))}loadAsText(e={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.load(Object.assign(Object.assign({},e),{type:o$t.Type.TEXT}))}))}cancel(){}loadSubResourceSupported(){return !1}loadSubResource(e,t={}){return __awaiter(this,void 0,void 0,(function*(){throw new Error("Not Supported")}))}resolveResourceSupported(){return !1}resolveResource(r){throw new Error("Not Supported")}toString(){return "Resource"}}!function(r){var e;r.defaultTransformCallback=function(r,e){return {url:r}},(e=r.Type||(r.Type={}))[e.JSON=0]="JSON",e[e.BINARY=1]="BINARY",e[e.IMAGE=2]="IMAGE",e[e.TEXT=3]="TEXT";}(o$t||(o$t={}));class s$p extends o$t{constructor(r,e={}){super(),this._url=r;const t=r.lastIndexOf("/");if(-1===t)throw new Error("invalid url");this._base_url=this._url.substr(0,t+1),this._type=e.type||o$t.Type.JSON,this._transform=e.transform||o$t.defaultTransformCallback,this._abort_ctrl=new AbortController;}get url(){return this._url}load(e={}){return __awaiter(this,void 0,void 0,(function*(){return yield this._loadURLResource(this._url,e.type||this._type,e)}))}cancel(){this._abort_ctrl.abort();}loadSubResourceSupported(){return !0}loadSubResource(e,o={}){return __awaiter(this,void 0,void 0,(function*(){return yield this._loadURLResource(r$t.resolveUrl(this._base_url,e),o.type,o)}))}resolveResourceSupported(){return !0}resolveResource(r){const e=r$t.resolveUrl(this._base_url,r);return new s$p(e,{transform:this._transform})}_loadURLResource(s,i,n={}){return __awaiter(this,void 0,void 0,(function*(){const r=this._transform(s,i);if(i===o$t.Type.IMAGE)return yield r$t.loadImage(r.url,r);const u=this._make_fetch_params(r)||{};n.signal&&(u.signal=n.signal);const a=yield r$v.get(r.url,void 0,u);if(!a.ok)throw new Error(a.statusText);return i===o$t.Type.JSON?yield a.json():i===o$t.Type.TEXT?yield a.text():i===o$t.Type.BINARY?yield a.arrayBuffer():a}))}_make_fetch_params(r){var e={signal:this._abort_ctrl.signal,credentials:r.credentials||"omit"};return r.headers&&(e.headers=r.headers),e}toString(){return "URLResource("+this.url+")"}}var i$s=o$t;

class i$r extends i$s{constructor(e,t){const r=t.lastIndexOf("/");if(-1===r)throw new Error("invalid url");super(),this._api=e,this._url=t,this._base_url=t.substr(0,r+1);}load(r={}){return __awaiter(this,void 0,void 0,(function*(){const e=yield this._api.fetch(r$v.METHOD.GET,this._url);return r.type===i$s.Type.JSON?yield e.json():e}))}loadSubResourceSupported(){return !0}loadSubResource(i,o={}){return __awaiter(this,void 0,void 0,(function*(){const e=r$t.resolveUrl(this._base_url,i),u=yield this._api.fetch(r$v.METHOD.GET,e);if(!u.ok)throw new Error(u.statusText);return o.type===i$s.Type.BINARY?yield u.arrayBuffer():o.type===i$s.Type.IMAGE?yield r$t.loadImage(yield u.blob()):u}))}}class o$s extends i$s{constructor(e,t){super(),this._api=e,this._datasetId=t;}load(){return __awaiter(this,void 0,void 0,(function*(){return yield this._api.getFeatures(this._datasetId)}))}}class u$b extends i$s{constructor(e,t){super(),this._api=e,this._datasetIds=Array.isArray(t)?t:[t];}load(){return __awaiter(this,void 0,void 0,(function*(){return yield this._api.get3DDatasetScene(this._datasetIds)}))}resolveResourceSupported(){return !0}resolveResource(e){return new i$r(this._api,e)}}class n$_ extends i$s{constructor(e,t){super(),this._api=e,this._datasetId=t;}load(){return __awaiter(this,void 0,void 0,(function*(){return yield this._api.getPointCloudDataset(this._datasetId)}))}resolveResourceSupported(){return !0}resolveResource(e){return new i$r(this._api,e)}}class d$9 extends i$s{constructor(e,t){super(),this._api=e,this._sceneId=t;}load(){return __awaiter(this,void 0,void 0,(function*(){return yield this._api.getSceneContent(this._sceneId)}))}resolveResourceSupported(){return !0}resolveResource(e){return new i$r(this._api,e)}}

class c$a{constructor(t,e,i,r){this.version=t,this.basePath=e?e.endsWith("/")?e.slice(0,-1):e:l$a,this._header_key=i,this._header_value=r;}loadDatasets(e=1,r=5){return __awaiter(this,void 0,void 0,(function*(){return (yield this.getDatasets(e,r)).map((t=>r$u.createFromJson(this,t)))}))}loadDataset(e){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.getDataset(e);return r$u.createFromJson(this,t)}))}load3DDatasets(e=1,i=5){return __awaiter(this,void 0,void 0,(function*(){return (yield this.get3DDatasets(e,i)).map((t=>s$q.createFromJson(this,t)))}))}load3DDataset(e){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.get3DDataset(e);return s$q.createFromJson(this,t)}))}loadPointCloudDatasets(e=1,i=5){return __awaiter(this,void 0,void 0,(function*(){return (yield this.getPointCloudDatasets(e,i)).map((t=>o$v.createFromJson(this,t)))}))}loadPointCloudDataset(e){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.getPointCloudDataset(e);return o$v.createFromJson(this,t)}))}loadScenes(e=1,i=5){return __awaiter(this,void 0,void 0,(function*(){return (yield this.getScenes(e,i)).map((t=>i$t.createFromJson(this,t)))}))}loadScene(e){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.getScene(e);return i$t.createFromJson(this,t)}))}getDatasetAsResource(t){return new o$s(this,t)}get3DDatasetAsResource(t){return new u$b(this,t)}getPointCloudDatasetAsResource(t){return new n$_(this,t)}getSceneAsResource(t){return new d$9(this,t)}get(i,r,o,s={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.fetchAPI(r$v.METHOD.GET,i,r,o,void 0,s)}))}post(i,r,o,s,n={}){return __awaiter(this,void 0,void 0,(function*(){return "string"!=typeof s&&(s=JSON.stringify(s)),yield this.fetchAPI(r$v.METHOD.POST,i,r,o,s,n)}))}patch(i,r,o,s,n={}){return __awaiter(this,void 0,void 0,(function*(){return "string"!=typeof s&&(s=JSON.stringify(s)),yield this.fetchAPI(r$v.METHOD.PATCH,i,r,o,s,n)}))}put(i,r,o,s,n={}){return __awaiter(this,void 0,void 0,(function*(){return "string"!=typeof s&&(s=JSON.stringify(s)),yield this.fetchAPI(r$v.METHOD.PUT,i,r,o,s,n)}))}delete(i,r,o,s={}){return __awaiter(this,void 0,void 0,(function*(){return yield this.fetchAPI(r$v.METHOD.DELETE,i,r,o,void 0,s)}))}fetchAPI(e,i,r,o,s,n={}){return __awaiter(this,void 0,void 0,(function*(){const t=this.basePath+"/"+i+"/"+this.version+(r.length>0?"/"+r.join("/"):""),a=yield this.fetch(e,t,o,s,n);return yield a.json()}))}fetch(i,r,o,s,n={}){return __awaiter(this,void 0,void 0,(function*(){let t;(n.headers||(n.headers={}))[this._header_key]=this._header_value;try{t=yield r$v.fetch(i,r,o,s,n);}catch(t){if(t instanceof r$v.FetchError&&t.response){let e;try{e=yield t.response.json();}catch(e){throw new u$a(-1,"Failed to fetch",r,void 0,t)}throw new u$a(e.code,e.error,r,t.response,t)}throw new u$a(-1,"Failed to fetch",r,void 0,t)}return t}))}}!function(t){var e;(e=t.TokenType||(t.TokenType={})).API_KEY="@@_CloudApi.TokenType.API_KEY",e.ACCESS_TOKEN="@@_CloudApi.TokenType.ACCESS_TOKEN";}(c$a||(c$a={}));class u$a extends r$v.FetchError{constructor(t,e,i,r,o){super(e+" ["+t+"]",i),Error.captureStackTrace&&Error.captureStackTrace(this,u$a),this.name="CloudApiError",this.code=t,this.response=r,this.cause=o,o&&(this.stack+="\nCaused-By: "+o.stack);}}const l$a="https://cloud.mapray.com";

var $version = 8;
var $root = {
	version: {
		required: true,
		type: "enum",
		values: [
			8
		],
		doc: "Style specification version number. Must be 8.",
		example: 8
	},
	name: {
		type: "string",
		doc: "A human-readable name for the style.",
		example: "Bright"
	},
	metadata: {
		type: "*",
		doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
	},
	center: {
		type: "array",
		value: "number",
		doc: "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
		example: [
			-73.9749,
			40.7736
		]
	},
	zoom: {
		type: "number",
		doc: "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
		example: 12.5
	},
	bearing: {
		type: "number",
		"default": 0,
		period: 360,
		units: "degrees",
		doc: "Default bearing, in degrees. The bearing is the compass direction that is \"up\"; for example, a bearing of 90° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
		example: 29
	},
	pitch: {
		type: "number",
		"default": 0,
		units: "degrees",
		doc: "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
		example: 50
	},
	light: {
		type: "light",
		doc: "The global light source.",
		example: {
			anchor: "viewport",
			color: "white",
			intensity: 0.4
		}
	},
	sources: {
		required: true,
		type: "sources",
		doc: "Data source specifications.",
		example: {
			"mapbox-streets": {
				type: "vector",
				url: "mapbox://mapbox.mapbox-streets-v6"
			}
		}
	},
	sprite: {
		type: "string",
		doc: "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
		example: "mapbox://sprites/mapbox/bright-v8"
	},
	glyphs: {
		type: "string",
		doc: "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
		example: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
	},
	transition: {
		type: "transition",
		doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.",
		example: {
			duration: 300,
			delay: 0
		}
	},
	layers: {
		required: true,
		type: "array",
		value: "layer",
		doc: "Layers will be drawn in the order of this array.",
		example: [
			{
				id: "water",
				source: "mapbox-streets",
				"source-layer": "water",
				type: "fill",
				paint: {
					"fill-color": "#00ffff"
				}
			}
		]
	}
};
var sources = {
	"*": {
		type: "source",
		doc: "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."
	}
};
var source = [
	"source_vector",
	"source_raster",
	"source_raster_dem",
	"source_geojson",
	"source_video",
	"source_image"
];
var source_vector = {
	type: {
		required: true,
		type: "enum",
		values: {
			vector: {
				doc: "A vector tile source."
			}
		},
		doc: "The type of the source."
	},
	url: {
		type: "string",
		doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
	},
	tiles: {
		type: "array",
		value: "string",
		doc: "An array of one or more tile source URLs, as in the TileJSON spec."
	},
	bounds: {
		type: "array",
		value: "number",
		length: 4,
		"default": [
			-180,
			-85.051129,
			180,
			85.051129
		],
		doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
	},
	scheme: {
		type: "enum",
		values: {
			xyz: {
				doc: "Slippy map tilenames scheme."
			},
			tms: {
				doc: "OSGeo spec scheme."
			}
		},
		"default": "xyz",
		doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
	},
	minzoom: {
		type: "number",
		"default": 0,
		doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
	},
	maxzoom: {
		type: "number",
		"default": 22,
		doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
	},
	attribution: {
		type: "string",
		doc: "Contains an attribution to be displayed when the map is shown to a user."
	},
	promoteId: {
		type: "promoteId",
		doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers."
	},
	volatile: {
		type: "boolean",
		"default": false,
		doc: "A setting to determine whether a source's tiles are cached locally.",
		"sdk-support": {
			"basic functionality": {
				android: "9.3.0",
				ios: "5.10.0"
			}
		}
	},
	"*": {
		type: "*",
		doc: "Other keys to configure the data source."
	}
};
var source_raster = {
	type: {
		required: true,
		type: "enum",
		values: {
			raster: {
				doc: "A raster tile source."
			}
		},
		doc: "The type of the source."
	},
	url: {
		type: "string",
		doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
	},
	tiles: {
		type: "array",
		value: "string",
		doc: "An array of one or more tile source URLs, as in the TileJSON spec."
	},
	bounds: {
		type: "array",
		value: "number",
		length: 4,
		"default": [
			-180,
			-85.051129,
			180,
			85.051129
		],
		doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
	},
	minzoom: {
		type: "number",
		"default": 0,
		doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
	},
	maxzoom: {
		type: "number",
		"default": 22,
		doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
	},
	tileSize: {
		type: "number",
		"default": 512,
		units: "pixels",
		doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
	},
	scheme: {
		type: "enum",
		values: {
			xyz: {
				doc: "Slippy map tilenames scheme."
			},
			tms: {
				doc: "OSGeo spec scheme."
			}
		},
		"default": "xyz",
		doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
	},
	attribution: {
		type: "string",
		doc: "Contains an attribution to be displayed when the map is shown to a user."
	},
	volatile: {
		type: "boolean",
		"default": false,
		doc: "A setting to determine whether a source's tiles are cached locally.",
		"sdk-support": {
			"basic functionality": {
				android: "9.3.0",
				ios: "5.10.0"
			}
		}
	},
	"*": {
		type: "*",
		doc: "Other keys to configure the data source."
	}
};
var source_raster_dem = {
	type: {
		required: true,
		type: "enum",
		values: {
			"raster-dem": {
				doc: "A RGB-encoded raster DEM source"
			}
		},
		doc: "The type of the source."
	},
	url: {
		type: "string",
		doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
	},
	tiles: {
		type: "array",
		value: "string",
		doc: "An array of one or more tile source URLs, as in the TileJSON spec."
	},
	bounds: {
		type: "array",
		value: "number",
		length: 4,
		"default": [
			-180,
			-85.051129,
			180,
			85.051129
		],
		doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
	},
	minzoom: {
		type: "number",
		"default": 0,
		doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
	},
	maxzoom: {
		type: "number",
		"default": 22,
		doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
	},
	tileSize: {
		type: "number",
		"default": 512,
		units: "pixels",
		doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
	},
	attribution: {
		type: "string",
		doc: "Contains an attribution to be displayed when the map is shown to a user."
	},
	encoding: {
		type: "enum",
		values: {
			terrarium: {
				doc: "Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info."
			},
			mapbox: {
				doc: "Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info."
			}
		},
		"default": "mapbox",
		doc: "The encoding used by this source. Mapbox Terrain RGB is used by default"
	},
	volatile: {
		type: "boolean",
		"default": false,
		doc: "A setting to determine whether a source's tiles are cached locally.",
		"sdk-support": {
			"basic functionality": {
				android: "9.3.0",
				ios: "5.10.0"
			}
		}
	},
	"*": {
		type: "*",
		doc: "Other keys to configure the data source."
	}
};
var source_geojson = {
	type: {
		required: true,
		type: "enum",
		values: {
			geojson: {
				doc: "A GeoJSON data source."
			}
		},
		doc: "The data type of the GeoJSON source."
	},
	data: {
		type: "*",
		doc: "A URL to a GeoJSON file, or inline GeoJSON."
	},
	maxzoom: {
		type: "number",
		"default": 18,
		doc: "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
	},
	attribution: {
		type: "string",
		doc: "Contains an attribution to be displayed when the map is shown to a user."
	},
	buffer: {
		type: "number",
		"default": 128,
		maximum: 512,
		minimum: 0,
		doc: "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."
	},
	filter: {
		type: "*",
		doc: "An expression for filtering features prior to processing them for rendering."
	},
	tolerance: {
		type: "number",
		"default": 0.375,
		doc: "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
	},
	cluster: {
		type: "boolean",
		"default": false,
		doc: "If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\n * `cluster` Is `true` if the point is a cluster \n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\n * `point_count` Number of original points grouped into this cluster\n * `point_count_abbreviated` An abbreviated point count"
	},
	clusterRadius: {
		type: "number",
		"default": 50,
		minimum: 0,
		doc: "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."
	},
	clusterMaxZoom: {
		type: "number",
		doc: "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered). Clusters are re-evaluated at integer zoom levels so setting clusterMaxZoom to 14 means the clusters will be displayed until z15."
	},
	clusterMinPoints: {
		type: "number",
		doc: "Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`."
	},
	clusterProperties: {
		type: "*",
		doc: "An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{\"property_name\": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `\"+\"` or `\"max\"`) — it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\n\nExample: `{\"sum\": [\"+\", [\"get\", \"scalerank\"]]}`.\n\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `[\"accumulated\"]` value, e.g.:\n`{\"sum\": [[\"+\", [\"accumulated\"], [\"get\", \"sum\"]], [\"get\", \"scalerank\"]]}`"
	},
	lineMetrics: {
		type: "boolean",
		"default": false,
		doc: "Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values."
	},
	generateId: {
		type: "boolean",
		"default": false,
		doc: "Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values."
	},
	promoteId: {
		type: "promoteId",
		doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`."
	}
};
var source_video = {
	type: {
		required: true,
		type: "enum",
		values: {
			video: {
				doc: "A video data source."
			}
		},
		doc: "The data type of the video source."
	},
	urls: {
		required: true,
		type: "array",
		value: "string",
		doc: "URLs to video content in order of preferred format."
	},
	coordinates: {
		required: true,
		doc: "Corners of video specified in longitude, latitude pairs.",
		type: "array",
		length: 4,
		value: {
			type: "array",
			length: 2,
			value: "number",
			doc: "A single longitude, latitude pair."
		}
	}
};
var source_image = {
	type: {
		required: true,
		type: "enum",
		values: {
			image: {
				doc: "An image data source."
			}
		},
		doc: "The data type of the image source."
	},
	url: {
		required: true,
		type: "string",
		doc: "URL that points to an image."
	},
	coordinates: {
		required: true,
		doc: "Corners of image specified in longitude, latitude pairs.",
		type: "array",
		length: 4,
		value: {
			type: "array",
			length: 2,
			value: "number",
			doc: "A single longitude, latitude pair."
		}
	}
};
var layer = {
	id: {
		type: "string",
		doc: "Unique layer name.",
		required: true
	},
	type: {
		type: "enum",
		values: {
			fill: {
				doc: "A filled polygon with an optional stroked border.",
				"sdk-support": {
					"basic functionality": {
						js: "0.10.0",
						android: "2.0.1",
						ios: "2.0.0",
						macos: "0.1.0"
					}
				}
			},
			line: {
				doc: "A stroked line.",
				"sdk-support": {
					"basic functionality": {
						js: "0.10.0",
						android: "2.0.1",
						ios: "2.0.0",
						macos: "0.1.0"
					}
				}
			},
			symbol: {
				doc: "An icon or a text label.",
				"sdk-support": {
					"basic functionality": {
						js: "0.10.0",
						android: "2.0.1",
						ios: "2.0.0",
						macos: "0.1.0"
					}
				}
			},
			circle: {
				doc: "A filled circle.",
				"sdk-support": {
					"basic functionality": {
						js: "0.10.0",
						android: "2.0.1",
						ios: "2.0.0",
						macos: "0.1.0"
					}
				}
			},
			heatmap: {
				doc: "A heatmap.",
				"sdk-support": {
					"basic functionality": {
						js: "0.41.0",
						android: "6.0.0",
						ios: "4.0.0",
						macos: "0.7.0"
					}
				}
			},
			"fill-extrusion": {
				doc: "An extruded (3D) polygon.",
				"sdk-support": {
					"basic functionality": {
						js: "0.27.0",
						android: "5.1.0",
						ios: "3.6.0",
						macos: "0.5.0"
					}
				}
			},
			raster: {
				doc: "Raster map textures such as satellite imagery.",
				"sdk-support": {
					"basic functionality": {
						js: "0.10.0",
						android: "2.0.1",
						ios: "2.0.0",
						macos: "0.1.0"
					}
				}
			},
			hillshade: {
				doc: "Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.",
				"sdk-support": {
					"basic functionality": {
						js: "0.43.0",
						android: "6.0.0",
						ios: "4.0.0",
						macos: "0.7.0"
					}
				}
			},
			background: {
				doc: "The background color or pattern of the map.",
				"sdk-support": {
					"basic functionality": {
						js: "0.10.0",
						android: "2.0.1",
						ios: "2.0.0",
						macos: "0.1.0"
					}
				}
			}
		},
		doc: "Rendering type of this layer.",
		required: true
	},
	metadata: {
		type: "*",
		doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
	},
	source: {
		type: "string",
		doc: "Name of a source description to be used for this layer. Required for all layer types except `background`."
	},
	"source-layer": {
		type: "string",
		doc: "Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources."
	},
	minzoom: {
		type: "number",
		minimum: 0,
		maximum: 24,
		doc: "The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden."
	},
	maxzoom: {
		type: "number",
		minimum: 0,
		maximum: 24,
		doc: "The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden."
	},
	filter: {
		type: "filter",
		doc: "A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `feature-state` expression is not supported in filter expressions."
	},
	layout: {
		type: "layout",
		doc: "Layout properties for the layer."
	},
	paint: {
		type: "paint",
		doc: "Default paint properties for this layer."
	}
};
var layout = [
	"layout_fill",
	"layout_line",
	"layout_circle",
	"layout_heatmap",
	"layout_fill-extrusion",
	"layout_symbol",
	"layout_raster",
	"layout_hillshade",
	"layout_background"
];
var layout_background = {
	visibility: {
		type: "enum",
		values: {
			visible: {
				doc: "The layer is shown."
			},
			none: {
				doc: "The layer is not shown."
			}
		},
		"default": "visible",
		doc: "Whether this layer is displayed.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		"property-type": "constant"
	}
};
var layout_fill = {
	"fill-sort-key": {
		type: "number",
		doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
		"sdk-support": {
			"basic functionality": {
				js: "1.2.0",
				android: "9.1.0",
				ios: "5.8.0",
				macos: "0.15.0"
			},
			"data-driven styling": {
				js: "1.2.0",
				android: "9.1.0",
				ios: "5.8.0",
				macos: "0.15.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {
				doc: "The layer is shown."
			},
			none: {
				doc: "The layer is not shown."
			}
		},
		"default": "visible",
		doc: "Whether this layer is displayed.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		"property-type": "constant"
	}
};
var layout_circle = {
	"circle-sort-key": {
		type: "number",
		doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
		"sdk-support": {
			"basic functionality": {
				js: "1.2.0",
				android: "9.2.0",
				ios: "5.9.0",
				macos: "0.16.0"
			},
			"data-driven styling": {
				js: "1.2.0",
				android: "9.2.0",
				ios: "5.9.0",
				macos: "0.16.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {
				doc: "The layer is shown."
			},
			none: {
				doc: "The layer is not shown."
			}
		},
		"default": "visible",
		doc: "Whether this layer is displayed.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		"property-type": "constant"
	}
};
var layout_heatmap = {
	visibility: {
		type: "enum",
		values: {
			visible: {
				doc: "The layer is shown."
			},
			none: {
				doc: "The layer is not shown."
			}
		},
		"default": "visible",
		doc: "Whether this layer is displayed.",
		"sdk-support": {
			"basic functionality": {
				js: "0.41.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		"property-type": "constant"
	}
};
var layout_line = {
	"line-cap": {
		type: "enum",
		values: {
			butt: {
				doc: "A cap with a squared-off end which is drawn to the exact endpoint of the line."
			},
			round: {
				doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
			},
			square: {
				doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
			}
		},
		"default": "butt",
		doc: "The display of line endings.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"line-join": {
		type: "enum",
		values: {
			bevel: {
				doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
			},
			round: {
				doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
			},
			miter: {
				doc: "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."
			}
		},
		"default": "miter",
		doc: "The display of lines when joining.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.40.0",
				android: "5.2.0",
				ios: "3.7.0",
				macos: "0.6.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"line-miter-limit": {
		type: "number",
		"default": 2,
		doc: "Used to automatically convert miter joins to bevel joins for sharp angles.",
		requires: [
			{
				"line-join": "miter"
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"line-round-limit": {
		type: "number",
		"default": 1.05,
		doc: "Used to automatically convert round joins to miter joins for shallow angles.",
		requires: [
			{
				"line-join": "round"
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"line-sort-key": {
		type: "number",
		doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
		"sdk-support": {
			"basic functionality": {
				js: "1.2.0",
				android: "9.1.0",
				ios: "5.8.0",
				macos: "0.15.0"
			},
			"data-driven styling": {
				js: "1.2.0",
				android: "9.1.0",
				ios: "5.8.0",
				macos: "0.15.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {
				doc: "The layer is shown."
			},
			none: {
				doc: "The layer is not shown."
			}
		},
		"default": "visible",
		doc: "Whether this layer is displayed.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		"property-type": "constant"
	}
};
var layout_symbol = {
	"symbol-placement": {
		type: "enum",
		values: {
			point: {
				doc: "The label is placed at the point where the geometry is located."
			},
			line: {
				doc: "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."
			},
			"line-center": {
				doc: "The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries."
			}
		},
		"default": "point",
		doc: "Label placement relative to its geometry.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"`line-center` value": {
				js: "0.47.0",
				android: "6.4.0",
				ios: "4.3.0",
				macos: "0.10.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"symbol-spacing": {
		type: "number",
		"default": 250,
		minimum: 1,
		units: "pixels",
		doc: "Distance between two symbol anchors.",
		requires: [
			{
				"symbol-placement": "line"
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"symbol-avoid-edges": {
		type: "boolean",
		"default": false,
		doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"symbol-sort-key": {
		type: "number",
		doc: "Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.",
		"sdk-support": {
			"basic functionality": {
				js: "0.53.0",
				android: "7.4.0",
				ios: "4.11.0",
				macos: "0.14.0"
			},
			"data-driven styling": {
				js: "0.53.0",
				android: "7.4.0",
				ios: "4.11.0",
				macos: "0.14.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"symbol-z-order": {
		type: "enum",
		values: {
			auto: {
				doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."
			},
			"viewport-y": {
				doc: "Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."
			},
			source: {
				doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data."
			}
		},
		"default": "auto",
		doc: "Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.",
		"sdk-support": {
			"basic functionality": {
				js: "0.49.0",
				android: "6.6.0",
				ios: "4.5.0",
				macos: "0.12.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"icon-allow-overlap": {
		type: "boolean",
		"default": false,
		doc: "If true, the icon will be visible even if it collides with other previously drawn symbols.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"icon-ignore-placement": {
		type: "boolean",
		"default": false,
		doc: "If true, other symbols can be visible even if they collide with the icon.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"icon-optional": {
		type: "boolean",
		"default": false,
		doc: "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
		requires: [
			"icon-image",
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"icon-rotation-alignment": {
		type: "enum",
		values: {
			map: {
				doc: "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line."
			},
			viewport: {
				doc: "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
			},
			auto: {
				doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
			}
		},
		"default": "auto",
		doc: "In combination with `symbol-placement`, determines the rotation behavior of icons.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"`auto` value": {
				js: "0.25.0",
				android: "4.2.0",
				ios: "3.4.0",
				macos: "0.3.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"icon-size": {
		type: "number",
		"default": 1,
		minimum: 0,
		units: "factor of the original icon size",
		doc: "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.35.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"icon-text-fit": {
		type: "enum",
		values: {
			none: {
				doc: "The icon is displayed at its intrinsic aspect ratio."
			},
			width: {
				doc: "The icon is scaled in the x-dimension to fit the width of the text."
			},
			height: {
				doc: "The icon is scaled in the y-dimension to fit the height of the text."
			},
			both: {
				doc: "The icon is scaled in both x- and y-dimensions."
			}
		},
		"default": "none",
		doc: "Scales the icon to fit around the associated text.",
		requires: [
			"icon-image",
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.21.0",
				android: "4.2.0",
				ios: "3.4.0",
				macos: "0.2.1"
			},
			"stretchable icons": {
				js: "1.6.0",
				android: "9.2.0",
				ios: "5.8.0",
				macos: "0.15.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"icon-text-fit-padding": {
		type: "array",
		value: "number",
		length: 4,
		"default": [
			0,
			0,
			0,
			0
		],
		units: "pixels",
		doc: "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",
		requires: [
			"icon-image",
			"text-field",
			{
				"icon-text-fit": [
					"both",
					"width",
					"height"
				]
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.21.0",
				android: "4.2.0",
				ios: "3.4.0",
				macos: "0.2.1"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"icon-image": {
		type: "resolvedImage",
		doc: "Name of image in sprite to use for drawing an image background.",
		tokens: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.35.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"icon-rotate": {
		type: "number",
		"default": 0,
		period: 360,
		units: "degrees",
		doc: "Rotates the icon clockwise.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.21.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"icon-padding": {
		type: "number",
		"default": 2,
		minimum: 0,
		units: "pixels",
		doc: "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"icon-keep-upright": {
		type: "boolean",
		"default": false,
		doc: "If true, the icon may be flipped to prevent it from being rendered upside-down.",
		requires: [
			"icon-image",
			{
				"icon-rotation-alignment": "map"
			},
			{
				"symbol-placement": [
					"line",
					"line-center"
				]
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"icon-offset": {
		type: "array",
		value: "number",
		length: 2,
		"default": [
			0,
			0
		],
		doc: "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"icon-anchor": {
		type: "enum",
		values: {
			center: {
				doc: "The center of the icon is placed closest to the anchor."
			},
			left: {
				doc: "The left side of the icon is placed closest to the anchor."
			},
			right: {
				doc: "The right side of the icon is placed closest to the anchor."
			},
			top: {
				doc: "The top of the icon is placed closest to the anchor."
			},
			bottom: {
				doc: "The bottom of the icon is placed closest to the anchor."
			},
			"top-left": {
				doc: "The top left corner of the icon is placed closest to the anchor."
			},
			"top-right": {
				doc: "The top right corner of the icon is placed closest to the anchor."
			},
			"bottom-left": {
				doc: "The bottom left corner of the icon is placed closest to the anchor."
			},
			"bottom-right": {
				doc: "The bottom right corner of the icon is placed closest to the anchor."
			}
		},
		"default": "center",
		doc: "Part of the icon placed closest to the anchor.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.40.0",
				android: "5.2.0",
				ios: "3.7.0",
				macos: "0.6.0"
			},
			"data-driven styling": {
				js: "0.40.0",
				android: "5.2.0",
				ios: "3.7.0",
				macos: "0.6.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"icon-pitch-alignment": {
		type: "enum",
		values: {
			map: {
				doc: "The icon is aligned to the plane of the map."
			},
			viewport: {
				doc: "The icon is aligned to the plane of the viewport."
			},
			auto: {
				doc: "Automatically matches the value of `icon-rotation-alignment`."
			}
		},
		"default": "auto",
		doc: "Orientation of icon when map is pitched.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.39.0",
				android: "5.2.0",
				ios: "3.7.0",
				macos: "0.6.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-pitch-alignment": {
		type: "enum",
		values: {
			map: {
				doc: "The text is aligned to the plane of the map."
			},
			viewport: {
				doc: "The text is aligned to the plane of the viewport."
			},
			auto: {
				doc: "Automatically matches the value of `text-rotation-alignment`."
			}
		},
		"default": "auto",
		doc: "Orientation of text when map is pitched.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.21.0",
				android: "4.2.0",
				ios: "3.4.0",
				macos: "0.2.1"
			},
			"`auto` value": {
				js: "0.25.0",
				android: "4.2.0",
				ios: "3.4.0",
				macos: "0.3.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-rotation-alignment": {
		type: "enum",
		values: {
			map: {
				doc: "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line."
			},
			viewport: {
				doc: "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
			},
			auto: {
				doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
			}
		},
		"default": "auto",
		doc: "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"`auto` value": {
				js: "0.25.0",
				android: "4.2.0",
				ios: "3.4.0",
				macos: "0.3.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-field": {
		type: "formatted",
		"default": "",
		tokens: true,
		doc: "Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"text-font": {
		type: "array",
		value: "string",
		"default": [
			"Open Sans Regular",
			"Arial Unicode MS Regular"
		],
		doc: "Font stack to use for displaying text.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.43.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"text-size": {
		type: "number",
		"default": 16,
		minimum: 0,
		units: "pixels",
		doc: "Font size.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.35.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"text-max-width": {
		type: "number",
		"default": 10,
		minimum: 0,
		units: "ems",
		doc: "The maximum line width for text wrapping.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.40.0",
				android: "5.2.0",
				ios: "3.7.0",
				macos: "0.6.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"text-line-height": {
		type: "number",
		"default": 1.2,
		units: "ems",
		doc: "Text leading value for multi-line text.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-letter-spacing": {
		type: "number",
		"default": 0,
		units: "ems",
		doc: "Text tracking amount.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.40.0",
				android: "5.2.0",
				ios: "3.7.0",
				macos: "0.6.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"text-justify": {
		type: "enum",
		values: {
			auto: {
				doc: "The text is aligned towards the anchor position."
			},
			left: {
				doc: "The text is aligned to the left."
			},
			center: {
				doc: "The text is centered."
			},
			right: {
				doc: "The text is aligned to the right."
			}
		},
		"default": "center",
		doc: "Text justification options.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.39.0",
				android: "5.2.0",
				ios: "3.7.0",
				macos: "0.6.0"
			},
			auto: {
				js: "0.54.0",
				android: "7.4.0",
				ios: "4.10.0",
				macos: "0.14.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"text-radial-offset": {
		type: "number",
		units: "ems",
		"default": 0,
		doc: "Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",
		"sdk-support": {
			"basic functionality": {
				js: "0.54.0",
				android: "7.4.0",
				ios: "4.10.0",
				macos: "0.14.0"
			},
			"data-driven styling": {
				js: "0.54.0",
				android: "7.4.0",
				ios: "4.10.0",
				macos: "0.14.0"
			}
		},
		requires: [
			"text-field"
		],
		"property-type": "data-driven",
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature"
			]
		}
	},
	"text-variable-anchor": {
		type: "array",
		value: "enum",
		values: {
			center: {
				doc: "The center of the text is placed closest to the anchor."
			},
			left: {
				doc: "The left side of the text is placed closest to the anchor."
			},
			right: {
				doc: "The right side of the text is placed closest to the anchor."
			},
			top: {
				doc: "The top of the text is placed closest to the anchor."
			},
			bottom: {
				doc: "The bottom of the text is placed closest to the anchor."
			},
			"top-left": {
				doc: "The top left corner of the text is placed closest to the anchor."
			},
			"top-right": {
				doc: "The top right corner of the text is placed closest to the anchor."
			},
			"bottom-left": {
				doc: "The bottom left corner of the text is placed closest to the anchor."
			},
			"bottom-right": {
				doc: "The bottom right corner of the text is placed closest to the anchor."
			}
		},
		requires: [
			"text-field",
			{
				"symbol-placement": [
					"point"
				]
			}
		],
		doc: "To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.",
		"sdk-support": {
			"basic functionality": {
				js: "0.54.0",
				android: "7.4.0",
				ios: "4.10.0",
				macos: "0.14.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-anchor": {
		type: "enum",
		values: {
			center: {
				doc: "The center of the text is placed closest to the anchor."
			},
			left: {
				doc: "The left side of the text is placed closest to the anchor."
			},
			right: {
				doc: "The right side of the text is placed closest to the anchor."
			},
			top: {
				doc: "The top of the text is placed closest to the anchor."
			},
			bottom: {
				doc: "The bottom of the text is placed closest to the anchor."
			},
			"top-left": {
				doc: "The top left corner of the text is placed closest to the anchor."
			},
			"top-right": {
				doc: "The top right corner of the text is placed closest to the anchor."
			},
			"bottom-left": {
				doc: "The bottom left corner of the text is placed closest to the anchor."
			},
			"bottom-right": {
				doc: "The bottom right corner of the text is placed closest to the anchor."
			}
		},
		"default": "center",
		doc: "Part of the text placed closest to the anchor.",
		requires: [
			"text-field",
			{
				"!": "text-variable-anchor"
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.39.0",
				android: "5.2.0",
				ios: "3.7.0",
				macos: "0.6.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"text-max-angle": {
		type: "number",
		"default": 45,
		units: "degrees",
		doc: "Maximum angle change between adjacent characters.",
		requires: [
			"text-field",
			{
				"symbol-placement": [
					"line",
					"line-center"
				]
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-writing-mode": {
		type: "array",
		value: "enum",
		values: {
			horizontal: {
				doc: "If a text's language supports horizontal writing mode, symbols with point placement would be laid out horizontally."
			},
			vertical: {
				doc: "If a text's language supports vertical writing mode, symbols with point placement would be laid out vertically."
			}
		},
		doc: "The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesn’t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. The order of elements in an array define priority order for the placement of an orientation variant.",
		requires: [
			"text-field",
			{
				"symbol-placement": [
					"point"
				]
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "1.3.0",
				android: "8.3.0",
				ios: "5.3.0",
				macos: "0.15.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-rotate": {
		type: "number",
		"default": 0,
		period: 360,
		units: "degrees",
		doc: "Rotates the text clockwise.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.35.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"text-padding": {
		type: "number",
		"default": 2,
		minimum: 0,
		units: "pixels",
		doc: "Size of the additional area around the text bounding box used for detecting symbol collisions.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-keep-upright": {
		type: "boolean",
		"default": true,
		doc: "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
		requires: [
			"text-field",
			{
				"text-rotation-alignment": "map"
			},
			{
				"symbol-placement": [
					"line",
					"line-center"
				]
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-transform": {
		type: "enum",
		values: {
			none: {
				doc: "The text is not altered."
			},
			uppercase: {
				doc: "Forces all letters to be displayed in uppercase."
			},
			lowercase: {
				doc: "Forces all letters to be displayed in lowercase."
			}
		},
		"default": "none",
		doc: "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"text-offset": {
		type: "array",
		doc: "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.",
		value: "number",
		units: "ems",
		length: 2,
		"default": [
			0,
			0
		],
		requires: [
			"text-field",
			{
				"!": "text-radial-offset"
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.35.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "data-driven"
	},
	"text-allow-overlap": {
		type: "boolean",
		"default": false,
		doc: "If true, the text will be visible even if it collides with other previously drawn symbols.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-ignore-placement": {
		type: "boolean",
		"default": false,
		doc: "If true, other symbols can be visible even if they collide with the text.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-optional": {
		type: "boolean",
		"default": false,
		doc: "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
		requires: [
			"text-field",
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	visibility: {
		type: "enum",
		values: {
			visible: {
				doc: "The layer is shown."
			},
			none: {
				doc: "The layer is not shown."
			}
		},
		"default": "visible",
		doc: "Whether this layer is displayed.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		"property-type": "constant"
	}
};
var layout_raster = {
	visibility: {
		type: "enum",
		values: {
			visible: {
				doc: "The layer is shown."
			},
			none: {
				doc: "The layer is not shown."
			}
		},
		"default": "visible",
		doc: "Whether this layer is displayed.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		"property-type": "constant"
	}
};
var layout_hillshade = {
	visibility: {
		type: "enum",
		values: {
			visible: {
				doc: "The layer is shown."
			},
			none: {
				doc: "The layer is not shown."
			}
		},
		"default": "visible",
		doc: "Whether this layer is displayed.",
		"sdk-support": {
			"basic functionality": {
				js: "0.43.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		"property-type": "constant"
	}
};
var filter = {
	type: "array",
	value: "*",
	doc: "A filter selects specific features from a layer."
};
var filter_operator = {
	type: "enum",
	values: {
		"==": {
			doc: "`[\"==\", key, value]` equality: `feature[key] = value`"
		},
		"!=": {
			doc: "`[\"!=\", key, value]` inequality: `feature[key] ≠ value`"
		},
		">": {
			doc: "`[\">\", key, value]` greater than: `feature[key] > value`"
		},
		">=": {
			doc: "`[\">=\", key, value]` greater than or equal: `feature[key] ≥ value`"
		},
		"<": {
			doc: "`[\"<\", key, value]` less than: `feature[key] < value`"
		},
		"<=": {
			doc: "`[\"<=\", key, value]` less than or equal: `feature[key] ≤ value`"
		},
		"in": {
			doc: "`[\"in\", key, v0, ..., vn]` set inclusion: `feature[key] ∈ {v0, ..., vn}`"
		},
		"!in": {
			doc: "`[\"!in\", key, v0, ..., vn]` set exclusion: `feature[key] ∉ {v0, ..., vn}`"
		},
		all: {
			doc: "`[\"all\", f0, ..., fn]` logical `AND`: `f0 ∧ ... ∧ fn`"
		},
		any: {
			doc: "`[\"any\", f0, ..., fn]` logical `OR`: `f0 ∨ ... ∨ fn`"
		},
		none: {
			doc: "`[\"none\", f0, ..., fn]` logical `NOR`: `¬f0 ∧ ... ∧ ¬fn`"
		},
		has: {
			doc: "`[\"has\", key]` `feature[key]` exists"
		},
		"!has": {
			doc: "`[\"!has\", key]` `feature[key]` does not exist"
		},
		within: {
			doc: "`[\"within\", object]` feature geometry is within object geometry"
		}
	},
	doc: "The filter operator."
};
var geometry_type = {
	type: "enum",
	values: {
		Point: {
			doc: "Filter to point geometries."
		},
		LineString: {
			doc: "Filter to line geometries."
		},
		Polygon: {
			doc: "Filter to polygon geometries."
		}
	},
	doc: "The geometry type for the filter to select."
};
var function_stop = {
	type: "array",
	minimum: 0,
	maximum: 24,
	value: [
		"number",
		"color"
	],
	length: 2,
	doc: "Zoom level and value pair."
};
var expression = {
	type: "array",
	value: "*",
	minimum: 1,
	doc: "An expression defines a function that can be used for data-driven style properties or feature filters."
};
var expression_name = {
	doc: "",
	type: "enum",
	values: {
		"let": {
			doc: "Binds expressions to named variables, which can then be referenced in the result expression using [\"var\", \"variable_name\"].",
			group: "Variable binding",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"var": {
			doc: "References variable bound using \"let\".",
			group: "Variable binding",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		literal: {
			doc: "Provides a literal array or object value.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		array: {
			doc: "Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		at: {
			doc: "Retrieves an item from an array.",
			group: "Lookup",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"in": {
			doc: "Determines whether an item exists in an array or a substring exists in a string.",
			group: "Lookup",
			"sdk-support": {
				"basic functionality": {
					js: "1.6.0",
					android: "9.1.0",
					ios: "5.8.0",
					macos: "0.15.0"
				}
			}
		},
		"index-of": {
			doc: "Returns the first position at which an item can be found in an array or a substring can be found in a string, or `-1` if the input cannot be found. Accepts an optional index from where to begin the search.",
			group: "Lookup",
			"sdk-support": {
				"basic functionality": {
					js: "1.10.0"
				}
			}
		},
		slice: {
			doc: "Returns an item from an array or a substring from a string from a specified start index, or between a start index and an end index if set. The return value is inclusive of the start index but not of the end index.",
			group: "Lookup",
			"sdk-support": {
				"basic functionality": {
					js: "1.10.0"
				}
			}
		},
		"case": {
			doc: "Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		match: {
			doc: "Selects the output whose label value matches the input value, or the fallback value if no match is found. The input can be any expression (e.g. `[\"get\", \"building_type\"]`). Each label must be either:\n - a single literal value; or\n - an array of literal values, whose values must be all strings or all numbers (e.g. `[100, 101]` or `[\"c\", \"b\"]`). The input matches if any of the values in the array matches, similar to the `\"in\"` operator.\nEach label must be unique. If the input type does not match the type of the labels, the result will be the fallback value.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		coalesce: {
			doc: "Evaluates each expression in turn until the first non-null value is obtained, and returns that value.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		step: {
			doc: "Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.",
			group: "Ramps, scales, curves",
			"sdk-support": {
				"basic functionality": {
					js: "0.42.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		interpolate: {
			doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\n\nInterpolation types:\n- `[\"linear\"]`: Interpolates linearly between the pair of stops just less than and just greater than the input.\n- `[\"exponential\", base]`: Interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\n- `[\"cubic-bezier\", x1, y1, x2, y2]`: Interpolates using the cubic bezier curve defined by the given control points.",
			group: "Ramps, scales, curves",
			"sdk-support": {
				"basic functionality": {
					js: "0.42.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"interpolate-hcl": {
			doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.",
			group: "Ramps, scales, curves",
			"sdk-support": {
				"basic functionality": {
					js: "0.49.0"
				}
			}
		},
		"interpolate-lab": {
			doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.",
			group: "Ramps, scales, curves",
			"sdk-support": {
				"basic functionality": {
					js: "0.49.0"
				}
			}
		},
		ln2: {
			doc: "Returns mathematical constant ln(2).",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		pi: {
			doc: "Returns the mathematical constant pi.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		e: {
			doc: "Returns the mathematical constant e.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"typeof": {
			doc: "Returns a string describing the type of the given value.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		string: {
			doc: "Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		number: {
			doc: "Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		boolean: {
			doc: "Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		object: {
			doc: "Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		collator: {
			doc: "Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.45.0",
					android: "6.5.0",
					ios: "4.2.0",
					macos: "0.9.0"
				}
			}
		},
		format: {
			doc: "Returns a `formatted` string for displaying mixed-format text in the `text-field` property. The input may contain a string literal or expression, including an [`'image'`](#types-image) expression. Strings may be followed by a style override object that supports the following properties:\n- `\"text-font\"`: Overrides the font stack specified by the root layout property.\n- `\"text-color\"`: Overrides the color specified by the root paint property.\n- `\"font-scale\"`: Applies a scaling factor on `text-size` as specified by the root layout property.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.48.0",
					android: "6.7.0",
					ios: "4.6.0",
					macos: "0.12.0"
				},
				"text-font": {
					js: "0.48.0",
					android: "6.7.0",
					ios: "4.6.0",
					macos: "0.12.0"
				},
				"font-scale": {
					js: "0.48.0",
					android: "6.7.0",
					ios: "4.6.0",
					macos: "0.12.0"
				},
				"text-color": {
					js: "1.3.0",
					android: "7.3.0",
					ios: "4.10.0",
					macos: "0.14.0"
				},
				image: {
					js: "1.6.0",
					android: "8.6.0",
					ios: "5.7.0",
					macos: "0.15.0"
				}
			}
		},
		image: {
			doc: "Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "1.4.0",
					android: "8.6.0",
					ios: "5.7.0",
					macos: "0.15.0"
				}
			}
		},
		"number-format": {
			doc: "Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.54.0"
				}
			}
		},
		"to-string": {
			doc: "Converts the input value to a string. If the input is `null`, the result is `\"\"`. If the input is a boolean, the result is `\"true\"` or `\"false\"`. If the input is a number, it is converted to a string as specified by the [\"NumberToString\" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `\"rgba(r,g,b,a)\"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"to-number": {
			doc: "Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the [\"ToNumber Applied to the String Type\" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"to-boolean": {
			doc: "Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"to-rgba": {
			doc: "Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.",
			group: "Color",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"to-color": {
			doc: "Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
			group: "Types",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		rgb: {
			doc: "Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.",
			group: "Color",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		rgba: {
			doc: "Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.",
			group: "Color",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		get: {
			doc: "Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns null if the requested property is missing.",
			group: "Lookup",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		has: {
			doc: "Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.",
			group: "Lookup",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		length: {
			doc: "Gets the length of an array or string.",
			group: "Lookup",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		properties: {
			doc: "Gets the feature properties object.  Note that in some cases, it may be more efficient to use [\"get\", \"property_name\"] directly.",
			group: "Feature data",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"feature-state": {
			doc: "Retrieves a property value from the current feature's state. Returns null if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\"feature-state\"] can only be used with paint properties that support data-driven styling.",
			group: "Feature data",
			"sdk-support": {
				"basic functionality": {
					js: "0.46.0"
				}
			}
		},
		"geometry-type": {
			doc: "Gets the feature's geometry type: `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`.",
			group: "Feature data",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		id: {
			doc: "Gets the feature's id, if it has one.",
			group: "Feature data",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		zoom: {
			doc: "Gets the current zoom level.  Note that in style layout and paint properties, [\"zoom\"] may only appear as the input to a top-level \"step\" or \"interpolate\" expression.",
			group: "Zoom",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"heatmap-density": {
			doc: "Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",
			group: "Heatmap",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"line-progress": {
			doc: "Gets the progress along a gradient line. Can only be used in the `line-gradient` property.",
			group: "Feature data",
			"sdk-support": {
				"basic functionality": {
					js: "0.45.0",
					android: "6.5.0",
					ios: "4.6.0",
					macos: "0.12.0"
				}
			}
		},
		accumulated: {
			doc: "Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.",
			group: "Feature data",
			"sdk-support": {
				"basic functionality": {
					js: "0.53.0"
				}
			}
		},
		"+": {
			doc: "Returns the sum of the inputs.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"*": {
			doc: "Returns the product of the inputs.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"-": {
			doc: "For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"/": {
			doc: "Returns the result of floating point division of the first input by the second.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"%": {
			doc: "Returns the remainder after integer division of the first input by the second.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"^": {
			doc: "Returns the result of raising the first input to the power specified by the second.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		sqrt: {
			doc: "Returns the square root of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.42.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		log10: {
			doc: "Returns the base-ten logarithm of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		ln: {
			doc: "Returns the natural logarithm of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		log2: {
			doc: "Returns the base-two logarithm of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		sin: {
			doc: "Returns the sine of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		cos: {
			doc: "Returns the cosine of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		tan: {
			doc: "Returns the tangent of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		asin: {
			doc: "Returns the arcsine of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		acos: {
			doc: "Returns the arccosine of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		atan: {
			doc: "Returns the arctangent of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		min: {
			doc: "Returns the minimum value of the inputs.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		max: {
			doc: "Returns the maximum value of the inputs.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		round: {
			doc: "Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `[\"round\", -1.5]` evaluates to -2.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.45.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		abs: {
			doc: "Returns the absolute value of the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.45.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		ceil: {
			doc: "Returns the smallest integer that is greater than or equal to the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.45.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		floor: {
			doc: "Returns the largest integer that is less than or equal to the input.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					js: "0.45.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		distance: {
			doc: "Returns the shortest distance in meters between the evaluated feature and the input geometry. The input value can be a valid GeoJSON of type `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Distance values returned may vary in precision due to loss in precision from encoding geometries, particularly below zoom level 13.",
			group: "Math",
			"sdk-support": {
				"basic functionality": {
					android: "9.2.0",
					ios: "5.9.0",
					macos: "0.16.0"
				}
			}
		},
		"==": {
			doc: "Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				},
				collator: {
					js: "0.45.0",
					android: "6.5.0",
					ios: "4.2.0",
					macos: "0.9.0"
				}
			}
		},
		"!=": {
			doc: "Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				},
				collator: {
					js: "0.45.0",
					android: "6.5.0",
					ios: "4.2.0",
					macos: "0.9.0"
				}
			}
		},
		">": {
			doc: "Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				},
				collator: {
					js: "0.45.0",
					android: "6.5.0",
					ios: "4.2.0",
					macos: "0.9.0"
				}
			}
		},
		"<": {
			doc: "Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				},
				collator: {
					js: "0.45.0",
					android: "6.5.0",
					ios: "4.2.0",
					macos: "0.9.0"
				}
			}
		},
		">=": {
			doc: "Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				},
				collator: {
					js: "0.45.0",
					android: "6.5.0",
					ios: "4.2.0",
					macos: "0.9.0"
				}
			}
		},
		"<=": {
			doc: "Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				},
				collator: {
					js: "0.45.0",
					android: "6.5.0",
					ios: "4.2.0",
					macos: "0.9.0"
				}
			}
		},
		all: {
			doc: "Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		any: {
			doc: "Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"!": {
			doc: "Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		within: {
			doc: "Returns `true` if the evaluated feature is fully contained inside a boundary of the input geometry, `false` otherwise. The input value can be a valid GeoJSON of type `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Supported features for evaluation:\n- `Point`: Returns `false` if a point is on the boundary or falls outside the boundary.\n- `LineString`: Returns `false` if any part of a line falls outside the boundary, the line intersects the boundary, or a line's endpoint is on the boundary.",
			group: "Decision",
			"sdk-support": {
				"basic functionality": {
					js: "1.9.0",
					android: "9.1.0",
					ios: "5.8.0",
					macos: "0.15.0"
				}
			}
		},
		"is-supported-script": {
			doc: "Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).",
			group: "String",
			"sdk-support": {
				"basic functionality": {
					js: "0.45.0",
					android: "6.6.0"
				}
			}
		},
		upcase: {
			doc: "Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
			group: "String",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		downcase: {
			doc: "Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
			group: "String",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		concat: {
			doc: "Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.",
			group: "String",
			"sdk-support": {
				"basic functionality": {
					js: "0.41.0",
					android: "6.0.0",
					ios: "4.0.0",
					macos: "0.7.0"
				}
			}
		},
		"resolved-locale": {
			doc: "Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.",
			group: "String",
			"sdk-support": {
				"basic functionality": {
					js: "0.45.0",
					android: "6.5.0",
					ios: "4.2.0",
					macos: "0.9.0"
				}
			}
		}
	}
};
var light = {
	anchor: {
		type: "enum",
		"default": "viewport",
		values: {
			map: {
				doc: "The position of the light source is aligned to the rotation of the map."
			},
			viewport: {
				doc: "The position of the light source is aligned to the rotation of the viewport."
			}
		},
		"property-type": "data-constant",
		transition: false,
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		doc: "Whether extruded geometries are lit relative to the map or viewport.",
		example: "map",
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		}
	},
	position: {
		type: "array",
		"default": [
			1.15,
			210,
			30
		],
		length: 3,
		value: "number",
		"property-type": "data-constant",
		transition: true,
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		doc: "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0° (0° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0°, directly above, to 180°, directly below).",
		example: [
			1.5,
			90,
			80
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		}
	},
	color: {
		type: "color",
		"property-type": "data-constant",
		"default": "#ffffff",
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		transition: true,
		doc: "Color tint for lighting extruded geometries.",
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		}
	},
	intensity: {
		type: "number",
		"property-type": "data-constant",
		"default": 0.5,
		minimum: 0,
		maximum: 1,
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		transition: true,
		doc: "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		}
	}
};
var paint = [
	"paint_fill",
	"paint_line",
	"paint_circle",
	"paint_heatmap",
	"paint_fill-extrusion",
	"paint_symbol",
	"paint_raster",
	"paint_hillshade",
	"paint_background"
];
var paint_fill = {
	"fill-antialias": {
		type: "boolean",
		"default": true,
		doc: "Whether or not the fill should be antialiased.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"fill-opacity": {
		type: "number",
		"default": 1,
		minimum: 0,
		maximum: 1,
		doc: "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.21.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-color": {
		type: "color",
		"default": "#000000",
		doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
		transition: true,
		requires: [
			{
				"!": "fill-pattern"
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.19.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-outline-color": {
		type: "color",
		doc: "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
		transition: true,
		requires: [
			{
				"!": "fill-pattern"
			},
			{
				"fill-antialias": true
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.19.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-translate": {
		type: "array",
		value: "number",
		length: 2,
		"default": [
			0,
			0
		],
		transition: true,
		units: "pixels",
		doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"fill-translate-anchor": {
		type: "enum",
		values: {
			map: {
				doc: "The fill is translated relative to the map."
			},
			viewport: {
				doc: "The fill is translated relative to the viewport."
			}
		},
		doc: "Controls the frame of reference for `fill-translate`.",
		"default": "map",
		requires: [
			"fill-translate"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"fill-pattern": {
		type: "resolvedImage",
		transition: true,
		doc: "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.49.0",
				android: "6.5.0",
				macos: "0.11.0",
				ios: "4.4.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "cross-faded-data-driven"
	}
};
var paint_line = {
	"line-opacity": {
		type: "number",
		doc: "The opacity at which the line will be drawn.",
		"default": 1,
		minimum: 0,
		maximum: 1,
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-color": {
		type: "color",
		doc: "The color with which the line will be drawn.",
		"default": "#000000",
		transition: true,
		requires: [
			{
				"!": "line-pattern"
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.23.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-translate": {
		type: "array",
		value: "number",
		length: 2,
		"default": [
			0,
			0
		],
		transition: true,
		units: "pixels",
		doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"line-translate-anchor": {
		type: "enum",
		values: {
			map: {
				doc: "The line is translated relative to the map."
			},
			viewport: {
				doc: "The line is translated relative to the viewport."
			}
		},
		doc: "Controls the frame of reference for `line-translate`.",
		"default": "map",
		requires: [
			"line-translate"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"line-width": {
		type: "number",
		"default": 1,
		minimum: 0,
		transition: true,
		units: "pixels",
		doc: "Stroke thickness.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.39.0",
				android: "5.2.0",
				ios: "3.7.0",
				macos: "0.6.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-gap-width": {
		type: "number",
		"default": 0,
		minimum: 0,
		doc: "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
		transition: true,
		units: "pixels",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-offset": {
		type: "number",
		"default": 0,
		doc: "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
		transition: true,
		units: "pixels",
		"sdk-support": {
			"basic functionality": {
				js: "0.12.1",
				android: "3.0.0",
				ios: "3.1.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-blur": {
		type: "number",
		"default": 0,
		minimum: 0,
		transition: true,
		units: "pixels",
		doc: "Blur applied to the line, in pixels.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"line-dasharray": {
		type: "array",
		value: "number",
		doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
		minimum: 0,
		transition: true,
		units: "line widths",
		requires: [
			{
				"!": "line-pattern"
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "cross-faded"
	},
	"line-pattern": {
		type: "resolvedImage",
		transition: true,
		doc: "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.49.0",
				android: "6.5.0",
				macos: "0.11.0",
				ios: "4.4.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "cross-faded-data-driven"
	},
	"line-gradient": {
		type: "color",
		doc: "Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `\"lineMetrics\": true`.",
		transition: false,
		requires: [
			{
				"!": "line-dasharray"
			},
			{
				"!": "line-pattern"
			},
			{
				source: "geojson",
				has: {
					lineMetrics: true
				}
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.45.0",
				android: "6.5.0",
				ios: "4.4.0",
				macos: "0.11.0"
			},
			"data-driven styling": {
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"line-progress"
			]
		},
		"property-type": "color-ramp"
	}
};
var paint_circle = {
	"circle-radius": {
		type: "number",
		"default": 5,
		minimum: 0,
		transition: true,
		units: "pixels",
		doc: "Circle radius.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.18.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-color": {
		type: "color",
		"default": "#000000",
		doc: "The fill color of the circle.",
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.18.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-blur": {
		type: "number",
		"default": 0,
		doc: "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.20.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-opacity": {
		type: "number",
		doc: "The opacity at which the circle will be drawn.",
		"default": 1,
		minimum: 0,
		maximum: 1,
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.20.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-translate": {
		type: "array",
		value: "number",
		length: 2,
		"default": [
			0,
			0
		],
		transition: true,
		units: "pixels",
		doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"circle-translate-anchor": {
		type: "enum",
		values: {
			map: {
				doc: "The circle is translated relative to the map."
			},
			viewport: {
				doc: "The circle is translated relative to the viewport."
			}
		},
		doc: "Controls the frame of reference for `circle-translate`.",
		"default": "map",
		requires: [
			"circle-translate"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"circle-pitch-scale": {
		type: "enum",
		values: {
			map: {
				doc: "Circles are scaled according to their apparent distance to the camera."
			},
			viewport: {
				doc: "Circles are not scaled."
			}
		},
		"default": "map",
		doc: "Controls the scaling behavior of the circle when the map is pitched.",
		"sdk-support": {
			"basic functionality": {
				js: "0.21.0",
				android: "4.2.0",
				ios: "3.4.0",
				macos: "0.2.1"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"circle-pitch-alignment": {
		type: "enum",
		values: {
			map: {
				doc: "The circle is aligned to the plane of the map."
			},
			viewport: {
				doc: "The circle is aligned to the plane of the viewport."
			}
		},
		"default": "viewport",
		doc: "Orientation of circle when map is pitched.",
		"sdk-support": {
			"basic functionality": {
				js: "0.39.0",
				android: "5.2.0",
				ios: "3.7.0",
				macos: "0.6.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"circle-stroke-width": {
		type: "number",
		"default": 0,
		minimum: 0,
		transition: true,
		units: "pixels",
		doc: "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
		"sdk-support": {
			"basic functionality": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			},
			"data-driven styling": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-stroke-color": {
		type: "color",
		"default": "#000000",
		doc: "The stroke color of the circle.",
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			},
			"data-driven styling": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"circle-stroke-opacity": {
		type: "number",
		doc: "The opacity of the circle's stroke.",
		"default": 1,
		minimum: 0,
		maximum: 1,
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			},
			"data-driven styling": {
				js: "0.29.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	}
};
var paint_heatmap = {
	"heatmap-radius": {
		type: "number",
		"default": 30,
		minimum: 1,
		transition: true,
		units: "pixels",
		doc: "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.",
		"sdk-support": {
			"basic functionality": {
				js: "0.41.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			},
			"data-driven styling": {
				js: "0.43.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"heatmap-weight": {
		type: "number",
		"default": 1,
		minimum: 0,
		transition: false,
		doc: "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",
		"sdk-support": {
			"basic functionality": {
				js: "0.41.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			},
			"data-driven styling": {
				js: "0.41.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"heatmap-intensity": {
		type: "number",
		"default": 1,
		minimum: 0,
		transition: true,
		doc: "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",
		"sdk-support": {
			"basic functionality": {
				js: "0.41.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"heatmap-color": {
		type: "color",
		"default": [
			"interpolate",
			[
				"linear"
			],
			[
				"heatmap-density"
			],
			0,
			"rgba(0, 0, 255, 0)",
			0.1,
			"royalblue",
			0.3,
			"cyan",
			0.5,
			"lime",
			0.7,
			"yellow",
			1,
			"red"
		],
		doc: "Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `[\"heatmap-density\"]` as input.",
		transition: false,
		"sdk-support": {
			"basic functionality": {
				js: "0.41.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			},
			"data-driven styling": {
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"heatmap-density"
			]
		},
		"property-type": "color-ramp"
	},
	"heatmap-opacity": {
		type: "number",
		doc: "The global opacity at which the heatmap layer will be drawn.",
		"default": 1,
		minimum: 0,
		maximum: 1,
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.41.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	}
};
var paint_symbol = {
	"icon-opacity": {
		doc: "The opacity at which the icon will be drawn.",
		type: "number",
		"default": 1,
		minimum: 0,
		maximum: 1,
		transition: true,
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-color": {
		type: "color",
		"default": "#000000",
		transition: true,
		doc: "The color of the icon. This can only be used with sdf icons.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-halo-color": {
		type: "color",
		"default": "rgba(0, 0, 0, 0)",
		transition: true,
		doc: "The color of the icon's halo. Icon halos can only be used with SDF icons.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-halo-width": {
		type: "number",
		"default": 0,
		minimum: 0,
		transition: true,
		units: "pixels",
		doc: "Distance of halo to the icon outline.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-halo-blur": {
		type: "number",
		"default": 0,
		minimum: 0,
		transition: true,
		units: "pixels",
		doc: "Fade out the halo towards the outside.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"icon-translate": {
		type: "array",
		value: "number",
		length: 2,
		"default": [
			0,
			0
		],
		transition: true,
		units: "pixels",
		doc: "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
		requires: [
			"icon-image"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"icon-translate-anchor": {
		type: "enum",
		values: {
			map: {
				doc: "Icons are translated relative to the map."
			},
			viewport: {
				doc: "Icons are translated relative to the viewport."
			}
		},
		doc: "Controls the frame of reference for `icon-translate`.",
		"default": "map",
		requires: [
			"icon-image",
			"icon-translate"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-opacity": {
		type: "number",
		doc: "The opacity at which the text will be drawn.",
		"default": 1,
		minimum: 0,
		maximum: 1,
		transition: true,
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-color": {
		type: "color",
		doc: "The color with which the text will be drawn.",
		"default": "#000000",
		transition: true,
		overridable: true,
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-halo-color": {
		type: "color",
		"default": "rgba(0, 0, 0, 0)",
		transition: true,
		doc: "The color of the text's halo, which helps it stand out from backgrounds.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-halo-width": {
		type: "number",
		"default": 0,
		minimum: 0,
		transition: true,
		units: "pixels",
		doc: "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-halo-blur": {
		type: "number",
		"default": 0,
		minimum: 0,
		transition: true,
		units: "pixels",
		doc: "The halo's fadeout distance towards the outside.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
				js: "0.33.0",
				android: "5.0.0",
				ios: "3.5.0",
				macos: "0.4.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"text-translate": {
		type: "array",
		value: "number",
		length: 2,
		"default": [
			0,
			0
		],
		transition: true,
		units: "pixels",
		doc: "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
		requires: [
			"text-field"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"text-translate-anchor": {
		type: "enum",
		values: {
			map: {
				doc: "The text is translated relative to the map."
			},
			viewport: {
				doc: "The text is translated relative to the viewport."
			}
		},
		doc: "Controls the frame of reference for `text-translate`.",
		"default": "map",
		requires: [
			"text-field",
			"text-translate"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	}
};
var paint_raster = {
	"raster-opacity": {
		type: "number",
		doc: "The opacity at which the image will be drawn.",
		"default": 1,
		minimum: 0,
		maximum: 1,
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"raster-hue-rotate": {
		type: "number",
		"default": 0,
		period: 360,
		transition: true,
		units: "degrees",
		doc: "Rotates hues around the color wheel.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"raster-brightness-min": {
		type: "number",
		doc: "Increase or reduce the brightness of the image. The value is the minimum brightness.",
		"default": 0,
		minimum: 0,
		maximum: 1,
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"raster-brightness-max": {
		type: "number",
		doc: "Increase or reduce the brightness of the image. The value is the maximum brightness.",
		"default": 1,
		minimum: 0,
		maximum: 1,
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"raster-saturation": {
		type: "number",
		doc: "Increase or reduce the saturation of the image.",
		"default": 0,
		minimum: -1,
		maximum: 1,
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"raster-contrast": {
		type: "number",
		doc: "Increase or reduce the contrast of the image.",
		"default": 0,
		minimum: -1,
		maximum: 1,
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"raster-resampling": {
		type: "enum",
		doc: "The resampling/interpolation method to use for overscaling, also known as texture magnification filter",
		values: {
			linear: {
				doc: "(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled"
			},
			nearest: {
				doc: "Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled"
			}
		},
		"default": "linear",
		"sdk-support": {
			"basic functionality": {
				js: "0.47.0",
				android: "6.3.0",
				ios: "4.2.0",
				macos: "0.9.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"raster-fade-duration": {
		type: "number",
		"default": 300,
		minimum: 0,
		transition: false,
		units: "milliseconds",
		doc: "Fade duration when a new tile is added.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	}
};
var paint_hillshade = {
	"hillshade-illumination-direction": {
		type: "number",
		"default": 335,
		minimum: 0,
		maximum: 359,
		doc: "The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.",
		transition: false,
		"sdk-support": {
			"basic functionality": {
				js: "0.43.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"hillshade-illumination-anchor": {
		type: "enum",
		values: {
			map: {
				doc: "The hillshade illumination is relative to the north direction."
			},
			viewport: {
				doc: "The hillshade illumination is relative to the top of the viewport."
			}
		},
		"default": "viewport",
		doc: "Direction of light source when map is rotated.",
		"sdk-support": {
			"basic functionality": {
				js: "0.43.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"hillshade-exaggeration": {
		type: "number",
		doc: "Intensity of the hillshade",
		"default": 0.5,
		minimum: 0,
		maximum: 1,
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.43.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"hillshade-shadow-color": {
		type: "color",
		"default": "#000000",
		doc: "The shading color of areas that face away from the light source.",
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.43.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"hillshade-highlight-color": {
		type: "color",
		"default": "#FFFFFF",
		doc: "The shading color of areas that faces towards the light source.",
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.43.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"hillshade-accent-color": {
		type: "color",
		"default": "#000000",
		doc: "The shading color used to accentuate rugged terrain like sharp cliffs and gorges.",
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.43.0",
				android: "6.0.0",
				ios: "4.0.0",
				macos: "0.7.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	}
};
var paint_background = {
	"background-color": {
		type: "color",
		"default": "#000000",
		doc: "The color with which the background will be drawn.",
		transition: true,
		requires: [
			{
				"!": "background-pattern"
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"background-pattern": {
		type: "resolvedImage",
		transition: true,
		doc: "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			},
			"data-driven styling": {
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "cross-faded"
	},
	"background-opacity": {
		type: "number",
		"default": 1,
		minimum: 0,
		maximum: 1,
		doc: "The opacity at which the background will be drawn.",
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.10.0",
				android: "2.0.1",
				ios: "2.0.0",
				macos: "0.1.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	}
};
var transition = {
	duration: {
		type: "number",
		"default": 300,
		minimum: 0,
		units: "milliseconds",
		doc: "Time allotted for transitions to complete."
	},
	delay: {
		type: "number",
		"default": 0,
		minimum: 0,
		units: "milliseconds",
		doc: "Length of time before a transition begins."
	}
};
var promoteId = {
	"*": {
		type: "string",
		doc: "A name of a feature property to use as ID for feature state."
	}
};
var v8 = {
	$version: $version,
	$root: $root,
	sources: sources,
	source: source,
	source_vector: source_vector,
	source_raster: source_raster,
	source_raster_dem: source_raster_dem,
	source_geojson: source_geojson,
	source_video: source_video,
	source_image: source_image,
	layer: layer,
	layout: layout,
	layout_background: layout_background,
	layout_fill: layout_fill,
	layout_circle: layout_circle,
	layout_heatmap: layout_heatmap,
	"layout_fill-extrusion": {
	visibility: {
		type: "enum",
		values: {
			visible: {
				doc: "The layer is shown."
			},
			none: {
				doc: "The layer is not shown."
			}
		},
		"default": "visible",
		doc: "Whether this layer is displayed.",
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		"property-type": "constant"
	}
},
	layout_line: layout_line,
	layout_symbol: layout_symbol,
	layout_raster: layout_raster,
	layout_hillshade: layout_hillshade,
	filter: filter,
	filter_operator: filter_operator,
	geometry_type: geometry_type,
	"function": {
	expression: {
		type: "expression",
		doc: "An expression."
	},
	stops: {
		type: "array",
		doc: "An array of stops.",
		value: "function_stop"
	},
	base: {
		type: "number",
		"default": 1,
		minimum: 0,
		doc: "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
	},
	property: {
		type: "string",
		doc: "The name of a feature property to use as the function input.",
		"default": "$zoom"
	},
	type: {
		type: "enum",
		values: {
			identity: {
				doc: "Return the input value as the output value."
			},
			exponential: {
				doc: "Generate an output by interpolating between stops just less than and just greater than the function input."
			},
			interval: {
				doc: "Return the output value of the stop just less than the function input."
			},
			categorical: {
				doc: "Return the output value of the stop equal to the function input."
			}
		},
		doc: "The interpolation strategy to use in function evaluation.",
		"default": "exponential"
	},
	colorSpace: {
		type: "enum",
		values: {
			rgb: {
				doc: "Use the RGB color space to interpolate color values"
			},
			lab: {
				doc: "Use the LAB color space to interpolate color values."
			},
			hcl: {
				doc: "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."
			}
		},
		doc: "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",
		"default": "rgb"
	},
	"default": {
		type: "*",
		required: false,
		doc: "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances."
	}
},
	function_stop: function_stop,
	expression: expression,
	expression_name: expression_name,
	light: light,
	paint: paint,
	paint_fill: paint_fill,
	"paint_fill-extrusion": {
	"fill-extrusion-opacity": {
		type: "number",
		"default": 1,
		minimum: 0,
		maximum: 1,
		doc: "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"fill-extrusion-color": {
		type: "color",
		"default": "#000000",
		doc: "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",
		transition: true,
		requires: [
			{
				"!": "fill-extrusion-pattern"
			}
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			},
			"data-driven styling": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-extrusion-translate": {
		type: "array",
		value: "number",
		length: 2,
		"default": [
			0,
			0
		],
		transition: true,
		units: "pixels",
		doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"fill-extrusion-translate-anchor": {
		type: "enum",
		values: {
			map: {
				doc: "The fill extrusion is translated relative to the map."
			},
			viewport: {
				doc: "The fill extrusion is translated relative to the viewport."
			}
		},
		doc: "Controls the frame of reference for `fill-extrusion-translate`.",
		"default": "map",
		requires: [
			"fill-extrusion-translate"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	},
	"fill-extrusion-pattern": {
		type: "resolvedImage",
		transition: true,
		doc: "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			},
			"data-driven styling": {
				js: "0.49.0",
				android: "6.5.0",
				macos: "0.11.0",
				ios: "4.4.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom",
				"feature"
			]
		},
		"property-type": "cross-faded-data-driven"
	},
	"fill-extrusion-height": {
		type: "number",
		"default": 0,
		minimum: 0,
		units: "meters",
		doc: "The height with which to extrude this layer.",
		transition: true,
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			},
			"data-driven styling": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-extrusion-base": {
		type: "number",
		"default": 0,
		minimum: 0,
		units: "meters",
		doc: "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",
		transition: true,
		requires: [
			"fill-extrusion-height"
		],
		"sdk-support": {
			"basic functionality": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			},
			"data-driven styling": {
				js: "0.27.0",
				android: "5.1.0",
				ios: "3.6.0",
				macos: "0.5.0"
			}
		},
		expression: {
			interpolated: true,
			parameters: [
				"zoom",
				"feature",
				"feature-state"
			]
		},
		"property-type": "data-driven"
	},
	"fill-extrusion-vertical-gradient": {
		type: "boolean",
		"default": true,
		doc: "Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.",
		transition: false,
		"sdk-support": {
			"basic functionality": {
				js: "0.50.0",
				ios: "4.7.0",
				macos: "0.13.0"
			}
		},
		expression: {
			interpolated: false,
			parameters: [
				"zoom"
			]
		},
		"property-type": "data-constant"
	}
},
	paint_line: paint_line,
	paint_circle: paint_circle,
	paint_heatmap: paint_heatmap,
	paint_symbol: paint_symbol,
	paint_raster: paint_raster,
	paint_hillshade: paint_hillshade,
	paint_background: paint_background,
	transition: transition,
	"property-type": {
	"data-driven": {
		type: "property-type",
		doc: "Property is interpolable and can be represented using a property expression."
	},
	"cross-faded": {
		type: "property-type",
		doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms."
	},
	"cross-faded-data-driven": {
		type: "property-type",
		doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression."
	},
	"color-ramp": {
		type: "property-type",
		doc: "Property should be specified using a color ramp from which the output color can be sampled based on a property calculation."
	},
	"data-constant": {
		type: "property-type",
		doc: "Property is interpolable but cannot be represented using a property expression."
	},
	constant: {
		type: "property-type",
		doc: "Property is constant across all zoom levels and property values."
	}
},
	promoteId: promoteId
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

createCommonjsModule(function (module, exports) {
(function(root) {

	/** Detect free variables */
	var freeExports =  exports &&
		!exports.nodeType && exports;
	var freeModule =  module &&
		!module.nodeType && module;
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(commonjsGlobal));
});

// Copyright Joyent, Inc. and other Node contributors.

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var decode = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty$1(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

// Copyright Joyent, Inc. and other Node contributors.

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

var encode = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) { return ''; }
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var querystring = createCommonjsModule(function (module, exports) {

exports.decode = exports.parse = decode;
exports.encode = exports.stringify = encode;
});
querystring.decode;
querystring.parse;
querystring.encode;
querystring.stringify;

function extend (output) {
    var inputs = [], len = arguments.length - 1;
    while (len-- > 0)
        inputs[len] = arguments[len + 1];
    for (var i = 0, list = inputs; i < list.length; i += 1) {
        var input = list[i];
        for (var k in input) {
            output[k] = input[k];
        }
    }
    return output;
}

var ParsingError = function (Error) {
    function ParsingError(key, message) {
        Error.call(this, message);
        this.message = message;
        this.key = key;
    }
    if (Error)
        ParsingError.__proto__ = Error;
    ParsingError.prototype = Object.create(Error && Error.prototype);
    ParsingError.prototype.constructor = ParsingError;
    return ParsingError;
}(Error);

var Scope = function Scope(parent, bindings) {
    if (bindings === void 0)
        bindings = [];
    this.parent = parent;
    this.bindings = {};
    for (var i = 0, list = bindings; i < list.length; i += 1) {
        var ref = list[i];
        var name = ref[0];
        var expression = ref[1];
        this.bindings[name] = expression;
    }
};
Scope.prototype.concat = function concat(bindings) {
    return new Scope(this, bindings);
};
Scope.prototype.get = function get(name) {
    if (this.bindings[name]) {
        return this.bindings[name];
    }
    if (this.parent) {
        return this.parent.get(name);
    }
    throw new Error(name + ' not found in scope.');
};
Scope.prototype.has = function has(name) {
    if (this.bindings[name]) {
        return true;
    }
    return this.parent ? this.parent.has(name) : false;
};

var NullType = { kind: 'null' };
var NumberType = { kind: 'number' };
var StringType = { kind: 'string' };
var BooleanType = { kind: 'boolean' };
var ColorType = { kind: 'color' };
var ObjectType = { kind: 'object' };
var ValueType = { kind: 'value' };
var ErrorType = { kind: 'error' };
var CollatorType = { kind: 'collator' };
var FormattedType = { kind: 'formatted' };
var ResolvedImageType = { kind: 'resolvedImage' };
function array(itemType, N) {
    return {
        kind: 'array',
        itemType: itemType,
        N: N
    };
}
function toString(type) {
    if (type.kind === 'array') {
        var itemType = toString(type.itemType);
        return typeof type.N === 'number' ? 'array<' + itemType + ', ' + type.N + '>' : type.itemType.kind === 'value' ? 'array' : 'array<' + itemType + '>';
    } else {
        return type.kind;
    }
}
var valueMemberTypes = [
    NullType,
    NumberType,
    StringType,
    BooleanType,
    ColorType,
    FormattedType,
    ObjectType,
    array(ValueType),
    ResolvedImageType
];
function checkSubtype(expected, t) {
    if (t.kind === 'error') {
        return null;
    } else if (expected.kind === 'array') {
        if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {
            return null;
        }
    } else if (expected.kind === t.kind) {
        return null;
    } else if (expected.kind === 'value') {
        for (var i = 0, list = valueMemberTypes; i < list.length; i += 1) {
            var memberType = list[i];
            if (!checkSubtype(memberType, t)) {
                return null;
            }
        }
    }
    return 'Expected ' + toString(expected) + ' but found ' + toString(t) + ' instead.';
}
function isValidType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
        return t.kind === provided.kind;
    });
}
function isValidNativeType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
        if (t === 'null') {
            return provided === null;
        } else if (t === 'array') {
            return Array.isArray(provided);
        } else if (t === 'object') {
            return provided && !Array.isArray(provided) && typeof provided === 'object';
        } else {
            return t === typeof provided;
        }
    });
}

var csscolorparser = createCommonjsModule(function (module, exports) {
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "rebeccapurple": [102,51,153,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]};

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    { return clamp_css_byte(parseFloat(str) / 100 * 255); }
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    { return clamp_css_float(parseFloat(str) / 100); }
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) { h += 1; }
  else if (h > 1) { h -= 1; }

  if (h * 6 < 1) { return m1 + (m2 - m1) * h * 6; }
  if (h * 2 < 1) { return m2; }
  if (h * 3 < 2) { return m1 + (m2 - m1) * (2/3 - h) * 6; }
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) { return kCSSColorTable[str].slice(); }  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) { return null; }  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) { return null; }  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) { return null; }
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) { return null; }
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) { return null; }
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) { return null; }
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor; } catch(e) { }
});
var csscolorparser_1 = csscolorparser.parseCSSColor;

var Color = function Color(r, g, b, a) {
    if (a === void 0)
        a = 1;
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
};
Color.parse = function parse(input) {
    if (!input) {
        return undefined;
    }
    if (input instanceof Color) {
        return input;
    }
    if (typeof input !== 'string') {
        return undefined;
    }
    var rgba = csscolorparser_1(input);
    if (!rgba) {
        return undefined;
    }
    return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
};
Color.prototype.toString = function toString() {
    var ref = this.toArray();
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    return 'rgba(' + Math.round(r) + ',' + Math.round(g) + ',' + Math.round(b) + ',' + a + ')';
};
Color.prototype.toArray = function toArray() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var a = ref.a;
    return a === 0 ? [
        0,
        0,
        0,
        0
    ] : [
        r * 255 / a,
        g * 255 / a,
        b * 255 / a,
        a
    ];
};
Color.black = new Color(0, 0, 0, 1);
Color.white = new Color(1, 1, 1, 1);
Color.transparent = new Color(0, 0, 0, 0);
Color.red = new Color(1, 0, 0, 1);

var Collator = function Collator(caseSensitive, diacriticSensitive, locale) {
    if (caseSensitive) {
        this.sensitivity = diacriticSensitive ? 'variant' : 'case';
    } else {
        this.sensitivity = diacriticSensitive ? 'accent' : 'base';
    }
    this.locale = locale;
    this.collator = new Intl.Collator(this.locale ? this.locale : [], {
        sensitivity: this.sensitivity,
        usage: 'search'
    });
};
Collator.prototype.compare = function compare(lhs, rhs) {
    return this.collator.compare(lhs, rhs);
};
Collator.prototype.resolvedLocale = function resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
};

var FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {
    this.text = text;
    this.image = image;
    this.scale = scale;
    this.fontStack = fontStack;
    this.textColor = textColor;
};
var Formatted = function Formatted(sections) {
    this.sections = sections;
};
Formatted.fromString = function fromString(unformatted) {
    return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);
};
Formatted.prototype.isEmpty = function isEmpty() {
    if (this.sections.length === 0) {
        return true;
    }
    return !this.sections.some(function (section) {
        return section.text.length !== 0 || section.image && section.image.name.length !== 0;
    });
};
Formatted.factory = function factory(text) {
    if (text instanceof Formatted) {
        return text;
    } else {
        return Formatted.fromString(text);
    }
};
Formatted.prototype.toString = function toString() {
    if (this.sections.length === 0) {
        return '';
    }
    return this.sections.map(function (section) {
        return section.text;
    }).join('');
};
Formatted.prototype.serialize = function serialize() {
    var serialized = ['format'];
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        if (section.image) {
            serialized.push([
                'image',
                section.image.name
            ]);
            continue;
        }
        serialized.push(section.text);
        var options = {};
        if (section.fontStack) {
            options['text-font'] = [
                'literal',
                section.fontStack.split(',')
            ];
        }
        if (section.scale) {
            options['font-scale'] = section.scale;
        }
        if (section.textColor) {
            options['text-color'] = ['rgba'].concat(section.textColor.toArray());
        }
        serialized.push(options);
    }
    return serialized;
};

var ResolvedImage = function ResolvedImage(options) {
    this.name = options.name;
    this.available = options.available;
};
ResolvedImage.prototype.toString = function toString() {
    return this.name;
};
ResolvedImage.fromString = function fromString(name) {
    if (!name) {
        return null;
    }
    return new ResolvedImage({
        name: name,
        available: false
    });
};
ResolvedImage.prototype.serialize = function serialize() {
    return [
        'image',
        this.name
    ];
};

function validateRGBA(r, g, b, a) {
    if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {
        var value = typeof a === 'number' ? [
            r,
            g,
            b,
            a
        ] : [
            r,
            g,
            b
        ];
        return 'Invalid rgba value [' + value.join(', ') + ']: \'r\', \'g\', and \'b\' must be between 0 and 255.';
    }
    if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {
        return 'Invalid rgba value [' + [
            r,
            g,
            b,
            a
        ].join(', ') + ']: \'a\' must be between 0 and 1.';
    }
    return null;
}
function isValue(mixed) {
    if (mixed === null) {
        return true;
    } else if (typeof mixed === 'string') {
        return true;
    } else if (typeof mixed === 'boolean') {
        return true;
    } else if (typeof mixed === 'number') {
        return true;
    } else if (mixed instanceof Color) {
        return true;
    } else if (mixed instanceof Collator) {
        return true;
    } else if (mixed instanceof Formatted) {
        return true;
    } else if (mixed instanceof ResolvedImage) {
        return true;
    } else if (Array.isArray(mixed)) {
        for (var i = 0, list = mixed; i < list.length; i += 1) {
            var item = list[i];
            if (!isValue(item)) {
                return false;
            }
        }
        return true;
    } else if (typeof mixed === 'object') {
        for (var key in mixed) {
            if (!isValue(mixed[key])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
function typeOf(value) {
    if (value === null) {
        return NullType;
    } else if (typeof value === 'string') {
        return StringType;
    } else if (typeof value === 'boolean') {
        return BooleanType;
    } else if (typeof value === 'number') {
        return NumberType;
    } else if (value instanceof Color) {
        return ColorType;
    } else if (value instanceof Collator) {
        return CollatorType;
    } else if (value instanceof Formatted) {
        return FormattedType;
    } else if (value instanceof ResolvedImage) {
        return ResolvedImageType;
    } else if (Array.isArray(value)) {
        var length = value.length;
        var itemType;
        for (var i = 0, list = value; i < list.length; i += 1) {
            var item = list[i];
            var t = typeOf(item);
            if (!itemType) {
                itemType = t;
            } else if (itemType === t) {
                continue;
            } else {
                itemType = ValueType;
                break;
            }
        }
        return array(itemType || ValueType, length);
    } else {
        return ObjectType;
    }
}
function toString$1(value) {
    var type = typeof value;
    if (value === null) {
        return '';
    } else if (type === 'string' || type === 'number' || type === 'boolean') {
        return String(value);
    } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {
        return value.toString();
    } else {
        return JSON.stringify(value);
    }
}

var Literal = function Literal(type, value) {
    this.type = type;
    this.value = value;
};
Literal.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('\'literal\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');
    }
    if (!isValue(args[1])) {
        return context.error('invalid value');
    }
    var value = args[1];
    var type = typeOf(value);
    var expected = context.expectedType;
    if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {
        type = expected;
    }
    return new Literal(type, value);
};
Literal.prototype.evaluate = function evaluate() {
    return this.value;
};
Literal.prototype.eachChild = function eachChild() {
};
Literal.prototype.outputDefined = function outputDefined() {
    return true;
};
Literal.prototype.serialize = function serialize() {
    if (this.type.kind === 'array' || this.type.kind === 'object') {
        return [
            'literal',
            this.value
        ];
    } else if (this.value instanceof Color) {
        return ['rgba'].concat(this.value.toArray());
    } else if (this.value instanceof Formatted) {
        return this.value.serialize();
    } else {
        return this.value;
    }
};

var RuntimeError = function RuntimeError(message) {
    this.name = 'ExpressionEvaluationError';
    this.message = message;
};
RuntimeError.prototype.toJSON = function toJSON() {
    return this.message;
};

var types = {
    string: StringType,
    number: NumberType,
    boolean: BooleanType,
    object: ObjectType
};
var Assertion = function Assertion(type, args) {
    this.type = type;
    this.args = args;
};
Assertion.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var i = 1;
    var type;
    var name = args[0];
    if (name === 'array') {
        var itemType;
        if (args.length > 2) {
            var type$1 = args[1];
            if (typeof type$1 !== 'string' || !(type$1 in types) || type$1 === 'object') {
                return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
            }
            itemType = types[type$1];
            i++;
        } else {
            itemType = ValueType;
        }
        var N;
        if (args.length > 3) {
            if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
                return context.error('The length argument to "array" must be a positive integer literal', 2);
            }
            N = args[2];
            i++;
        }
        type = array(itemType, N);
    } else {
        type = types[name];
    }
    var parsed = [];
    for (; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) {
            return null;
        }
        parsed.push(input);
    }
    return new Assertion(type, parsed);
};
Assertion.prototype.evaluate = function evaluate(ctx) {
    for (var i = 0; i < this.args.length; i++) {
        var value = this.args[i].evaluate(ctx);
        var error = checkSubtype(this.type, typeOf(value));
        if (!error) {
            return value;
        } else if (i === this.args.length - 1) {
            throw new RuntimeError('Expected value to be of type ' + toString(this.type) + ', but found ' + toString(typeOf(value)) + ' instead.');
        }
    }
    return null;
};
Assertion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Assertion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Assertion.prototype.serialize = function serialize() {
    var type = this.type;
    var serialized = [type.kind];
    if (type.kind === 'array') {
        var itemType = type.itemType;
        if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {
            serialized.push(itemType.kind);
            var N = type.N;
            if (typeof N === 'number' || this.args.length > 1) {
                serialized.push(N);
            }
        }
    }
    return serialized.concat(this.args.map(function (arg) {
        return arg.serialize();
    }));
};

var FormatExpression = function FormatExpression(sections) {
    this.type = FormattedType;
    this.sections = sections;
};
FormatExpression.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var firstArg = args[1];
    if (!Array.isArray(firstArg) && typeof firstArg === 'object') {
        return context.error('First argument must be an image or text section.');
    }
    var sections = [];
    var nextTokenMayBeObject = false;
    for (var i = 1; i <= args.length - 1; ++i) {
        var arg = args[i];
        if (nextTokenMayBeObject && typeof arg === 'object' && !Array.isArray(arg)) {
            nextTokenMayBeObject = false;
            var scale = null;
            if (arg['font-scale']) {
                scale = context.parse(arg['font-scale'], 1, NumberType);
                if (!scale) {
                    return null;
                }
            }
            var font = null;
            if (arg['text-font']) {
                font = context.parse(arg['text-font'], 1, array(StringType));
                if (!font) {
                    return null;
                }
            }
            var textColor = null;
            if (arg['text-color']) {
                textColor = context.parse(arg['text-color'], 1, ColorType);
                if (!textColor) {
                    return null;
                }
            }
            var lastExpression = sections[sections.length - 1];
            lastExpression.scale = scale;
            lastExpression.font = font;
            lastExpression.textColor = textColor;
        } else {
            var content = context.parse(args[i], 1, ValueType);
            if (!content) {
                return null;
            }
            var kind = content.type.kind;
            if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage') {
                return context.error('Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.');
            }
            nextTokenMayBeObject = true;
            sections.push({
                content: content,
                scale: null,
                font: null,
                textColor: null
            });
        }
    }
    return new FormatExpression(sections);
};
FormatExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluateSection = function (section) {
        var evaluatedContent = section.content.evaluate(ctx);
        if (typeOf(evaluatedContent) === ResolvedImageType) {
            return new FormattedSection('', evaluatedContent, null, null, null);
        }
        return new FormattedSection(toString$1(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);
    };
    return new Formatted(this.sections.map(evaluateSection));
};
FormatExpression.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        fn(section.content);
        if (section.scale) {
            fn(section.scale);
        }
        if (section.font) {
            fn(section.font);
        }
        if (section.textColor) {
            fn(section.textColor);
        }
    }
};
FormatExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
FormatExpression.prototype.serialize = function serialize() {
    var serialized = ['format'];
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        serialized.push(section.content.serialize());
        var options = {};
        if (section.scale) {
            options['font-scale'] = section.scale.serialize();
        }
        if (section.font) {
            options['text-font'] = section.font.serialize();
        }
        if (section.textColor) {
            options['text-color'] = section.textColor.serialize();
        }
        serialized.push(options);
    }
    return serialized;
};

var ImageExpression = function ImageExpression(input) {
    this.type = ResolvedImageType;
    this.input = input;
};
ImageExpression.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected two arguments.');
    }
    var name = context.parse(args[1], 1, StringType);
    if (!name) {
        return context.error('No image name provided.');
    }
    return new ImageExpression(name);
};
ImageExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluatedImageName = this.input.evaluate(ctx);
    var value = ResolvedImage.fromString(evaluatedImageName);
    if (value && ctx.availableImages) {
        value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
    }
    return value;
};
ImageExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
};
ImageExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
ImageExpression.prototype.serialize = function serialize() {
    return [
        'image',
        this.input.serialize()
    ];
};

var types$1 = {
    'to-boolean': BooleanType,
    'to-color': ColorType,
    'to-number': NumberType,
    'to-string': StringType
};
var Coercion = function Coercion(type, args) {
    this.type = type;
    this.args = args;
};
Coercion.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var name = args[0];
    if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2) {
        return context.error('Expected one argument.');
    }
    var type = types$1[name];
    var parsed = [];
    for (var i = 1; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) {
            return null;
        }
        parsed.push(input);
    }
    return new Coercion(type, parsed);
};
Coercion.prototype.evaluate = function evaluate(ctx) {
    if (this.type.kind === 'boolean') {
        return Boolean(this.args[0].evaluate(ctx));
    } else if (this.type.kind === 'color') {
        var input;
        var error;
        for (var i = 0, list = this.args; i < list.length; i += 1) {
            var arg = list[i];
            input = arg.evaluate(ctx);
            error = null;
            if (input instanceof Color) {
                return input;
            } else if (typeof input === 'string') {
                var c = ctx.parseColor(input);
                if (c) {
                    return c;
                }
            } else if (Array.isArray(input)) {
                if (input.length < 3 || input.length > 4) {
                    error = 'Invalid rbga value ' + JSON.stringify(input) + ': expected an array containing either three or four numeric values.';
                } else {
                    error = validateRGBA(input[0], input[1], input[2], input[3]);
                }
                if (!error) {
                    return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
                }
            }
        }
        throw new RuntimeError(error || 'Could not parse color from value \'' + (typeof input === 'string' ? input : String(JSON.stringify(input))) + '\'');
    } else if (this.type.kind === 'number') {
        var value = null;
        for (var i$1 = 0, list$1 = this.args; i$1 < list$1.length; i$1 += 1) {
            var arg$1 = list$1[i$1];
            value = arg$1.evaluate(ctx);
            if (value === null) {
                return 0;
            }
            var num = Number(value);
            if (isNaN(num)) {
                continue;
            }
            return num;
        }
        throw new RuntimeError('Could not convert ' + JSON.stringify(value) + ' to number.');
    } else if (this.type.kind === 'formatted') {
        return Formatted.fromString(toString$1(this.args[0].evaluate(ctx)));
    } else if (this.type.kind === 'resolvedImage') {
        return ResolvedImage.fromString(toString$1(this.args[0].evaluate(ctx)));
    } else {
        return toString$1(this.args[0].evaluate(ctx));
    }
};
Coercion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Coercion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Coercion.prototype.serialize = function serialize() {
    if (this.type.kind === 'formatted') {
        return new FormatExpression([{
                content: this.args[0],
                scale: null,
                font: null,
                textColor: null
            }]).serialize();
    }
    if (this.type.kind === 'resolvedImage') {
        return new ImageExpression(this.args[0]).serialize();
    }
    var serialized = ['to-' + this.type.kind];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var geometryTypes = [
    'Unknown',
    'Point',
    'LineString',
    'Polygon'
];
var EvaluationContext = function EvaluationContext() {
    this.globals = null;
    this.feature = null;
    this.featureState = null;
    this.formattedSection = null;
    this._parseColorCache = {};
    this.availableImages = null;
    this.canonical = null;
};
EvaluationContext.prototype.id = function id() {
    return this.feature && 'id' in this.feature ? this.feature.id : null;
};
EvaluationContext.prototype.geometryType = function geometryType() {
    return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
};
EvaluationContext.prototype.geometry = function geometry() {
    return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
};
EvaluationContext.prototype.canonicalID = function canonicalID() {
    return this.canonical;
};
EvaluationContext.prototype.properties = function properties() {
    return this.feature && this.feature.properties || {};
};
EvaluationContext.prototype.parseColor = function parseColor(input) {
    var cached = this._parseColorCache[input];
    if (!cached) {
        cached = this._parseColorCache[input] = Color.parse(input);
    }
    return cached;
};

var CompoundExpression = function CompoundExpression(name, type, evaluate, args) {
    this.name = name;
    this.type = type;
    this._evaluate = evaluate;
    this.args = args;
};
CompoundExpression.prototype.evaluate = function evaluate(ctx) {
    return this._evaluate(ctx, this.args);
};
CompoundExpression.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
CompoundExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
CompoundExpression.prototype.serialize = function serialize() {
    return [this.name].concat(this.args.map(function (arg) {
        return arg.serialize();
    }));
};
CompoundExpression.parse = function parse(args, context) {
    var ref$1;
    var op = args[0];
    var definition = CompoundExpression.definitions[op];
    if (!definition) {
        return context.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
    }
    var type = Array.isArray(definition) ? definition[0] : definition.type;
    var availableOverloads = Array.isArray(definition) ? [[
            definition[1],
            definition[2]
        ]] : definition.overloads;
    var overloads = availableOverloads.filter(function (ref) {
        var signature = ref[0];
        return !Array.isArray(signature) || signature.length === args.length - 1;
    });
    var signatureContext = null;
    for (var i$3 = 0, list = overloads; i$3 < list.length; i$3 += 1) {
        var ref = list[i$3];
        var params = ref[0];
        var evaluate = ref[1];
        signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);
        var parsedArgs = [];
        var argParseFailed = false;
        for (var i = 1; i < args.length; i++) {
            var arg = args[i];
            var expectedType = Array.isArray(params) ? params[i - 1] : params.type;
            var parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
            if (!parsed) {
                argParseFailed = true;
                break;
            }
            parsedArgs.push(parsed);
        }
        if (argParseFailed) {
            continue;
        }
        if (Array.isArray(params)) {
            if (params.length !== parsedArgs.length) {
                signatureContext.error('Expected ' + params.length + ' arguments, but found ' + parsedArgs.length + ' instead.');
                continue;
            }
        }
        for (var i$1 = 0; i$1 < parsedArgs.length; i$1++) {
            var expected = Array.isArray(params) ? params[i$1] : params.type;
            var arg$1 = parsedArgs[i$1];
            signatureContext.concat(i$1 + 1).checkSubtype(expected, arg$1.type);
        }
        if (signatureContext.errors.length === 0) {
            return new CompoundExpression(op, type, evaluate, parsedArgs);
        }
    }
    if (overloads.length === 1) {
        (ref$1 = context.errors).push.apply(ref$1, signatureContext.errors);
    } else {
        var expected$1 = overloads.length ? overloads : availableOverloads;
        var signatures = expected$1.map(function (ref) {
            var params = ref[0];
            return stringifySignature(params);
        }).join(' | ');
        var actualTypes = [];
        for (var i$2 = 1; i$2 < args.length; i$2++) {
            var parsed$1 = context.parse(args[i$2], 1 + actualTypes.length);
            if (!parsed$1) {
                return null;
            }
            actualTypes.push(toString(parsed$1.type));
        }
        context.error('Expected arguments of type ' + signatures + ', but found (' + actualTypes.join(', ') + ') instead.');
    }
    return null;
};
CompoundExpression.register = function register(registry, definitions) {
    CompoundExpression.definitions = definitions;
    for (var name in definitions) {
        registry[name] = CompoundExpression;
    }
};
function stringifySignature(signature) {
    if (Array.isArray(signature)) {
        return '(' + signature.map(toString).join(', ') + ')';
    } else {
        return '(' + toString(signature.type) + '...)';
    }
}

var CollatorExpression = function CollatorExpression(caseSensitive, diacriticSensitive, locale) {
    this.type = CollatorType;
    this.locale = locale;
    this.caseSensitive = caseSensitive;
    this.diacriticSensitive = diacriticSensitive;
};
CollatorExpression.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected one argument.');
    }
    var options = args[1];
    if (typeof options !== 'object' || Array.isArray(options)) {
        return context.error('Collator options argument must be an object.');
    }
    var caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);
    if (!caseSensitive) {
        return null;
    }
    var diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);
    if (!diacriticSensitive) {
        return null;
    }
    var locale = null;
    if (options['locale']) {
        locale = context.parse(options['locale'], 1, StringType);
        if (!locale) {
            return null;
        }
    }
    return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
};
CollatorExpression.prototype.evaluate = function evaluate(ctx) {
    return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
};
CollatorExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.caseSensitive);
    fn(this.diacriticSensitive);
    if (this.locale) {
        fn(this.locale);
    }
};
CollatorExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
CollatorExpression.prototype.serialize = function serialize() {
    var options = {};
    options['case-sensitive'] = this.caseSensitive.serialize();
    options['diacritic-sensitive'] = this.diacriticSensitive.serialize();
    if (this.locale) {
        options['locale'] = this.locale.serialize();
    }
    return [
        'collator',
        options
    ];
};

var EXTENT = 8192;
function updateBBox(bbox, coord) {
    bbox[0] = Math.min(bbox[0], coord[0]);
    bbox[1] = Math.min(bbox[1], coord[1]);
    bbox[2] = Math.max(bbox[2], coord[0]);
    bbox[3] = Math.max(bbox[3], coord[1]);
}
function mercatorXfromLng(lng) {
    return (180 + lng) / 360;
}
function mercatorYfromLat(lat) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function boxWithinBox(bbox1, bbox2) {
    if (bbox1[0] <= bbox2[0]) {
        return false;
    }
    if (bbox1[2] >= bbox2[2]) {
        return false;
    }
    if (bbox1[1] <= bbox2[1]) {
        return false;
    }
    if (bbox1[3] >= bbox2[3]) {
        return false;
    }
    return true;
}
function getTileCoordinates(p, canonical) {
    var x = mercatorXfromLng(p[0]);
    var y = mercatorYfromLat(p[1]);
    var tilesAtZoom = Math.pow(2, canonical.z);
    return [
        Math.round(x * tilesAtZoom * EXTENT),
        Math.round(y * tilesAtZoom * EXTENT)
    ];
}
function onBoundary(p, p1, p2) {
    var x1 = p[0] - p1[0];
    var y1 = p[1] - p1[1];
    var x2 = p[0] - p2[0];
    var y2 = p[1] - p2[1];
    return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
}
function rayIntersect(p, p1, p2) {
    return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
}
function pointWithinPolygon(point, rings) {
    var inside = false;
    for (var i = 0, len = rings.length; i < len; i++) {
        var ring = rings[i];
        for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {
            if (onBoundary(point, ring[j], ring[j + 1])) {
                return false;
            }
            if (rayIntersect(point, ring[j], ring[j + 1])) {
                inside = !inside;
            }
        }
    }
    return inside;
}
function pointWithinPolygons(point, polygons) {
    for (var i = 0; i < polygons.length; i++) {
        if (pointWithinPolygon(point, polygons[i])) {
            return true;
        }
    }
    return false;
}
function perp(v1, v2) {
    return v1[0] * v2[1] - v1[1] * v2[0];
}
function twoSided(p1, p2, q1, q2) {
    var x1 = p1[0] - q1[0];
    var y1 = p1[1] - q1[1];
    var x2 = p2[0] - q1[0];
    var y2 = p2[1] - q1[1];
    var x3 = q2[0] - q1[0];
    var y3 = q2[1] - q1[1];
    var det1 = x1 * y3 - x3 * y1;
    var det2 = x2 * y3 - x3 * y2;
    if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) {
        return true;
    }
    return false;
}
function lineIntersectLine(a, b, c, d) {
    var vectorP = [
        b[0] - a[0],
        b[1] - a[1]
    ];
    var vectorQ = [
        d[0] - c[0],
        d[1] - c[1]
    ];
    if (perp(vectorQ, vectorP) === 0) {
        return false;
    }
    if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) {
        return true;
    }
    return false;
}
function lineIntersectPolygon(p1, p2, polygon) {
    for (var i = 0, list = polygon; i < list.length; i += 1) {
        var ring = list[i];
        for (var j = 0; j < ring.length - 1; ++j) {
            if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {
                return true;
            }
        }
    }
    return false;
}
function lineStringWithinPolygon(line, polygon) {
    for (var i = 0; i < line.length; ++i) {
        if (!pointWithinPolygon(line[i], polygon)) {
            return false;
        }
    }
    for (var i$1 = 0; i$1 < line.length - 1; ++i$1) {
        if (lineIntersectPolygon(line[i$1], line[i$1 + 1], polygon)) {
            return false;
        }
    }
    return true;
}
function lineStringWithinPolygons(line, polygons) {
    for (var i = 0; i < polygons.length; i++) {
        if (lineStringWithinPolygon(line, polygons[i])) {
            return true;
        }
    }
    return false;
}
function getTilePolygon(coordinates, bbox, canonical) {
    var polygon = [];
    for (var i = 0; i < coordinates.length; i++) {
        var ring = [];
        for (var j = 0; j < coordinates[i].length; j++) {
            var coord = getTileCoordinates(coordinates[i][j], canonical);
            updateBBox(bbox, coord);
            ring.push(coord);
        }
        polygon.push(ring);
    }
    return polygon;
}
function getTilePolygons(coordinates, bbox, canonical) {
    var polygons = [];
    for (var i = 0; i < coordinates.length; i++) {
        var polygon = getTilePolygon(coordinates[i], bbox, canonical);
        polygons.push(polygon);
    }
    return polygons;
}
function updatePoint(p, bbox, polyBBox, worldSize) {
    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
        var halfWorldSize = worldSize * 0.5;
        var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;
        if (shift === 0) {
            shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
        }
        p[0] += shift;
    }
    updateBBox(bbox, p);
}
function resetBBox(bbox) {
    bbox[0] = bbox[1] = Infinity;
    bbox[2] = bbox[3] = -Infinity;
}
function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [
        canonical.x * EXTENT,
        canonical.y * EXTENT
    ];
    var tilePoints = [];
    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
        var points = list$1[i$1];
        for (var i = 0, list = points; i < list.length; i += 1) {
            var point = list[i];
            var p = [
                point.x + shifts[0],
                point.y + shifts[1]
            ];
            updatePoint(p, pointBBox, polyBBox, worldSize);
            tilePoints.push(p);
        }
    }
    return tilePoints;
}
function getTileLines(geometry, lineBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [
        canonical.x * EXTENT,
        canonical.y * EXTENT
    ];
    var tileLines = [];
    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
        var line = list$1[i$1];
        var tileLine = [];
        for (var i = 0, list = line; i < list.length; i += 1) {
            var point = list[i];
            var p = [
                point.x + shifts[0],
                point.y + shifts[1]
            ];
            updateBBox(lineBBox, p);
            tileLine.push(p);
        }
        tileLines.push(tileLine);
    }
    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
        resetBBox(lineBBox);
        for (var i$3 = 0, list$3 = tileLines; i$3 < list$3.length; i$3 += 1) {
            var line$1 = list$3[i$3];
            for (var i$2 = 0, list$2 = line$1; i$2 < list$2.length; i$2 += 1) {
                var p$1 = list$2[i$2];
                updatePoint(p$1, lineBBox, polyBBox, worldSize);
            }
        }
    }
    return tileLines;
}
function pointsWithinPolygons(ctx, polygonGeometry) {
    var pointBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    var polyBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    var canonical = ctx.canonicalID();
    if (polygonGeometry.type === 'Polygon') {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) {
            return false;
        }
        for (var i = 0, list = tilePoints; i < list.length; i += 1) {
            var point = list[i];
            if (!pointWithinPolygon(point, tilePolygon)) {
                return false;
            }
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints$1 = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) {
            return false;
        }
        for (var i$1 = 0, list$1 = tilePoints$1; i$1 < list$1.length; i$1 += 1) {
            var point$1 = list$1[i$1];
            if (!pointWithinPolygons(point$1, tilePolygons)) {
                return false;
            }
        }
    }
    return true;
}
function linesWithinPolygons(ctx, polygonGeometry) {
    var lineBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    var polyBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    var canonical = ctx.canonicalID();
    if (polygonGeometry.type === 'Polygon') {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) {
            return false;
        }
        for (var i = 0, list = tileLines; i < list.length; i += 1) {
            var line = list[i];
            if (!lineStringWithinPolygon(line, tilePolygon)) {
                return false;
            }
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines$1 = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) {
            return false;
        }
        for (var i$1 = 0, list$1 = tileLines$1; i$1 < list$1.length; i$1 += 1) {
            var line$1 = list$1[i$1];
            if (!lineStringWithinPolygons(line$1, tilePolygons)) {
                return false;
            }
        }
    }
    return true;
}
var Within = function Within(geojson, geometries) {
    this.type = BooleanType;
    this.geojson = geojson;
    this.geometries = geometries;
};
Within.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('\'within\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');
    }
    if (isValue(args[1])) {
        var geojson = args[1];
        if (geojson.type === 'FeatureCollection') {
            for (var i = 0; i < geojson.features.length; ++i) {
                var type = geojson.features[i].geometry.type;
                if (type === 'Polygon' || type === 'MultiPolygon') {
                    return new Within(geojson, geojson.features[i].geometry);
                }
            }
        } else if (geojson.type === 'Feature') {
            var type$1 = geojson.geometry.type;
            if (type$1 === 'Polygon' || type$1 === 'MultiPolygon') {
                return new Within(geojson, geojson.geometry);
            }
        } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {
            return new Within(geojson, geojson);
        }
    }
    return context.error('\'within\' expression requires valid geojson object that contains polygon geometry type.');
};
Within.prototype.evaluate = function evaluate(ctx) {
    if (ctx.geometry() != null && ctx.canonicalID() != null) {
        if (ctx.geometryType() === 'Point') {
            return pointsWithinPolygons(ctx, this.geometries);
        } else if (ctx.geometryType() === 'LineString') {
            return linesWithinPolygons(ctx, this.geometries);
        }
    }
    return false;
};
Within.prototype.eachChild = function eachChild() {
};
Within.prototype.outputDefined = function outputDefined() {
    return true;
};
Within.prototype.serialize = function serialize() {
    return [
        'within',
        this.geojson
    ];
};

function isFeatureConstant(e) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'get' && e.args.length === 1) {
            return false;
        } else if (e.name === 'feature-state') {
            return false;
        } else if (e.name === 'has' && e.args.length === 1) {
            return false;
        } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {
            return false;
        } else if (/^filter-/.test(e.name)) {
            return false;
        }
    }
    if (e instanceof Within) {
        return false;
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isFeatureConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isStateConstant(e) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'feature-state') {
            return false;
        }
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isStateConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isGlobalPropertyConstant(e, properties) {
    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {
        return false;
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isGlobalPropertyConstant(arg, properties)) {
            result = false;
        }
    });
    return result;
}

var Var = function Var(name, boundExpression) {
    this.type = boundExpression.type;
    this.name = name;
    this.boundExpression = boundExpression;
};
Var.parse = function parse(args, context) {
    if (args.length !== 2 || typeof args[1] !== 'string') {
        return context.error('\'var\' expression requires exactly one string literal argument.');
    }
    var name = args[1];
    if (!context.scope.has(name)) {
        return context.error('Unknown variable "' + name + '". Make sure "' + name + '" has been bound in an enclosing "let" expression before using it.', 1);
    }
    return new Var(name, context.scope.get(name));
};
Var.prototype.evaluate = function evaluate(ctx) {
    return this.boundExpression.evaluate(ctx);
};
Var.prototype.eachChild = function eachChild() {
};
Var.prototype.outputDefined = function outputDefined() {
    return false;
};
Var.prototype.serialize = function serialize() {
    return [
        'var',
        this.name
    ];
};

var ParsingContext = function ParsingContext(registry, path, expectedType, scope, errors) {
    if (path === void 0)
        path = [];
    if (scope === void 0)
        scope = new Scope();
    if (errors === void 0)
        errors = [];
    this.registry = registry;
    this.path = path;
    this.key = path.map(function (part) {
        return '[' + part + ']';
    }).join('');
    this.scope = scope;
    this.errors = errors;
    this.expectedType = expectedType;
};
ParsingContext.prototype.parse = function parse(expr, index, expectedType, bindings, options) {
    if (options === void 0)
        options = {};
    if (index) {
        return this.concat(index, expectedType, bindings)._parse(expr, options);
    }
    return this._parse(expr, options);
};
ParsingContext.prototype._parse = function _parse(expr, options) {
    if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
        expr = [
            'literal',
            expr
        ];
    }
    function annotate(parsed, type, typeAnnotation) {
        if (typeAnnotation === 'assert') {
            return new Assertion(type, [parsed]);
        } else if (typeAnnotation === 'coerce') {
            return new Coercion(type, [parsed]);
        } else {
            return parsed;
        }
    }
    if (Array.isArray(expr)) {
        if (expr.length === 0) {
            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
        }
        var op = expr[0];
        if (typeof op !== 'string') {
            this.error('Expression name must be a string, but found ' + typeof op + ' instead. If you wanted a literal array, use ["literal", [...]].', 0);
            return null;
        }
        var Expr = this.registry[op];
        if (Expr) {
            var parsed = Expr.parse(expr, this);
            if (!parsed) {
                return null;
            }
            if (this.expectedType) {
                var expected = this.expectedType;
                var actual = parsed.type;
                if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {
                    parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');
                } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {
                    parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');
                } else if (this.checkSubtype(expected, actual)) {
                    return null;
                }
            }
            if (!(parsed instanceof Literal) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {
                var ec = new EvaluationContext();
                try {
                    parsed = new Literal(parsed.type, parsed.evaluate(ec));
                } catch (e) {
                    this.error(e.message);
                    return null;
                }
            }
            return parsed;
        }
        return this.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
    } else if (typeof expr === 'undefined') {
        return this.error('\'undefined\' value invalid. Use null instead.');
    } else if (typeof expr === 'object') {
        return this.error('Bare objects invalid. Use ["literal", {...}] instead.');
    } else {
        return this.error('Expected an array, but found ' + typeof expr + ' instead.');
    }
};
ParsingContext.prototype.concat = function concat(index, expectedType, bindings) {
    var path = typeof index === 'number' ? this.path.concat(index) : this.path;
    var scope = bindings ? this.scope.concat(bindings) : this.scope;
    return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
};
ParsingContext.prototype.error = function error(error$1) {
    var keys = [], len = arguments.length - 1;
    while (len-- > 0)
        keys[len] = arguments[len + 1];
    var key = '' + this.key + keys.map(function (k) {
        return '[' + k + ']';
    }).join('');
    this.errors.push(new ParsingError(key, error$1));
};
ParsingContext.prototype.checkSubtype = function checkSubtype$1(expected, t) {
    var error = checkSubtype(expected, t);
    if (error) {
        this.error(error);
    }
    return error;
};
function isConstant(expression) {
    if (expression instanceof Var) {
        return isConstant(expression.boundExpression);
    } else if (expression instanceof CompoundExpression && expression.name === 'error') {
        return false;
    } else if (expression instanceof CollatorExpression) {
        return false;
    } else if (expression instanceof Within) {
        return false;
    }
    var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;
    var childrenConstant = true;
    expression.eachChild(function (child) {
        if (isTypeAnnotation) {
            childrenConstant = childrenConstant && isConstant(child);
        } else {
            childrenConstant = childrenConstant && child instanceof Literal;
        }
    });
    if (!childrenConstant) {
        return false;
    }
    return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, [
        'zoom',
        'heatmap-density',
        'line-progress',
        'accumulated',
        'is-supported-script'
    ]);
}

function findStopLessThanOrEqualTo(stops, input) {
    var lastIndex = stops.length - 1;
    var lowerIndex = 0;
    var upperIndex = lastIndex;
    var currentIndex = 0;
    var currentValue, nextValue;
    while (lowerIndex <= upperIndex) {
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex];
        nextValue = stops[currentIndex + 1];
        if (currentValue <= input) {
            if (currentIndex === lastIndex || input < nextValue) {
                return currentIndex;
            }
            lowerIndex = currentIndex + 1;
        } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
        } else {
            throw new RuntimeError('Input is not a number.');
        }
    }
    return 0;
}

var Step = function Step(type, input, stops) {
    this.type = type;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];
        this.labels.push(label);
        this.outputs.push(expression);
    }
};
Step.parse = function parse(args, context) {
    if (args.length - 1 < 4) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if ((args.length - 1) % 2 !== 0) {
        return context.error('Expected an even number of arguments.');
    }
    var input = context.parse(args[1], 1, NumberType);
    if (!input) {
        return null;
    }
    var stops = [];
    var outputType = null;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    for (var i = 1; i < args.length; i += 2) {
        var label = i === 1 ? -Infinity : args[i];
        var value = args[i + 1];
        var labelKey = i;
        var valueKey = i + 1;
        if (typeof label !== 'number') {
            return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }
        if (stops.length && stops[stops.length - 1][0] >= label) {
            return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }
        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        stops.push([
            label,
            parsed
        ]);
    }
    return new Step(outputType, input, stops);
};
Step.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;
    if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
    }
    var value = this.input.evaluate(ctx);
    if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
    }
    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
    }
    var index = findStopLessThanOrEqualTo(labels, value);
    return outputs[index].evaluate(ctx);
};
Step.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
        var expression = list[i];
        fn(expression);
    }
};
Step.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    });
};
Step.prototype.serialize = function serialize() {
    var serialized = [
        'step',
        this.input.serialize()
    ];
    for (var i = 0; i < this.labels.length; i++) {
        if (i > 0) {
            serialized.push(this.labels[i]);
        }
        serialized.push(this.outputs[i].serialize());
    }
    return serialized;
};

/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

var unitbezier = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === 'undefined') { epsilon = 1e-6; }

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) { return t2; }

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) { break; }

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) { return t0; }
    if (t2 > t1) { return t1; }

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) { return t2; }

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

function number(a, b, t) {
    return a * (1 - t) + b * t;
}
function color(from, to, t) {
    return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
}
function array$1(from, to, t) {
    return from.map(function (d, i) {
        return number(d, to[i], t);
    });
}

var interpolate = /*#__PURE__*/Object.freeze({
  __proto__: null,
  number: number,
  color: color,
  array: array$1
});

var Xn = 0.95047, Yn = 1, Zn = 1.08883, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1, deg2rad = Math.PI / 180, rad2deg = 180 / Math.PI;
function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
}
function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2xyz(x) {
    x /= 255;
    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function rgbToLab(rgbColor) {
    var b = rgb2xyz(rgbColor.r), a = rgb2xyz(rgbColor.g), l = rgb2xyz(rgbColor.b), x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn), y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn), z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
    return {
        l: 116 * y - 16,
        a: 500 * (x - y),
        b: 200 * (y - z),
        alpha: rgbColor.a
    };
}
function labToRgb(labColor) {
    var y = (labColor.l + 16) / 116, x = isNaN(labColor.a) ? y : y + labColor.a / 500, z = isNaN(labColor.b) ? y : y - labColor.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
}
function interpolateLab(from, to, t) {
    return {
        l: number(from.l, to.l, t),
        a: number(from.a, to.a, t),
        b: number(from.b, to.b, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
function rgbToHcl(rgbColor) {
    var ref = rgbToLab(rgbColor);
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var h = Math.atan2(b, a) * rad2deg;
    return {
        h: h < 0 ? h + 360 : h,
        c: Math.sqrt(a * a + b * b),
        l: l,
        alpha: rgbColor.a
    };
}
function hclToRgb(hclColor) {
    var h = hclColor.h * deg2rad, c = hclColor.c, l = hclColor.l;
    return labToRgb({
        l: l,
        a: Math.cos(h) * c,
        b: Math.sin(h) * c,
        alpha: hclColor.alpha
    });
}
function interpolateHue(a, b, t) {
    var d = b - a;
    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
}
function interpolateHcl(from, to, t) {
    return {
        h: interpolateHue(from.h, to.h, t),
        c: number(from.c, to.c, t),
        l: number(from.l, to.l, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
var lab = {
    forward: rgbToLab,
    reverse: labToRgb,
    interpolate: interpolateLab
};
var hcl = {
    forward: rgbToHcl,
    reverse: hclToRgb,
    interpolate: interpolateHcl
};

var colorSpaces = /*#__PURE__*/Object.freeze({
  __proto__: null,
  lab: lab,
  hcl: hcl
});

var Interpolate = function Interpolate(type, operator, interpolation, input, stops) {
    this.type = type;
    this.operator = operator;
    this.interpolation = interpolation;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];
        this.labels.push(label);
        this.outputs.push(expression);
    }
};
Interpolate.interpolationFactor = function interpolationFactor(interpolation, input, lower, upper) {
    var t = 0;
    if (interpolation.name === 'exponential') {
        t = exponentialInterpolation(input, interpolation.base, lower, upper);
    } else if (interpolation.name === 'linear') {
        t = exponentialInterpolation(input, 1, lower, upper);
    } else if (interpolation.name === 'cubic-bezier') {
        var c = interpolation.controlPoints;
        var ub = new unitbezier(c[0], c[1], c[2], c[3]);
        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
    }
    return t;
};
Interpolate.parse = function parse(args, context) {
    var operator = args[0];
    var interpolation = args[1];
    var input = args[2];
    var rest = args.slice(3);
    if (!Array.isArray(interpolation) || interpolation.length === 0) {
        return context.error('Expected an interpolation type expression.', 1);
    }
    if (interpolation[0] === 'linear') {
        interpolation = { name: 'linear' };
    } else if (interpolation[0] === 'exponential') {
        var base = interpolation[1];
        if (typeof base !== 'number') {
            return context.error('Exponential interpolation requires a numeric base.', 1, 1);
        }
        interpolation = {
            name: 'exponential',
            base: base
        };
    } else if (interpolation[0] === 'cubic-bezier') {
        var controlPoints = interpolation.slice(1);
        if (controlPoints.length !== 4 || controlPoints.some(function (t) {
                return typeof t !== 'number' || t < 0 || t > 1;
            })) {
            return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
        }
        interpolation = {
            name: 'cubic-bezier',
            controlPoints: controlPoints
        };
    } else {
        return context.error('Unknown interpolation type ' + String(interpolation[0]), 1, 0);
    }
    if (args.length - 1 < 4) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if ((args.length - 1) % 2 !== 0) {
        return context.error('Expected an even number of arguments.');
    }
    input = context.parse(input, 2, NumberType);
    if (!input) {
        return null;
    }
    var stops = [];
    var outputType = null;
    if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {
        outputType = ColorType;
    } else if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    for (var i = 0; i < rest.length; i += 2) {
        var label = rest[i];
        var value = rest[i + 1];
        var labelKey = i + 3;
        var valueKey = i + 4;
        if (typeof label !== 'number') {
            return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }
        if (stops.length && stops[stops.length - 1][0] >= label) {
            return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }
        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        stops.push([
            label,
            parsed
        ]);
    }
    if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
        return context.error('Type ' + toString(outputType) + ' is not interpolatable.');
    }
    return new Interpolate(outputType, operator, interpolation, input, stops);
};
Interpolate.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;
    if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
    }
    var value = this.input.evaluate(ctx);
    if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
    }
    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
    }
    var index = findStopLessThanOrEqualTo(labels, value);
    var lower = labels[index];
    var upper = labels[index + 1];
    var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
    var outputLower = outputs[index].evaluate(ctx);
    var outputUpper = outputs[index + 1].evaluate(ctx);
    if (this.operator === 'interpolate') {
        return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);
    } else if (this.operator === 'interpolate-hcl') {
        return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
    } else {
        return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
    }
};
Interpolate.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
        var expression = list[i];
        fn(expression);
    }
};
Interpolate.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    });
};
Interpolate.prototype.serialize = function serialize() {
    var interpolation;
    if (this.interpolation.name === 'linear') {
        interpolation = ['linear'];
    } else if (this.interpolation.name === 'exponential') {
        if (this.interpolation.base === 1) {
            interpolation = ['linear'];
        } else {
            interpolation = [
                'exponential',
                this.interpolation.base
            ];
        }
    } else {
        interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);
    }
    var serialized = [
        this.operator,
        interpolation,
        this.input.serialize()
    ];
    for (var i = 0; i < this.labels.length; i++) {
        serialized.push(this.labels[i], this.outputs[i].serialize());
    }
    return serialized;
};
function exponentialInterpolation(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

var Coalesce = function Coalesce(type, args) {
    this.type = type;
    this.args = args;
};
Coalesce.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expectected at least one argument.');
    }
    var outputType = null;
    var expectedType = context.expectedType;
    if (expectedType && expectedType.kind !== 'value') {
        outputType = expectedType;
    }
    var parsedArgs = [];
    for (var i = 0, list = args.slice(1); i < list.length; i += 1) {
        var arg = list[i];
        var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, { typeAnnotation: 'omit' });
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        parsedArgs.push(parsed);
    }
    var needsAnnotation = expectedType && parsedArgs.some(function (arg) {
        return checkSubtype(expectedType, arg.type);
    });
    return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
};
Coalesce.prototype.evaluate = function evaluate(ctx) {
    var result = null;
    var argCount = 0;
    var requestedImageName;
    for (var i = 0, list = this.args; i < list.length; i += 1) {
        var arg = list[i];
        argCount++;
        result = arg.evaluate(ctx);
        if (result && result instanceof ResolvedImage && !result.available) {
            if (!requestedImageName) {
                requestedImageName = result.name;
            }
            result = null;
            if (argCount === this.args.length) {
                result = requestedImageName;
            }
        }
        if (result !== null) {
            break;
        }
    }
    return result;
};
Coalesce.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Coalesce.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Coalesce.prototype.serialize = function serialize() {
    var serialized = ['coalesce'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var Let = function Let(bindings, result) {
    this.type = result.type;
    this.bindings = [].concat(bindings);
    this.result = result;
};
Let.prototype.evaluate = function evaluate(ctx) {
    return this.result.evaluate(ctx);
};
Let.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
        var binding = list[i];
        fn(binding[1]);
    }
    fn(this.result);
};
Let.parse = function parse(args, context) {
    if (args.length < 4) {
        return context.error('Expected at least 3 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var bindings = [];
    for (var i = 1; i < args.length - 1; i += 2) {
        var name = args[i];
        if (typeof name !== 'string') {
            return context.error('Expected string, but found ' + typeof name + ' instead.', i);
        }
        if (/[^a-zA-Z0-9_]/.test(name)) {
            return context.error('Variable names must contain only alphanumeric characters or \'_\'.', i);
        }
        var value = context.parse(args[i + 1], i + 1);
        if (!value) {
            return null;
        }
        bindings.push([
            name,
            value
        ]);
    }
    var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
    if (!result) {
        return null;
    }
    return new Let(bindings, result);
};
Let.prototype.outputDefined = function outputDefined() {
    return this.result.outputDefined();
};
Let.prototype.serialize = function serialize() {
    var serialized = ['let'];
    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
        var ref = list[i];
        var name = ref[0];
        var expr = ref[1];
        serialized.push(name, expr.serialize());
    }
    serialized.push(this.result.serialize());
    return serialized;
};

var At = function At(type, index, input) {
    this.type = type;
    this.index = index;
    this.input = input;
};
At.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var index = context.parse(args[1], 1, NumberType);
    var input = context.parse(args[2], 2, array(context.expectedType || ValueType));
    if (!index || !input) {
        return null;
    }
    var t = input.type;
    return new At(t.itemType, index, input);
};
At.prototype.evaluate = function evaluate(ctx) {
    var index = this.index.evaluate(ctx);
    var array = this.input.evaluate(ctx);
    if (index < 0) {
        throw new RuntimeError('Array index out of bounds: ' + index + ' < 0.');
    }
    if (index >= array.length) {
        throw new RuntimeError('Array index out of bounds: ' + index + ' > ' + (array.length - 1) + '.');
    }
    if (index !== Math.floor(index)) {
        throw new RuntimeError('Array index must be an integer, but found ' + index + ' instead.');
    }
    return array[index];
};
At.prototype.eachChild = function eachChild(fn) {
    fn(this.index);
    fn(this.input);
};
At.prototype.outputDefined = function outputDefined() {
    return false;
};
At.prototype.serialize = function serialize() {
    return [
        'at',
        this.index.serialize(),
        this.input.serialize()
    ];
};

var In = function In(needle, haystack) {
    this.type = BooleanType;
    this.needle = needle;
    this.haystack = haystack;
};
In.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack) {
        return null;
    }
    if (!isValidType(needle.type, [
            BooleanType,
            StringType,
            NumberType,
            NullType,
            ValueType
        ])) {
        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');
    }
    return new In(needle, haystack);
};
In.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);
    if (!haystack) {
        return false;
    }
    if (!isValidNativeType(needle, [
            'boolean',
            'string',
            'number',
            'null'
        ])) {
        throw new RuntimeError('Expected first argument to be of type boolean, string, number or null, but found ' + toString(typeOf(needle)) + ' instead.');
    }
    if (!isValidNativeType(haystack, [
            'string',
            'array'
        ])) {
        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');
    }
    return haystack.indexOf(needle) >= 0;
};
In.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
};
In.prototype.outputDefined = function outputDefined() {
    return true;
};
In.prototype.serialize = function serialize() {
    return [
        'in',
        this.needle.serialize(),
        this.haystack.serialize()
    ];
};

var IndexOf = function IndexOf(needle, haystack, fromIndex) {
    this.type = NumberType;
    this.needle = needle;
    this.haystack = haystack;
    this.fromIndex = fromIndex;
};
IndexOf.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
        return context.error('Expected 3 or 4 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack) {
        return null;
    }
    if (!isValidType(needle.type, [
            BooleanType,
            StringType,
            NumberType,
            NullType,
            ValueType
        ])) {
        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');
    }
    if (args.length === 4) {
        var fromIndex = context.parse(args[3], 3, NumberType);
        if (!fromIndex) {
            return null;
        }
        return new IndexOf(needle, haystack, fromIndex);
    } else {
        return new IndexOf(needle, haystack);
    }
};
IndexOf.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);
    if (!isValidNativeType(needle, [
            'boolean',
            'string',
            'number',
            'null'
        ])) {
        throw new RuntimeError('Expected first argument to be of type boolean, string, number or null, but found ' + toString(typeOf(needle)) + ' instead.');
    }
    if (!isValidNativeType(haystack, [
            'string',
            'array'
        ])) {
        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');
    }
    if (this.fromIndex) {
        var fromIndex = this.fromIndex.evaluate(ctx);
        return haystack.indexOf(needle, fromIndex);
    }
    return haystack.indexOf(needle);
};
IndexOf.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
    if (this.fromIndex) {
        fn(this.fromIndex);
    }
};
IndexOf.prototype.outputDefined = function outputDefined() {
    return false;
};
IndexOf.prototype.serialize = function serialize() {
    if (this.fromIndex != null && this.fromIndex !== undefined) {
        var fromIndex = this.fromIndex.serialize();
        return [
            'index-of',
            this.needle.serialize(),
            this.haystack.serialize(),
            fromIndex
        ];
    }
    return [
        'index-of',
        this.needle.serialize(),
        this.haystack.serialize()
    ];
};

var Match = function Match(inputType, outputType, input, cases, outputs, otherwise) {
    this.inputType = inputType;
    this.type = outputType;
    this.input = input;
    this.cases = cases;
    this.outputs = outputs;
    this.otherwise = otherwise;
};
Match.parse = function parse(args, context) {
    if (args.length < 5) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if (args.length % 2 !== 1) {
        return context.error('Expected an even number of arguments.');
    }
    var inputType;
    var outputType;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    var cases = {};
    var outputs = [];
    for (var i = 2; i < args.length - 1; i += 2) {
        var labels = args[i];
        var value = args[i + 1];
        if (!Array.isArray(labels)) {
            labels = [labels];
        }
        var labelContext = context.concat(i);
        if (labels.length === 0) {
            return labelContext.error('Expected at least one branch label.');
        }
        for (var i$1 = 0, list = labels; i$1 < list.length; i$1 += 1) {
            var label = list[i$1];
            if (typeof label !== 'number' && typeof label !== 'string') {
                return labelContext.error('Branch labels must be numbers or strings.');
            } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
                return labelContext.error('Branch labels must be integers no larger than ' + Number.MAX_SAFE_INTEGER + '.');
            } else if (typeof label === 'number' && Math.floor(label) !== label) {
                return labelContext.error('Numeric branch labels must be integer values.');
            } else if (!inputType) {
                inputType = typeOf(label);
            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
                return null;
            }
            if (typeof cases[String(label)] !== 'undefined') {
                return labelContext.error('Branch labels must be unique.');
            }
            cases[String(label)] = outputs.length;
        }
        var result = context.parse(value, i, outputType);
        if (!result) {
            return null;
        }
        outputType = outputType || result.type;
        outputs.push(result);
    }
    var input = context.parse(args[1], 1, ValueType);
    if (!input) {
        return null;
    }
    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) {
        return null;
    }
    if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {
        return null;
    }
    return new Match(inputType, outputType, input, cases, outputs, otherwise);
};
Match.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
    return output.evaluate(ctx);
};
Match.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    this.outputs.forEach(fn);
    fn(this.otherwise);
};
Match.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    }) && this.otherwise.outputDefined();
};
Match.prototype.serialize = function serialize() {
    var this$1$1 = this;
    var serialized = [
        'match',
        this.input.serialize()
    ];
    var sortedLabels = Object.keys(this.cases).sort();
    var groupedByOutput = [];
    var outputLookup = {};
    for (var i = 0, list = sortedLabels; i < list.length; i += 1) {
        var label = list[i];
        var outputIndex = outputLookup[this.cases[label]];
        if (outputIndex === undefined) {
            outputLookup[this.cases[label]] = groupedByOutput.length;
            groupedByOutput.push([
                this.cases[label],
                [label]
            ]);
        } else {
            groupedByOutput[outputIndex][1].push(label);
        }
    }
    var coerceLabel = function (label) {
        return this$1$1.inputType.kind === 'number' ? Number(label) : label;
    };
    for (var i$1 = 0, list$1 = groupedByOutput; i$1 < list$1.length; i$1 += 1) {
        var ref = list$1[i$1];
        var outputIndex = ref[0];
        var labels = ref[1];
        if (labels.length === 1) {
            serialized.push(coerceLabel(labels[0]));
        } else {
            serialized.push(labels.map(coerceLabel));
        }
        serialized.push(this.outputs[outputIndex$1].serialize());
    }
    serialized.push(this.otherwise.serialize());
    return serialized;
};

var Case = function Case(type, branches, otherwise) {
    this.type = type;
    this.branches = branches;
    this.otherwise = otherwise;
};
Case.parse = function parse(args, context) {
    if (args.length < 4) {
        return context.error('Expected at least 3 arguments, but found only ' + (args.length - 1) + '.');
    }
    if (args.length % 2 !== 0) {
        return context.error('Expected an odd number of arguments.');
    }
    var outputType;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    var branches = [];
    for (var i = 1; i < args.length - 1; i += 2) {
        var test = context.parse(args[i], i, BooleanType);
        if (!test) {
            return null;
        }
        var result = context.parse(args[i + 1], i + 1, outputType);
        if (!result) {
            return null;
        }
        branches.push([
            test,
            result
        ]);
        outputType = outputType || result.type;
    }
    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) {
        return null;
    }
    return new Case(outputType, branches, otherwise);
};
Case.prototype.evaluate = function evaluate(ctx) {
    for (var i = 0, list = this.branches; i < list.length; i += 1) {
        var ref = list[i];
        var test = ref[0];
        var expression = ref[1];
        if (test.evaluate(ctx)) {
            return expression.evaluate(ctx);
        }
    }
    return this.otherwise.evaluate(ctx);
};
Case.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.branches; i < list.length; i += 1) {
        var ref = list[i];
        var test = ref[0];
        var expression = ref[1];
        fn(test);
        fn(expression);
    }
    fn(this.otherwise);
};
Case.prototype.outputDefined = function outputDefined() {
    return this.branches.every(function (ref) {
        ref[0];
        var out = ref[1];
        return out.outputDefined();
    }) && this.otherwise.outputDefined();
};
Case.prototype.serialize = function serialize() {
    var serialized = ['case'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var Slice = function Slice(type, input, beginIndex, endIndex) {
    this.type = type;
    this.input = input;
    this.beginIndex = beginIndex;
    this.endIndex = endIndex;
};
Slice.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
        return context.error('Expected 3 or 4 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var input = context.parse(args[1], 1, ValueType);
    var beginIndex = context.parse(args[2], 2, NumberType);
    if (!input || !beginIndex) {
        return null;
    }
    if (!isValidType(input.type, [
            array(ValueType),
            StringType,
            ValueType
        ])) {
        return context.error('Expected first argument to be of type array or string, but found ' + toString(input.type) + ' instead');
    }
    if (args.length === 4) {
        var endIndex = context.parse(args[3], 3, NumberType);
        if (!endIndex) {
            return null;
        }
        return new Slice(input.type, input, beginIndex, endIndex);
    } else {
        return new Slice(input.type, input, beginIndex);
    }
};
Slice.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var beginIndex = this.beginIndex.evaluate(ctx);
    if (!isValidNativeType(input, [
            'string',
            'array'
        ])) {
        throw new RuntimeError('Expected first argument to be of type array or string, but found ' + toString(typeOf(input)) + ' instead.');
    }
    if (this.endIndex) {
        var endIndex = this.endIndex.evaluate(ctx);
        return input.slice(beginIndex, endIndex);
    }
    return input.slice(beginIndex);
};
Slice.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    fn(this.beginIndex);
    if (this.endIndex) {
        fn(this.endIndex);
    }
};
Slice.prototype.outputDefined = function outputDefined() {
    return false;
};
Slice.prototype.serialize = function serialize() {
    if (this.endIndex != null && this.endIndex !== undefined) {
        var endIndex = this.endIndex.serialize();
        return [
            'slice',
            this.input.serialize(),
            this.beginIndex.serialize(),
            endIndex
        ];
    }
    return [
        'slice',
        this.input.serialize(),
        this.beginIndex.serialize()
    ];
};

function isComparableType(op, type) {
    if (op === '==' || op === '!=') {
        return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';
    } else {
        return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';
    }
}
function eq(ctx, a, b) {
    return a === b;
}
function neq(ctx, a, b) {
    return a !== b;
}
function lt(ctx, a, b) {
    return a < b;
}
function gt(ctx, a, b) {
    return a > b;
}
function lteq(ctx, a, b) {
    return a <= b;
}
function gteq(ctx, a, b) {
    return a >= b;
}
function eqCollate(ctx, a, b, c) {
    return c.compare(a, b) === 0;
}
function neqCollate(ctx, a, b, c) {
    return !eqCollate(ctx, a, b, c);
}
function ltCollate(ctx, a, b, c) {
    return c.compare(a, b) < 0;
}
function gtCollate(ctx, a, b, c) {
    return c.compare(a, b) > 0;
}
function lteqCollate(ctx, a, b, c) {
    return c.compare(a, b) <= 0;
}
function gteqCollate(ctx, a, b, c) {
    return c.compare(a, b) >= 0;
}
function makeComparison(op, compareBasic, compareWithCollator) {
    var isOrderComparison = op !== '==' && op !== '!=';
    return function () {
        function Comparison(lhs, rhs, collator) {
            this.type = BooleanType;
            this.lhs = lhs;
            this.rhs = rhs;
            this.collator = collator;
            this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';
        }
        Comparison.parse = function parse(args, context) {
            if (args.length !== 3 && args.length !== 4) {
                return context.error('Expected two or three arguments.');
            }
            var op = args[0];
            var lhs = context.parse(args[1], 1, ValueType);
            if (!lhs) {
                return null;
            }
            if (!isComparableType(op, lhs.type)) {
                return context.concat(1).error('"' + op + '" comparisons are not supported for type \'' + toString(lhs.type) + '\'.');
            }
            var rhs = context.parse(args[2], 2, ValueType);
            if (!rhs) {
                return null;
            }
            if (!isComparableType(op, rhs.type)) {
                return context.concat(2).error('"' + op + '" comparisons are not supported for type \'' + toString(rhs.type) + '\'.');
            }
            if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                return context.error('Cannot compare types \'' + toString(lhs.type) + '\' and \'' + toString(rhs.type) + '\'.');
            }
            if (isOrderComparison) {
                if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {
                    lhs = new Assertion(rhs.type, [lhs]);
                } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {
                    rhs = new Assertion(lhs.type, [rhs]);
                }
            }
            var collator = null;
            if (args.length === 4) {
                if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                    return context.error('Cannot use collator to compare non-string types.');
                }
                collator = context.parse(args[3], 3, CollatorType);
                if (!collator) {
                    return null;
                }
            }
            return new Comparison(lhs, rhs, collator);
        };
        Comparison.prototype.evaluate = function evaluate(ctx) {
            var lhs = this.lhs.evaluate(ctx);
            var rhs = this.rhs.evaluate(ctx);
            if (isOrderComparison && this.hasUntypedArgument) {
                var lt = typeOf(lhs);
                var rt = typeOf(rhs);
                if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {
                    throw new RuntimeError('Expected arguments for "' + op + '" to be (string, string) or (number, number), but found (' + lt.kind + ', ' + rt.kind + ') instead.');
                }
            }
            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
                var lt$1 = typeOf(lhs);
                var rt$1 = typeOf(rhs);
                if (lt$1.kind !== 'string' || rt$1.kind !== 'string') {
                    return compareBasic(ctx, lhs, rhs);
                }
            }
            return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
        };
        Comparison.prototype.eachChild = function eachChild(fn) {
            fn(this.lhs);
            fn(this.rhs);
            if (this.collator) {
                fn(this.collator);
            }
        };
        Comparison.prototype.outputDefined = function outputDefined() {
            return true;
        };
        Comparison.prototype.serialize = function serialize() {
            var serialized = [op];
            this.eachChild(function (child) {
                serialized.push(child.serialize());
            });
            return serialized;
        };
        return Comparison;
    }();
}
var Equals = makeComparison('==', eq, eqCollate);
var NotEquals = makeComparison('!=', neq, neqCollate);
var LessThan = makeComparison('<', lt, ltCollate);
var GreaterThan = makeComparison('>', gt, gtCollate);
var LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);
var GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);

var NumberFormat = function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {
    this.type = StringType;
    this.number = number;
    this.locale = locale;
    this.currency = currency;
    this.minFractionDigits = minFractionDigits;
    this.maxFractionDigits = maxFractionDigits;
};
NumberFormat.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected two arguments.');
    }
    var number = context.parse(args[1], 1, NumberType);
    if (!number) {
        return null;
    }
    var options = args[2];
    if (typeof options !== 'object' || Array.isArray(options)) {
        return context.error('NumberFormat options argument must be an object.');
    }
    var locale = null;
    if (options['locale']) {
        locale = context.parse(options['locale'], 1, StringType);
        if (!locale) {
            return null;
        }
    }
    var currency = null;
    if (options['currency']) {
        currency = context.parse(options['currency'], 1, StringType);
        if (!currency) {
            return null;
        }
    }
    var minFractionDigits = null;
    if (options['min-fraction-digits']) {
        minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);
        if (!minFractionDigits) {
            return null;
        }
    }
    var maxFractionDigits = null;
    if (options['max-fraction-digits']) {
        maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);
        if (!maxFractionDigits) {
            return null;
        }
    }
    return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);
};
NumberFormat.prototype.evaluate = function evaluate(ctx) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
        style: this.currency ? 'currency' : 'decimal',
        currency: this.currency ? this.currency.evaluate(ctx) : undefined,
        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
    }).format(this.number.evaluate(ctx));
};
NumberFormat.prototype.eachChild = function eachChild(fn) {
    fn(this.number);
    if (this.locale) {
        fn(this.locale);
    }
    if (this.currency) {
        fn(this.currency);
    }
    if (this.minFractionDigits) {
        fn(this.minFractionDigits);
    }
    if (this.maxFractionDigits) {
        fn(this.maxFractionDigits);
    }
};
NumberFormat.prototype.outputDefined = function outputDefined() {
    return false;
};
NumberFormat.prototype.serialize = function serialize() {
    var options = {};
    if (this.locale) {
        options['locale'] = this.locale.serialize();
    }
    if (this.currency) {
        options['currency'] = this.currency.serialize();
    }
    if (this.minFractionDigits) {
        options['min-fraction-digits'] = this.minFractionDigits.serialize();
    }
    if (this.maxFractionDigits) {
        options['max-fraction-digits'] = this.maxFractionDigits.serialize();
    }
    return [
        'number-format',
        this.number.serialize(),
        options
    ];
};

var Length = function Length(input) {
    this.type = NumberType;
    this.input = input;
};
Length.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected 1 argument, but found ' + (args.length - 1) + ' instead.');
    }
    var input = context.parse(args[1], 1);
    if (!input) {
        return null;
    }
    if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value') {
        return context.error('Expected argument of type string or array, but found ' + toString(input.type) + ' instead.');
    }
    return new Length(input);
};
Length.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    if (typeof input === 'string') {
        return input.length;
    } else if (Array.isArray(input)) {
        return input.length;
    } else {
        throw new RuntimeError('Expected value to be of type string or array, but found ' + toString(typeOf(input)) + ' instead.');
    }
};
Length.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
};
Length.prototype.outputDefined = function outputDefined() {
    return false;
};
Length.prototype.serialize = function serialize() {
    var serialized = ['length'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var expressions = {
    '==': Equals,
    '!=': NotEquals,
    '>': GreaterThan,
    '<': LessThan,
    '>=': GreaterThanOrEqual,
    '<=': LessThanOrEqual,
    'array': Assertion,
    'at': At,
    'boolean': Assertion,
    'case': Case,
    'coalesce': Coalesce,
    'collator': CollatorExpression,
    'format': FormatExpression,
    'image': ImageExpression,
    'in': In,
    'index-of': IndexOf,
    'interpolate': Interpolate,
    'interpolate-hcl': Interpolate,
    'interpolate-lab': Interpolate,
    'length': Length,
    'let': Let,
    'literal': Literal,
    'match': Match,
    'number': Assertion,
    'number-format': NumberFormat,
    'object': Assertion,
    'slice': Slice,
    'step': Step,
    'string': Assertion,
    'to-boolean': Coercion,
    'to-color': Coercion,
    'to-number': Coercion,
    'to-string': Coercion,
    'var': Var,
    'within': Within
};
function rgba(ctx, ref) {
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    r = r.evaluate(ctx);
    g = g.evaluate(ctx);
    b = b.evaluate(ctx);
    var alpha = a ? a.evaluate(ctx) : 1;
    var error = validateRGBA(r, g, b, alpha);
    if (error) {
        throw new RuntimeError(error);
    }
    return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
}
function has(key, obj) {
    return key in obj;
}
function get(key, obj) {
    var v = obj[key];
    return typeof v === 'undefined' ? null : v;
}
function binarySearch(v, a, i, j) {
    while (i <= j) {
        var m = i + j >> 1;
        if (a[m] === v) {
            return true;
        }
        if (a[m] > v) {
            j = m - 1;
        } else {
            i = m + 1;
        }
    }
    return false;
}
function varargs(type) {
    return { type: type };
}
CompoundExpression.register(expressions, {
    'error': [
        ErrorType,
        [StringType],
        function (ctx, ref) {
            var v = ref[0];
            throw new RuntimeError(v.evaluate(ctx));
        }
    ],
    'typeof': [
        StringType,
        [ValueType],
        function (ctx, ref) {
            var v = ref[0];
            return toString(typeOf(v.evaluate(ctx)));
        }
    ],
    'to-rgba': [
        array(NumberType, 4),
        [ColorType],
        function (ctx, ref) {
            var v = ref[0];
            return v.evaluate(ctx).toArray();
        }
    ],
    'rgb': [
        ColorType,
        [
            NumberType,
            NumberType,
            NumberType
        ],
        rgba
    ],
    'rgba': [
        ColorType,
        [
            NumberType,
            NumberType,
            NumberType,
            NumberType
        ],
        rgba
    ],
    'has': {
        type: BooleanType,
        overloads: [
            [
                [StringType],
                function (ctx, ref) {
                    var key = ref[0];
                    return has(key.evaluate(ctx), ctx.properties());
                }
            ],
            [
                [
                    StringType,
                    ObjectType
                ],
                function (ctx, ref) {
                    var key = ref[0];
                    var obj = ref[1];
                    return has(key.evaluate(ctx), obj.evaluate(ctx));
                }
            ]
        ]
    },
    'get': {
        type: ValueType,
        overloads: [
            [
                [StringType],
                function (ctx, ref) {
                    var key = ref[0];
                    return get(key.evaluate(ctx), ctx.properties());
                }
            ],
            [
                [
                    StringType,
                    ObjectType
                ],
                function (ctx, ref) {
                    var key = ref[0];
                    var obj = ref[1];
                    return get(key.evaluate(ctx), obj.evaluate(ctx));
                }
            ]
        ]
    },
    'feature-state': [
        ValueType,
        [StringType],
        function (ctx, ref) {
            var key = ref[0];
            return get(key.evaluate(ctx), ctx.featureState || {});
        }
    ],
    'properties': [
        ObjectType,
        [],
        function (ctx) {
            return ctx.properties();
        }
    ],
    'geometry-type': [
        StringType,
        [],
        function (ctx) {
            return ctx.geometryType();
        }
    ],
    'id': [
        ValueType,
        [],
        function (ctx) {
            return ctx.id();
        }
    ],
    'zoom': [
        NumberType,
        [],
        function (ctx) {
            return ctx.globals.zoom;
        }
    ],
    'heatmap-density': [
        NumberType,
        [],
        function (ctx) {
            return ctx.globals.heatmapDensity || 0;
        }
    ],
    'line-progress': [
        NumberType,
        [],
        function (ctx) {
            return ctx.globals.lineProgress || 0;
        }
    ],
    'accumulated': [
        ValueType,
        [],
        function (ctx) {
            return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;
        }
    ],
    '+': [
        NumberType,
        varargs(NumberType),
        function (ctx, args) {
            var result = 0;
            for (var i = 0, list = args; i < list.length; i += 1) {
                var arg = list[i];
                result += arg.evaluate(ctx);
            }
            return result;
        }
    ],
    '*': [
        NumberType,
        varargs(NumberType),
        function (ctx, args) {
            var result = 1;
            for (var i = 0, list = args; i < list.length; i += 1) {
                var arg = list[i];
                result *= arg.evaluate(ctx);
            }
            return result;
        }
    ],
    '-': {
        type: NumberType,
        overloads: [
            [
                [
                    NumberType,
                    NumberType
                ],
                function (ctx, ref) {
                    var a = ref[0];
                    var b = ref[1];
                    return a.evaluate(ctx) - b.evaluate(ctx);
                }
            ],
            [
                [NumberType],
                function (ctx, ref) {
                    var a = ref[0];
                    return -a.evaluate(ctx);
                }
            ]
        ]
    },
    '/': [
        NumberType,
        [
            NumberType,
            NumberType
        ],
        function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) / b.evaluate(ctx);
        }
    ],
    '%': [
        NumberType,
        [
            NumberType,
            NumberType
        ],
        function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) % b.evaluate(ctx);
        }
    ],
    'ln2': [
        NumberType,
        [],
        function () {
            return Math.LN2;
        }
    ],
    'pi': [
        NumberType,
        [],
        function () {
            return Math.PI;
        }
    ],
    'e': [
        NumberType,
        [],
        function () {
            return Math.E;
        }
    ],
    '^': [
        NumberType,
        [
            NumberType,
            NumberType
        ],
        function (ctx, ref) {
            var b = ref[0];
            var e = ref[1];
            return Math.pow(b.evaluate(ctx), e.evaluate(ctx));
        }
    ],
    'sqrt': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var x = ref[0];
            return Math.sqrt(x.evaluate(ctx));
        }
    ],
    'log10': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.log(n.evaluate(ctx)) / Math.LN10;
        }
    ],
    'ln': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.log(n.evaluate(ctx));
        }
    ],
    'log2': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.log(n.evaluate(ctx)) / Math.LN2;
        }
    ],
    'sin': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.sin(n.evaluate(ctx));
        }
    ],
    'cos': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.cos(n.evaluate(ctx));
        }
    ],
    'tan': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.tan(n.evaluate(ctx));
        }
    ],
    'asin': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.asin(n.evaluate(ctx));
        }
    ],
    'acos': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.acos(n.evaluate(ctx));
        }
    ],
    'atan': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.atan(n.evaluate(ctx));
        }
    ],
    'min': [
        NumberType,
        varargs(NumberType),
        function (ctx, args) {
            return Math.min.apply(Math, args.map(function (arg) {
                return arg.evaluate(ctx);
            }));
        }
    ],
    'max': [
        NumberType,
        varargs(NumberType),
        function (ctx, args) {
            return Math.max.apply(Math, args.map(function (arg) {
                return arg.evaluate(ctx);
            }));
        }
    ],
    'abs': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.abs(n.evaluate(ctx));
        }
    ],
    'round': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            var v = n.evaluate(ctx);
            return v < 0 ? -Math.round(-v) : Math.round(v);
        }
    ],
    'floor': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.floor(n.evaluate(ctx));
        }
    ],
    'ceil': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];
            return Math.ceil(n.evaluate(ctx));
        }
    ],
    'filter-==': [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        function (ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            return ctx.properties()[k.value] === v.value;
        }
    ],
    'filter-id-==': [
        BooleanType,
        [ValueType],
        function (ctx, ref) {
            var v = ref[0];
            return ctx.id() === v.value;
        }
    ],
    'filter-type-==': [
        BooleanType,
        [StringType],
        function (ctx, ref) {
            var v = ref[0];
            return ctx.geometryType() === v.value;
        }
    ],
    'filter-<': [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        function (ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            var a = ctx.properties()[k.value];
            var b = v.value;
            return typeof a === typeof b && a < b;
        }
    ],
    'filter-id-<': [
        BooleanType,
        [ValueType],
        function (ctx, ref) {
            var v = ref[0];
            var a = ctx.id();
            var b = v.value;
            return typeof a === typeof b && a < b;
        }
    ],
    'filter->': [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        function (ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            var a = ctx.properties()[k.value];
            var b = v.value;
            return typeof a === typeof b && a > b;
        }
    ],
    'filter-id->': [
        BooleanType,
        [ValueType],
        function (ctx, ref) {
            var v = ref[0];
            var a = ctx.id();
            var b = v.value;
            return typeof a === typeof b && a > b;
        }
    ],
    'filter-<=': [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        function (ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            var a = ctx.properties()[k.value];
            var b = v.value;
            return typeof a === typeof b && a <= b;
        }
    ],
    'filter-id-<=': [
        BooleanType,
        [ValueType],
        function (ctx, ref) {
            var v = ref[0];
            var a = ctx.id();
            var b = v.value;
            return typeof a === typeof b && a <= b;
        }
    ],
    'filter->=': [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        function (ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            var a = ctx.properties()[k.value];
            var b = v.value;
            return typeof a === typeof b && a >= b;
        }
    ],
    'filter-id->=': [
        BooleanType,
        [ValueType],
        function (ctx, ref) {
            var v = ref[0];
            var a = ctx.id();
            var b = v.value;
            return typeof a === typeof b && a >= b;
        }
    ],
    'filter-has': [
        BooleanType,
        [ValueType],
        function (ctx, ref) {
            var k = ref[0];
            return k.value in ctx.properties();
        }
    ],
    'filter-has-id': [
        BooleanType,
        [],
        function (ctx) {
            return ctx.id() !== null && ctx.id() !== undefined;
        }
    ],
    'filter-type-in': [
        BooleanType,
        [array(StringType)],
        function (ctx, ref) {
            var v = ref[0];
            return v.value.indexOf(ctx.geometryType()) >= 0;
        }
    ],
    'filter-id-in': [
        BooleanType,
        [array(ValueType)],
        function (ctx, ref) {
            var v = ref[0];
            return v.value.indexOf(ctx.id()) >= 0;
        }
    ],
    'filter-in-small': [
        BooleanType,
        [
            StringType,
            array(ValueType)
        ],
        function (ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            return v.value.indexOf(ctx.properties()[k.value]) >= 0;
        }
    ],
    'filter-in-large': [
        BooleanType,
        [
            StringType,
            array(ValueType)
        ],
        function (ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);
        }
    ],
    'all': {
        type: BooleanType,
        overloads: [
            [
                [
                    BooleanType,
                    BooleanType
                ],
                function (ctx, ref) {
                    var a = ref[0];
                    var b = ref[1];
                    return a.evaluate(ctx) && b.evaluate(ctx);
                }
            ],
            [
                varargs(BooleanType),
                function (ctx, args) {
                    for (var i = 0, list = args; i < list.length; i += 1) {
                        var arg = list[i];
                        if (!arg.evaluate(ctx)) {
                            return false;
                        }
                    }
                    return true;
                }
            ]
        ]
    },
    'any': {
        type: BooleanType,
        overloads: [
            [
                [
                    BooleanType,
                    BooleanType
                ],
                function (ctx, ref) {
                    var a = ref[0];
                    var b = ref[1];
                    return a.evaluate(ctx) || b.evaluate(ctx);
                }
            ],
            [
                varargs(BooleanType),
                function (ctx, args) {
                    for (var i = 0, list = args; i < list.length; i += 1) {
                        var arg = list[i];
                        if (arg.evaluate(ctx)) {
                            return true;
                        }
                    }
                    return false;
                }
            ]
        ]
    },
    '!': [
        BooleanType,
        [BooleanType],
        function (ctx, ref) {
            var b = ref[0];
            return !b.evaluate(ctx);
        }
    ],
    'is-supported-script': [
        BooleanType,
        [StringType],
        function (ctx, ref) {
            var s = ref[0];
            var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;
            if (isSupportedScript) {
                return isSupportedScript(s.evaluate(ctx));
            }
            return true;
        }
    ],
    'upcase': [
        StringType,
        [StringType],
        function (ctx, ref) {
            var s = ref[0];
            return s.evaluate(ctx).toUpperCase();
        }
    ],
    'downcase': [
        StringType,
        [StringType],
        function (ctx, ref) {
            var s = ref[0];
            return s.evaluate(ctx).toLowerCase();
        }
    ],
    'concat': [
        StringType,
        varargs(ValueType),
        function (ctx, args) {
            return args.map(function (arg) {
                return toString$1(arg.evaluate(ctx));
            }).join('');
        }
    ],
    'resolved-locale': [
        StringType,
        [CollatorType],
        function (ctx, ref) {
            var collator = ref[0];
            return collator.evaluate(ctx).resolvedLocale();
        }
    ]
});

function success(value) {
    return {
        result: 'success',
        value: value
    };
}
function error(value) {
    return {
        result: 'error',
        value: value
    };
}

function supportsPropertyExpression(spec) {
    return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';
}
function supportsZoomExpression(spec) {
    return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;
}
function supportsInterpolation(spec) {
    return !!spec.expression && spec.expression.interpolated;
}

function getType(val) {
    if (val instanceof Number) {
        return 'number';
    } else if (val instanceof String) {
        return 'string';
    } else if (val instanceof Boolean) {
        return 'boolean';
    } else if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val;
    }
}

function isFunction$1(value) {
    return typeof value === 'object' && value !== null && !Array.isArray(value);
}
function identityFunction(x) {
    return x;
}
function createFunction(parameters, propertySpec) {
    var isColor = propertySpec.type === 'color';
    var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    var type = parameters.type || (supportsInterpolation(propertySpec) ? 'exponential' : 'interval');
    if (isColor) {
        parameters = extend({}, parameters);
        if (parameters.stops) {
            parameters.stops = parameters.stops.map(function (stop) {
                return [
                    stop[0],
                    Color.parse(stop[1])
                ];
            });
        }
        if (parameters.default) {
            parameters.default = Color.parse(parameters.default);
        } else {
            parameters.default = Color.parse(propertySpec.default);
        }
    }
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb' && !colorSpaces[parameters.colorSpace]) {
        throw new Error('Unknown color space: ' + parameters.colorSpace);
    }
    var innerFun;
    var hashedStops;
    var categoricalKeyType;
    if (type === 'exponential') {
        innerFun = evaluateExponentialFunction;
    } else if (type === 'interval') {
        innerFun = evaluateIntervalFunction;
    } else if (type === 'categorical') {
        innerFun = evaluateCategoricalFunction;
        hashedStops = Object.create(null);
        for (var i = 0, list = parameters.stops; i < list.length; i += 1) {
            var stop = list[i];
            hashedStops[stop[0]] = stop[1];
        }
        categoricalKeyType = typeof parameters.stops[0][0];
    } else if (type === 'identity') {
        innerFun = evaluateIdentityFunction;
    } else {
        throw new Error('Unknown function type "' + type + '"');
    }
    if (zoomAndFeatureDependent) {
        var featureFunctions = {};
        var zoomStops = [];
        for (var s = 0; s < parameters.stops.length; s++) {
            var stop$1 = parameters.stops[s];
            var zoom = stop$1[0].zoom;
            if (featureFunctions[zoom] === undefined) {
                featureFunctions[zoom] = {
                    zoom: zoom,
                    type: parameters.type,
                    property: parameters.property,
                    default: parameters.default,
                    stops: []
                };
                zoomStops.push(zoom);
            }
            featureFunctions[zoom].stops.push([
                stop$1[0].value,
                stop$1[1]
            ]);
        }
        var featureFunctionStops = [];
        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {
            var z = list$1[i$1];
            featureFunctionStops.push([
                featureFunctions[z].zoom,
                createFunction(featureFunctions[z], propertySpec)
            ]);
        }
        var interpolationType = { name: 'linear' };
        return {
            kind: 'composite',
            interpolationType: interpolationType,
            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),
            zoomStops: featureFunctionStops.map(function (s) {
                return s[0];
            }),
            evaluate: function evaluate(ref, properties) {
                var zoom = ref.zoom;
                return evaluateExponentialFunction({
                    stops: featureFunctionStops,
                    base: parameters.base
                }, propertySpec, zoom).evaluate(zoom, properties);
            }
        };
    } else if (zoomDependent) {
        var interpolationType$1 = type === 'exponential' ? {
            name: 'exponential',
            base: parameters.base !== undefined ? parameters.base : 1
        } : null;
        return {
            kind: 'camera',
            interpolationType: interpolationType$1,
            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType$1),
            zoomStops: parameters.stops.map(function (s) {
                return s[0];
            }),
            evaluate: function (ref) {
                var zoom = ref.zoom;
                return innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType);
            }
        };
    } else {
        return {
            kind: 'source',
            evaluate: function evaluate(_, feature) {
                var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;
                if (value === undefined) {
                    return coalesce(parameters.default, propertySpec.default);
                }
                return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);
            }
        };
    }
}
function coalesce(a, b, c) {
    if (a !== undefined) {
        return a;
    }
    if (b !== undefined) {
        return b;
    }
    if (c !== undefined) {
        return c;
    }
}
function evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {
    var evaluated = typeof input === keyType ? hashedStops[input] : undefined;
    return coalesce(evaluated, parameters.default, propertySpec.default);
}
function evaluateIntervalFunction(parameters, propertySpec, input) {
    if (getType(input) !== 'number') {
        return coalesce(parameters.default, propertySpec.default);
    }
    var n = parameters.stops.length;
    if (n === 1) {
        return parameters.stops[0][1];
    }
    if (input <= parameters.stops[0][0]) {
        return parameters.stops[0][1];
    }
    if (input >= parameters.stops[n - 1][0]) {
        return parameters.stops[n - 1][1];
    }
    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
        return stop[0];
    }), input);
    return parameters.stops[index][1];
}
function evaluateExponentialFunction(parameters, propertySpec, input) {
    var base = parameters.base !== undefined ? parameters.base : 1;
    if (getType(input) !== 'number') {
        return coalesce(parameters.default, propertySpec.default);
    }
    var n = parameters.stops.length;
    if (n === 1) {
        return parameters.stops[0][1];
    }
    if (input <= parameters.stops[0][0]) {
        return parameters.stops[0][1];
    }
    if (input >= parameters.stops[n - 1][0]) {
        return parameters.stops[n - 1][1];
    }
    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
        return stop[0];
    }), input);
    var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);
    var outputLower = parameters.stops[index][1];
    var outputUpper = parameters.stops[index + 1][1];
    var interp = interpolate[propertySpec.type] || identityFunction;
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {
        var colorspace = colorSpaces[parameters.colorSpace];
        interp = function (a, b) {
            return colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));
        };
    }
    if (typeof outputLower.evaluate === 'function') {
        return {
            evaluate: function evaluate() {
                var args = [], len = arguments.length;
                while (len--)
                    args[len] = arguments[len];
                var evaluatedLower = outputLower.evaluate.apply(undefined, args);
                var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);
                if (evaluatedLower === undefined || evaluatedUpper === undefined) {
                    return undefined;
                }
                return interp(evaluatedLower, evaluatedUpper, t);
            }
        };
    }
    return interp(outputLower, outputUpper, t);
}
function evaluateIdentityFunction(parameters, propertySpec, input) {
    if (propertySpec.type === 'color') {
        input = Color.parse(input);
    } else if (propertySpec.type === 'formatted') {
        input = Formatted.fromString(input.toString());
    } else if (propertySpec.type === 'resolvedImage') {
        input = ResolvedImage.fromString(input.toString());
    } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {
        input = undefined;
    }
    return coalesce(input, parameters.default, propertySpec.default);
}
function interpolationFactor(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

var StyleExpression = function StyleExpression(expression, propertySpec) {
    this.expression = expression;
    this._warningHistory = {};
    this._evaluator = new EvaluationContext();
    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;
    this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;
};
StyleExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature;
    this._evaluator.featureState = featureState;
    this._evaluator.canonical = canonical;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection;
    return this.expression.evaluate(this._evaluator);
};
StyleExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature || null;
    this._evaluator.featureState = featureState || null;
    this._evaluator.canonical = canonical;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection || null;
    try {
        var val = this.expression.evaluate(this._evaluator);
        if (val === null || val === undefined || typeof val === 'number' && val !== val) {
            return this._defaultValue;
        }
        if (this._enumValues && !(val in this._enumValues)) {
            throw new RuntimeError('Expected value to be one of ' + Object.keys(this._enumValues).map(function (v) {
                return JSON.stringify(v);
            }).join(', ') + ', but found ' + JSON.stringify(val) + ' instead.');
        }
        return val;
    } catch (e) {
        if (!this._warningHistory[e.message]) {
            this._warningHistory[e.message] = true;
            if (typeof console !== 'undefined') {
                console.warn(e.message);
            }
        }
        return this._defaultValue;
    }
};
function isExpression(expression) {
    return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in expressions;
}
function createExpression(expression, propertySpec) {
    var parser = new ParsingContext(expressions, [], propertySpec ? getExpectedType(propertySpec) : undefined);
    var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? { typeAnnotation: 'coerce' } : undefined);
    if (!parsed) {
        return error(parser.errors);
    }
    return success(new StyleExpression(parsed, propertySpec));
}
var ZoomConstantExpression = function ZoomConstantExpression(kind, expression) {
    this.kind = kind;
    this._styleExpression = expression;
    this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);
};
ZoomConstantExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomConstantExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
};
var ZoomDependentExpression = function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {
    this.kind = kind;
    this.zoomStops = zoomStops;
    this._styleExpression = expression;
    this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);
    this.interpolationType = interpolationType;
};
ZoomDependentExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomDependentExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomDependentExpression.prototype.interpolationFactor = function interpolationFactor(input, lower, upper) {
    if (this.interpolationType) {
        return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);
    } else {
        return 0;
    }
};
function createPropertyExpression(expression, propertySpec) {
    expression = createExpression(expression, propertySpec);
    if (expression.result === 'error') {
        return expression;
    }
    var parsed = expression.value.expression;
    var isFeatureConstant$1 = isFeatureConstant(parsed);
    if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {
        return error([new ParsingError('', 'data expressions not supported')]);
    }
    var isZoomConstant = isGlobalPropertyConstant(parsed, ['zoom']);
    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
        return error([new ParsingError('', 'zoom expressions not supported')]);
    }
    var zoomCurve = findZoomCurve(parsed);
    if (!zoomCurve && !isZoomConstant) {
        return error([new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
    } else if (zoomCurve instanceof ParsingError) {
        return error([zoomCurve]);
    } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {
        return error([new ParsingError('', '"interpolate" expressions cannot be used with this property')]);
    }
    if (!zoomCurve) {
        return success(isFeatureConstant$1 ? new ZoomConstantExpression('constant', expression.value) : new ZoomConstantExpression('source', expression.value));
    }
    var interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;
    return success(isFeatureConstant$1 ? new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));
}
var StylePropertyFunction = function StylePropertyFunction(parameters, specification) {
    this._parameters = parameters;
    this._specification = specification;
    extend(this, createFunction(this._parameters, this._specification));
};
StylePropertyFunction.deserialize = function deserialize(serialized) {
    return new StylePropertyFunction(serialized._parameters, serialized._specification);
};
StylePropertyFunction.serialize = function serialize(input) {
    return {
        _parameters: input._parameters,
        _specification: input._specification
    };
};
function normalizePropertyExpression(value, specification) {
    if (isFunction$1(value)) {
        return new StylePropertyFunction(value, specification);
    } else if (isExpression(value)) {
        var expression = createPropertyExpression(value, specification);
        if (expression.result === 'error') {
            throw new Error(expression.value.map(function (err) {
                return err.key + ': ' + err.message;
            }).join(', '));
        }
        return expression.value;
    } else {
        var constant = value;
        if (typeof value === 'string' && specification.type === 'color') {
            constant = Color.parse(value);
        }
        return {
            kind: 'constant',
            evaluate: function () {
                return constant;
            }
        };
    }
}
function findZoomCurve(expression) {
    var result = null;
    if (expression instanceof Let) {
        result = findZoomCurve(expression.result);
    } else if (expression instanceof Coalesce) {
        for (var i = 0, list = expression.args; i < list.length; i += 1) {
            var arg = list[i];
            result = findZoomCurve(arg);
            if (result) {
                break;
            }
        }
    } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === 'zoom') {
        result = expression;
    }
    if (result instanceof ParsingError) {
        return result;
    }
    expression.eachChild(function (child) {
        var childResult = findZoomCurve(child);
        if (childResult instanceof ParsingError) {
            result = childResult;
        } else if (!result && childResult) {
            result = new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
        } else if (result && childResult && result !== childResult) {
            result = new ParsingError('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
        }
    });
    return result;
}
function getExpectedType(spec) {
    var types = {
        color: ColorType,
        string: StringType,
        number: NumberType,
        enum: StringType,
        boolean: BooleanType,
        formatted: FormattedType,
        resolvedImage: ResolvedImageType
    };
    if (spec.type === 'array') {
        return array(types[spec.value] || ValueType, spec.length);
    }
    return types[spec.type];
}
function getDefaultValue(spec) {
    if (spec.type === 'color' && isFunction$1(spec.default)) {
        return new Color(0, 0, 0, 0);
    } else if (spec.type === 'color') {
        return Color.parse(spec.default) || null;
    } else if (spec.default === undefined) {
        return null;
    } else {
        return spec.default;
    }
}

function isExpressionFilter(filter) {
    if (filter === true || filter === false) {
        return true;
    }
    if (!Array.isArray(filter) || filter.length === 0) {
        return false;
    }
    switch (filter[0]) {
    case 'has':
        return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';
    case 'in':
        return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));
    case '!in':
    case '!has':
    case 'none':
        return false;
    case '==':
    case '!=':
    case '>':
    case '>=':
    case '<':
    case '<=':
        return filter.length !== 3 || (Array.isArray(filter[1]) || Array.isArray(filter[2]));
    case 'any':
    case 'all':
        for (var i = 0, list = filter.slice(1); i < list.length; i += 1) {
            var f = list[i];
            if (!isExpressionFilter(f) && typeof f !== 'boolean') {
                return false;
            }
        }
        return true;
    default:
        return true;
    }
}

var ValidationError = function ValidationError(key, value, message, identifier) {
    this.message = (key ? key + ': ' : '') + message;
    if (identifier) {
        this.identifier = identifier;
    }
    if (value !== null && value !== undefined && value.__line__) {
        this.line = value.__line__;
    }
};

var ParsingError$1 = function ParsingError(error) {
    this.error = error;
    this.message = error.message;
    var match = error.message.match(/line (\d+)/);
    this.line = match ? parseInt(match[1], 10) : 0;
};

function validateConstants(options) {
    var key = options.key;
    var constants = options.value;
    if (constants) {
        return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
    } else {
        return [];
    }
}

function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
        return value.valueOf();
    } else {
        return value;
    }
}
function deepUnbundle(value) {
    if (Array.isArray(value)) {
        return value.map(deepUnbundle);
    } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {
        var unbundledValue = {};
        for (var key in value) {
            unbundledValue[key] = deepUnbundle(value[key]);
        }
        return unbundledValue;
    }
    return unbundle(value);
}

function validateObject(options) {
    var key = options.key;
    var object = options.value;
    var elementSpecs = options.valueSpec || {};
    var elementValidators = options.objectElementValidators || {};
    var style = options.style;
    var styleSpec = options.styleSpec;
    var errors = [];
    var type = getType(object);
    if (type !== 'object') {
        return [new ValidationError(key, object, 'object expected, ' + type + ' found')];
    }
    for (var objectKey in object) {
        var elementSpecKey = objectKey.split('.')[0];
        var elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];
        var validateElement = void 0;
        if (elementValidators[elementSpecKey]) {
            validateElement = elementValidators[elementSpecKey];
        } else if (elementSpecs[elementSpecKey]) {
            validateElement = validate;
        } else if (elementValidators['*']) {
            validateElement = elementValidators['*'];
        } else if (elementSpecs['*']) {
            validateElement = validate;
        } else {
            errors.push(new ValidationError(key, object[objectKey], 'unknown property "' + objectKey + '"'));
            continue;
        }
        errors = errors.concat(validateElement({
            key: (key ? key + '.' : key) + objectKey,
            value: object[objectKey],
            valueSpec: elementSpec,
            style: style,
            styleSpec: styleSpec,
            object: object,
            objectKey: objectKey
        }, object));
    }
    for (var elementSpecKey$1 in elementSpecs) {
        if (elementValidators[elementSpecKey$1]) {
            continue;
        }
        if (elementSpecs[elementSpecKey$1].required && elementSpecs[elementSpecKey$1]['default'] === undefined && object[elementSpecKey$1] === undefined) {
            errors.push(new ValidationError(key, object, 'missing required property "' + elementSpecKey$1 + '"'));
        }
    }
    return errors;
}

function validateArray(options) {
    var array = options.value;
    var arraySpec = options.valueSpec;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var key = options.key;
    var validateArrayElement = options.arrayElementValidator || validate;
    if (getType(array) !== 'array') {
        return [new ValidationError(key, array, 'array expected, ' + getType(array) + ' found')];
    }
    if (arraySpec.length && array.length !== arraySpec.length) {
        return [new ValidationError(key, array, 'array length ' + arraySpec.length + ' expected, length ' + array.length + ' found')];
    }
    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
        return [new ValidationError(key, array, 'array length at least ' + arraySpec['min-length'] + ' expected, length ' + array.length + ' found')];
    }
    var arrayElementSpec = {
        'type': arraySpec.value,
        'values': arraySpec.values
    };
    if (styleSpec.$version < 7) {
        arrayElementSpec.function = arraySpec.function;
    }
    if (getType(arraySpec.value) === 'object') {
        arrayElementSpec = arraySpec.value;
    }
    var errors = [];
    for (var i = 0; i < array.length; i++) {
        errors = errors.concat(validateArrayElement({
            array: array,
            arrayIndex: i,
            value: array[i],
            valueSpec: arrayElementSpec,
            style: style,
            styleSpec: styleSpec,
            key: key + '[' + i + ']'
        }));
    }
    return errors;
}

function validateNumber(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var type = getType(value);
    if (type === 'number' && value !== value) {
        type = 'NaN';
    }
    if (type !== 'number') {
        return [new ValidationError(key, value, 'number expected, ' + type + ' found')];
    }
    if ('minimum' in valueSpec && value < valueSpec.minimum) {
        return [new ValidationError(key, value, value + ' is less than the minimum value ' + valueSpec.minimum)];
    }
    if ('maximum' in valueSpec && value > valueSpec.maximum) {
        return [new ValidationError(key, value, value + ' is greater than the maximum value ' + valueSpec.maximum)];
    }
    return [];
}

function validateFunction(options) {
    var functionValueSpec = options.valueSpec;
    var functionType = unbundle(options.value.type);
    var stopKeyType;
    var stopDomainValues = {};
    var previousStopDomainValue;
    var previousStopDomainZoom;
    var isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;
    var isPropertyFunction = !isZoomFunction;
    var isZoomAndPropertyFunction = getType(options.value.stops) === 'array' && getType(options.value.stops[0]) === 'array' && getType(options.value.stops[0][0]) === 'object';
    var errors = validateObject({
        key: options.key,
        value: options.value,
        valueSpec: options.styleSpec.function,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            stops: validateFunctionStops,
            default: validateFunctionDefault
        }
    });
    if (functionType === 'identity' && isZoomFunction) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "property"'));
    }
    if (functionType !== 'identity' && !options.value.stops) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "stops"'));
    }
    if (functionType === 'exponential' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {
        errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));
    }
    if (options.styleSpec.$version >= 8) {
        if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {
            errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));
        } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {
            errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));
        }
    }
    if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {
        errors.push(new ValidationError(options.key, options.value, '"property" property is required'));
    }
    return errors;
    function validateFunctionStops(options) {
        if (functionType === 'identity') {
            return [new ValidationError(options.key, options.value, 'identity function may not have a "stops" property')];
        }
        var errors = [];
        var value = options.value;
        errors = errors.concat(validateArray({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec,
            style: options.style,
            styleSpec: options.styleSpec,
            arrayElementValidator: validateFunctionStop
        }));
        if (getType(value) === 'array' && value.length === 0) {
            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
        }
        return errors;
    }
    function validateFunctionStop(options) {
        var errors = [];
        var value = options.value;
        var key = options.key;
        if (getType(value) !== 'array') {
            return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];
        }
        if (value.length !== 2) {
            return [new ValidationError(key, value, 'array length 2 expected, length ' + value.length + ' found')];
        }
        if (isZoomAndPropertyFunction) {
            if (getType(value[0]) !== 'object') {
                return [new ValidationError(key, value, 'object expected, ' + getType(value[0]) + ' found')];
            }
            if (value[0].zoom === undefined) {
                return [new ValidationError(key, value, 'object stop key must have zoom')];
            }
            if (value[0].value === undefined) {
                return [new ValidationError(key, value, 'object stop key must have value')];
            }
            if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {
                return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];
            }
            if (unbundle(value[0].zoom) !== previousStopDomainZoom) {
                previousStopDomainZoom = unbundle(value[0].zoom);
                previousStopDomainValue = undefined;
                stopDomainValues = {};
            }
            errors = errors.concat(validateObject({
                key: key + '[0]',
                value: value[0],
                valueSpec: { zoom: {} },
                style: options.style,
                styleSpec: options.styleSpec,
                objectElementValidators: {
                    zoom: validateNumber,
                    value: validateStopDomainValue
                }
            }));
        } else {
            errors = errors.concat(validateStopDomainValue({
                key: key + '[0]',
                value: value[0],
                valueSpec: {},
                style: options.style,
                styleSpec: options.styleSpec
            }, value));
        }
        if (isExpression(deepUnbundle(value[1]))) {
            return errors.concat([new ValidationError(key + '[1]', value[1], 'expressions are not allowed in function stops.')]);
        }
        return errors.concat(validate({
            key: key + '[1]',
            value: value[1],
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        }));
    }
    function validateStopDomainValue(options, stop) {
        var type = getType(options.value);
        var value = unbundle(options.value);
        var reportValue = options.value !== null ? options.value : stop;
        if (!stopKeyType) {
            stopKeyType = type;
        } else if (type !== stopKeyType) {
            return [new ValidationError(options.key, reportValue, type + ' stop domain type must match previous stop domain type ' + stopKeyType)];
        }
        if (type !== 'number' && type !== 'string' && type !== 'boolean') {
            return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];
        }
        if (type !== 'number' && functionType !== 'categorical') {
            var message = 'number expected, ' + type + ' found';
            if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {
                message += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.';
            }
            return [new ValidationError(options.key, reportValue, message)];
        }
        if (functionType === 'categorical' && type === 'number' && (!isFinite(value) || Math.floor(value) !== value)) {
            return [new ValidationError(options.key, reportValue, 'integer expected, found ' + value)];
        }
        if (functionType !== 'categorical' && type === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];
        } else {
            previousStopDomainValue = value;
        }
        if (functionType === 'categorical' && value in stopDomainValues) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];
        } else {
            stopDomainValues[value] = true;
        }
        return [];
    }
    function validateFunctionDefault(options) {
        return validate({
            key: options.key,
            value: options.value,
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        });
    }
}

function validateExpression(options) {
    var expression = (options.expressionContext === 'property' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);
    if (expression.result === 'error') {
        return expression.value.map(function (error) {
            return new ValidationError('' + options.key + error.key, options.value, error.message);
        });
    }
    var expressionObj = expression.value.expression || expression.value._styleExpression.expression;
    if (options.expressionContext === 'property' && options.propertyKey === 'text-font' && !expressionObj.outputDefined()) {
        return [new ValidationError(options.key, options.value, 'Invalid data expression for "' + options.propertyKey + '". Output values must be contained as literals within the expression.')];
    }
    if (options.expressionContext === 'property' && options.propertyType === 'layout' && !isStateConstant(expressionObj)) {
        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with layout properties.')];
    }
    if (options.expressionContext === 'filter' && !isStateConstant(expressionObj)) {
        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with filters.')];
    }
    if (options.expressionContext && options.expressionContext.indexOf('cluster') === 0) {
        if (!isGlobalPropertyConstant(expressionObj, [
                'zoom',
                'feature-state'
            ])) {
            return [new ValidationError(options.key, options.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
        }
        if (options.expressionContext === 'cluster-initial' && !isFeatureConstant(expressionObj)) {
            return [new ValidationError(options.key, options.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];
        }
    }
    return [];
}

function validateBoolean(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);
    if (type !== 'boolean') {
        return [new ValidationError(key, value, 'boolean expected, ' + type + ' found')];
    }
    return [];
}

function validateColor(options) {
    var key = options.key;
    var value = options.value;
    var type = getType(value);
    if (type !== 'string') {
        return [new ValidationError(key, value, 'color expected, ' + type + ' found')];
    }
    if (csscolorparser_1(value) === null) {
        return [new ValidationError(key, value, 'color expected, "' + value + '" found')];
    }
    return [];
}

function validateEnum(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var errors = [];
    if (Array.isArray(valueSpec.values)) {
        if (valueSpec.values.indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, 'expected one of [' + valueSpec.values.join(', ') + '], ' + JSON.stringify(value) + ' found'));
        }
    } else {
        if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, 'expected one of [' + Object.keys(valueSpec.values).join(', ') + '], ' + JSON.stringify(value) + ' found'));
        }
    }
    return errors;
}

function validateFilter(options) {
    if (isExpressionFilter(deepUnbundle(options.value))) {
        return validateExpression(extend({}, options, {
            expressionContext: 'filter',
            valueSpec: { value: 'boolean' }
        }));
    } else {
        return validateNonExpressionFilter(options);
    }
}
function validateNonExpressionFilter(options) {
    var value = options.value;
    var key = options.key;
    if (getType(value) !== 'array') {
        return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];
    }
    var styleSpec = options.styleSpec;
    var type;
    var errors = [];
    if (value.length < 1) {
        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
    }
    errors = errors.concat(validateEnum({
        key: key + '[0]',
        value: value[0],
        valueSpec: styleSpec.filter_operator,
        style: options.style,
        styleSpec: options.styleSpec
    }));
    switch (unbundle(value[0])) {
    case '<':
    case '<=':
    case '>':
    case '>=':
        if (value.length >= 2 && unbundle(value[1]) === '$type') {
            errors.push(new ValidationError(key, value, '"$type" cannot be use with operator "' + value[0] + '"'));
        }
    case '==':
    case '!=':
        if (value.length !== 3) {
            errors.push(new ValidationError(key, value, 'filter array for operator "' + value[0] + '" must have 3 elements'));
        }
    case 'in':
    case '!in':
        if (value.length >= 2) {
            type = getType(value[1]);
            if (type !== 'string') {
                errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));
            }
        }
        for (var i = 2; i < value.length; i++) {
            type = getType(value[i]);
            if (unbundle(value[1]) === '$type') {
                errors = errors.concat(validateEnum({
                    key: key + '[' + i + ']',
                    value: value[i],
                    valueSpec: styleSpec.geometry_type,
                    style: options.style,
                    styleSpec: options.styleSpec
                }));
            } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                errors.push(new ValidationError(key + '[' + i + ']', value[i], 'string, number, or boolean expected, ' + type + ' found'));
            }
        }
        break;
    case 'any':
    case 'all':
    case 'none':
        for (var i$1 = 1; i$1 < value.length; i$1++) {
            errors = errors.concat(validateNonExpressionFilter({
                key: key + '[' + i$1 + ']',
                value: value[i$1],
                style: options.style,
                styleSpec: options.styleSpec
            }));
        }
        break;
    case 'has':
    case '!has':
        type = getType(value[1]);
        if (value.length !== 2) {
            errors.push(new ValidationError(key, value, 'filter array for "' + value[0] + '" operator must have 2 elements'));
        } else if (type !== 'string') {
            errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));
        }
        break;
    case 'within':
        type = getType(value[1]);
        if (value.length !== 2) {
            errors.push(new ValidationError(key, value, 'filter array for "' + value[0] + '" operator must have 2 elements'));
        } else if (type !== 'object') {
            errors.push(new ValidationError(key + '[1]', value[1], 'object expected, ' + type + ' found'));
        }
        break;
    }
    return errors;
}

function validateProperty(options, propertyType) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec[propertyType + '_' + options.layerType];
    if (!layerSpec) {
        return [];
    }
    var transitionMatch = propertyKey.match(/^(.*)-transition$/);
    if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
        return validate({
            key: key,
            value: value,
            valueSpec: styleSpec.transition,
            style: style,
            styleSpec: styleSpec
        });
    }
    var valueSpec = options.valueSpec || layerSpec[propertyKey];
    if (!valueSpec) {
        return [new ValidationError(key, value, 'unknown property "' + propertyKey + '"')];
    }
    var tokenMatch;
    if (getType(value) === 'string' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {
        return [new ValidationError(key, value, '"' + propertyKey + '" does not support interpolation syntax\n' + 'Use an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(tokenMatch[1]) + ' }`.')];
    }
    var errors = [];
    if (options.layerType === 'symbol') {
        if (propertyKey === 'text-field' && style && !style.glyphs) {
            errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
        }
        if (propertyKey === 'text-font' && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === 'identity') {
            errors.push(new ValidationError(key, value, '"text-font" does not support identity functions'));
        }
    }
    return errors.concat(validate({
        key: options.key,
        value: value,
        valueSpec: valueSpec,
        style: style,
        styleSpec: styleSpec,
        expressionContext: 'property',
        propertyType: propertyType,
        propertyKey: propertyKey
    }));
}

function validatePaintProperty(options) {
    return validateProperty(options, 'paint');
}

function validateLayoutProperty(options) {
    return validateProperty(options, 'layout');
}

function validateLayer(options) {
    var errors = [];
    var layer = options.value;
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    if (!layer.type && !layer.ref) {
        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
    }
    var type = unbundle(layer.type);
    var ref = unbundle(layer.ref);
    if (layer.id) {
        var layerId = unbundle(layer.id);
        for (var i = 0; i < options.arrayIndex; i++) {
            var otherLayer = style.layers[i];
            if (unbundle(otherLayer.id) === layerId) {
                errors.push(new ValidationError(key, layer.id, 'duplicate layer id "' + layer.id + '", previously used at line ' + otherLayer.id.__line__));
            }
        }
    }
    if ('ref' in layer) {
        [
            'type',
            'source',
            'source-layer',
            'filter',
            'layout'
        ].forEach(function (p) {
            if (p in layer) {
                errors.push(new ValidationError(key, layer[p], '"' + p + '" is prohibited for ref layers'));
            }
        });
        var parent;
        style.layers.forEach(function (layer) {
            if (unbundle(layer.id) === ref) {
                parent = layer;
            }
        });
        if (!parent) {
            errors.push(new ValidationError(key, layer.ref, 'ref layer "' + ref + '" not found'));
        } else if (parent.ref) {
            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
        } else {
            type = unbundle(parent.type);
        }
    } else if (type !== 'background') {
        if (!layer.source) {
            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
        } else {
            var source = style.sources && style.sources[layer.source];
            var sourceType = source && unbundle(source.type);
            if (!source) {
                errors.push(new ValidationError(key, layer.source, 'source "' + layer.source + '" not found'));
            } else if (sourceType === 'vector' && type === 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "' + layer.id + '" requires a raster source'));
            } else if (sourceType === 'raster' && type !== 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "' + layer.id + '" requires a vector source'));
            } else if (sourceType === 'vector' && !layer['source-layer']) {
                errors.push(new ValidationError(key, layer, 'layer "' + layer.id + '" must specify a "source-layer"'));
            } else if (sourceType === 'raster-dem' && type !== 'hillshade') {
                errors.push(new ValidationError(key, layer.source, 'raster-dem source can only be used with layer type \'hillshade\'.'));
            } else if (type === 'line' && layer.paint && layer.paint['line-gradient'] && (sourceType !== 'geojson' || !source.lineMetrics)) {
                errors.push(new ValidationError(key, layer, 'layer "' + layer.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'));
            }
        }
    }
    errors = errors.concat(validateObject({
        key: key,
        value: layer,
        valueSpec: styleSpec.layer,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            '*': function _() {
                return [];
            },
            type: function type() {
                return validate({
                    key: key + '.type',
                    value: layer.type,
                    valueSpec: styleSpec.layer.type,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    object: layer,
                    objectKey: 'type'
                });
            },
            filter: validateFilter,
            layout: function layout(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function _(options) {
                            return validateLayoutProperty(extend({ layerType: type }, options));
                        }
                    }
                });
            },
            paint: function paint(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function _(options) {
                            return validatePaintProperty(extend({ layerType: type }, options));
                        }
                    }
                });
            }
        }
    }));
    return errors;
}

function validateString(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);
    if (type !== 'string') {
        return [new ValidationError(key, value, 'string expected, ' + type + ' found')];
    }
    return [];
}

var objectElementValidators = { promoteId: validatePromoteId };
function validateSource(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;
    if (!value.type) {
        return [new ValidationError(key, value, '"type" is required')];
    }
    var type = unbundle(value.type);
    var errors;
    switch (type) {
    case 'vector':
    case 'raster':
    case 'raster-dem':
        errors = validateObject({
            key: key,
            value: value,
            valueSpec: styleSpec['source_' + type.replace('-', '_')],
            style: options.style,
            styleSpec: styleSpec,
            objectElementValidators: objectElementValidators
        });
        return errors;
    case 'geojson':
        errors = validateObject({
            key: key,
            value: value,
            valueSpec: styleSpec.source_geojson,
            style: style,
            styleSpec: styleSpec,
            objectElementValidators: objectElementValidators
        });
        if (value.cluster) {
            for (var prop in value.clusterProperties) {
                var ref = value.clusterProperties[prop];
                var operator = ref[0];
                var mapExpr = ref[1];
                var reduceExpr = typeof operator === 'string' ? [
                    operator,
                    ['accumulated'],
                    [
                        'get',
                        prop
                    ]
                ] : operator;
                errors.push.apply(errors, validateExpression({
                    key: key + '.' + prop + '.map',
                    value: mapExpr,
                    expressionContext: 'cluster-map'
                }));
                errors.push.apply(errors, validateExpression({
                    key: key + '.' + prop + '.reduce',
                    value: reduceExpr,
                    expressionContext: 'cluster-reduce'
                }));
            }
        }
        return errors;
    case 'video':
        return validateObject({
            key: key,
            value: value,
            valueSpec: styleSpec.source_video,
            style: style,
            styleSpec: styleSpec
        });
    case 'image':
        return validateObject({
            key: key,
            value: value,
            valueSpec: styleSpec.source_image,
            style: style,
            styleSpec: styleSpec
        });
    case 'canvas':
        return [new ValidationError(key, null, 'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.', 'source.canvas')];
    default:
        return validateEnum({
            key: key + '.type',
            value: value.type,
            valueSpec: {
                values: [
                    'vector',
                    'raster',
                    'raster-dem',
                    'geojson',
                    'video',
                    'image'
                ]
            },
            style: style,
            styleSpec: styleSpec
        });
    }
}
function validatePromoteId(ref) {
    var key = ref.key;
    var value = ref.value;
    if (getType(value) === 'string') {
        return validateString({
            key: key,
            value: value
        });
    } else {
        var errors = [];
        for (var prop in value) {
            errors.push.apply(errors, validateString({
                key: key + '.' + prop,
                value: value[prop]
            }));
        }
        return errors;
    }
}

function validateLight(options) {
    var light = options.value;
    var styleSpec = options.styleSpec;
    var lightSpec = styleSpec.light;
    var style = options.style;
    var errors = [];
    var rootType = getType(light);
    if (light === undefined) {
        return errors;
    } else if (rootType !== 'object') {
        errors = errors.concat([new ValidationError('light', light, 'object expected, ' + rootType + ' found')]);
        return errors;
    }
    for (var key in light) {
        var transitionMatch = key.match(/^(.*)-transition$/);
        if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: styleSpec.transition,
                style: style,
                styleSpec: styleSpec
            }));
        } else if (lightSpec[key]) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: lightSpec[key],
                style: style,
                styleSpec: styleSpec
            }));
        } else {
            errors = errors.concat([new ValidationError(key, light[key], 'unknown property "' + key + '"')]);
        }
    }
    return errors;
}

function validateFormatted(options) {
    if (validateString(options).length === 0) {
        return [];
    }
    return validateExpression(options);
}

function validateImage(options) {
    if (validateString(options).length === 0) {
        return [];
    }
    return validateExpression(options);
}

var VALIDATORS = {
    '*': function _() {
        return [];
    },
    'array': validateArray,
    'boolean': validateBoolean,
    'number': validateNumber,
    'color': validateColor,
    'constants': validateConstants,
    'enum': validateEnum,
    'filter': validateFilter,
    'function': validateFunction,
    'layer': validateLayer,
    'object': validateObject,
    'source': validateSource,
    'light': validateLight,
    'string': validateString,
    'formatted': validateFormatted,
    'resolvedImage': validateImage
};
function validate(options) {
    var value = options.value;
    var valueSpec = options.valueSpec;
    var styleSpec = options.styleSpec;
    if (valueSpec.expression && isFunction$1(unbundle(value))) {
        return validateFunction(options);
    } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {
        return validateExpression(options);
    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
        return VALIDATORS[valueSpec.type](options);
    } else {
        var valid = validateObject(extend({}, options, { valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec }));
        return valid;
    }
}

function validateGlyphsURL (options) {
    var value = options.value;
    var key = options.key;
    var errors = validateString(options);
    if (errors.length) {
        return errors;
    }
    if (value.indexOf('{fontstack}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
    }
    if (value.indexOf('{range}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
    }
    return errors;
}

function validateStyleMin(style, styleSpec) {
    if (styleSpec === void 0)
        styleSpec = v8;
    var errors = [];
    errors = errors.concat(validate({
        key: '',
        value: style,
        valueSpec: styleSpec.$root,
        styleSpec: styleSpec,
        style: style,
        objectElementValidators: {
            glyphs: validateGlyphsURL,
            '*': function _() {
                return [];
            }
        }
    }));
    if (style.constants) {
        errors = errors.concat(validateConstants({
            key: 'constants',
            value: style.constants,
            style: style,
            styleSpec: styleSpec
        }));
    }
    return sortErrors(errors);
}
validateStyleMin.source = wrapCleanErrors(validateSource);
validateStyleMin.light = wrapCleanErrors(validateLight);
validateStyleMin.layer = wrapCleanErrors(validateLayer);
validateStyleMin.filter = wrapCleanErrors(validateFilter);
validateStyleMin.paintProperty = wrapCleanErrors(validatePaintProperty);
validateStyleMin.layoutProperty = wrapCleanErrors(validateLayoutProperty);
function sortErrors(errors) {
    return [].concat(errors).sort(function (a, b) {
        return a.line - b.line;
    });
}
function wrapCleanErrors(inner) {
    return function () {
        var args = [], len = arguments.length;
        while (len--)
            args[len] = arguments[len];
        return sortErrors(inner.apply(this, args));
    };
}

var jsonlint = createCommonjsModule(function (module, exports) {
/* parser generated by jison 0.4.15 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v){ }return o},$V0=[1,12],$V1=[1,13],$V2=[1,9],$V3=[1,10],$V4=[1,11],$V5=[1,14],$V6=[1,15],$V7=[14,18,22,24],$V8=[18,22],$V9=[22,24];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"JSONString":3,"STRING":4,"JSONNumber":5,"NUMBER":6,"JSONNullLiteral":7,"NULL":8,"JSONBooleanLiteral":9,"TRUE":10,"FALSE":11,"JSONText":12,"JSONValue":13,"EOF":14,"JSONObject":15,"JSONArray":16,"{":17,"}":18,"JSONMemberList":19,"JSONMember":20,":":21,",":22,"[":23,"]":24,"JSONElementList":25,"$accept":0,"$end":1},
terminals_: {2:"error",4:"STRING",6:"NUMBER",8:"NULL",10:"TRUE",11:"FALSE",14:"EOF",17:"{",18:"}",21:":",22:",",23:"[",24:"]"},
productions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 // replace escaped characters with actual character
          this.$ = new String(yytext.replace(/\\(\\|")/g, "$"+"1")
                     .replace(/\\n/g,'\n')
                     .replace(/\\r/g,'\r')
                     .replace(/\\t/g,'\t')
                     .replace(/\\v/g,'\v')
                     .replace(/\\f/g,'\f')
                     .replace(/\\b/g,'\b'));
          this.$.__line__ =  this._$.first_line;
        
break;
case 2:

            this.$ = new Number(yytext);
            this.$.__line__ =  this._$.first_line;
        
break;
case 3:

            this.$ = null;
        
break;
case 4:

            this.$ = new Boolean(true);
            this.$.__line__ = this._$.first_line;
        
break;
case 5:

            this.$ = new Boolean(false);
            this.$.__line__ = this._$.first_line;
        
break;
case 6:
return this.$ = $$[$0-1];
case 13:
this.$ = {}; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        });
break;
case 14: case 19:
this.$ = $$[$0-1]; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        });
break;
case 15:
this.$ = [$$[$0-2], $$[$0]];
break;
case 16:
this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];
break;
case 17:
this.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];
break;
case 18:
this.$ = []; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        });
break;
case 20:
this.$ = [$$[$0]];
break;
case 21:
this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);
break;
}
},
table: [{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,12:1,13:2,15:7,16:8,17:$V5,23:$V6},{1:[3]},{14:[1,16]},o($V7,[2,7]),o($V7,[2,8]),o($V7,[2,9]),o($V7,[2,10]),o($V7,[2,11]),o($V7,[2,12]),o($V7,[2,3]),o($V7,[2,4]),o($V7,[2,5]),o([14,18,21,22,24],[2,1]),o($V7,[2,2]),{3:20,4:$V0,18:[1,17],19:18,20:19},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:23,15:7,16:8,17:$V5,23:$V6,24:[1,21],25:22},{1:[2,6]},o($V7,[2,13]),{18:[1,24],22:[1,25]},o($V8,[2,16]),{21:[1,26]},o($V7,[2,18]),{22:[1,28],24:[1,27]},o($V9,[2,20]),o($V7,[2,14]),{3:20,4:$V0,20:29},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:30,15:7,16:8,17:$V5,23:$V6},o($V7,[2,19]),{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:31,15:7,16:8,17:$V5,23:$V6},o($V8,[2,17]),o($V8,[2,15]),o($V9,[2,21])],
defaultActions: {16:[2,6]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    
        function lex() {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, state, action, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 6
case 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4
case 3:return 17
case 4:return 18
case 5:return 23
case 6:return 24
case 7:return 22
case 8:return 21
case 9:return 10
case 10:return 11
case 11:return 8
case 12:return 14
case 13:return 'INVALID'
}
},
rules: [/^(?:\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,/^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?::)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:null\b)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
}
});
jsonlint.parser;
jsonlint.Parser;
jsonlint.parse;

function readStyle(style) {
    if (style instanceof String || typeof style === 'string' || style instanceof Buffer) {
        try {
            return jsonlint.parse(style.toString());
        } catch (e) {
            throw new ParsingError$1(e);
        }
    }
    return style;
}

function validateStyle(style, styleSpec) {
    if (styleSpec === void 0)
        styleSpec = v8;
    var s = style;
    try {
        s = readStyle(s);
    } catch (e) {
        return [e];
    }
    return validateStyleMin(s, styleSpec);
}

var expression$1 = {
    StyleExpression: StyleExpression,
    isExpression: isExpression,
    isExpressionFilter: isExpressionFilter,
    createExpression: createExpression,
    createPropertyExpression: createPropertyExpression,
    normalizePropertyExpression: normalizePropertyExpression,
    ZoomConstantExpression: ZoomConstantExpression,
    ZoomDependentExpression: ZoomDependentExpression,
    StylePropertyFunction: StylePropertyFunction
};
validateStyle.parsed = validateStyle;
validateStyle.latest = validateStyle;

function n$Z(n){return "object"==typeof n&&null!==n&&!(n instanceof Array)}function r$s(n){return n instanceof Array}function t$y(o){if(n$Z(o)){const n={};for(const r in o)n[r]=t$y(o[r]);return n}if(r$s(o)){const n=[];for(const r of o)n.push(r);return n}return o}

var s$o;!function(e){e[e.POINT=1]="POINT",e[e.LINESTRING=2]="LINESTRING",e[e.POLYGON=3]="POLYGON";}(s$o||(s$o={}));class r$r{constructor(t,s){let n;if("string"==typeof s){n={type:s};}else if(void 0!==s){const e=s;n=r$r.createPropSpec(e);}const{result:l,value:a}=expression$1.createExpression(t,n);if("success"!==l)throw a[0];this._style_expr=a;}static createPropSpec(e){const s={type:e.value_type};return "array"===e.value_type&&(void 0!==e.element_type&&(s.value=e.element_type),void 0!==e.num_elements&&(s.length=e.num_elements)),void 0!==e.default_value&&(s.default=t$y(e.default_value)),s}evaluate(e,t,s){return this._style_expr.evaluate(e,t,s,undefined,e.image_names)}}function n$Y(t){return expression$1.isExpression(t)}

class e$t{constructor(t){this._value=t;}evaluate(){return this._value}}function a$j(t,a,o){const i=new r$r(a,o);return new e$t(i.evaluate(t))}class o$r{constructor(o,i,h){let r;if(this.name=i.name,this._is_layout="layout"===i.category,this._has_zoom=!1,this._has_fdata=!1,this._has_fstate=!1,void 0!==h)n$Y(h)?(this.analyzeExpression(h),r=this.isConstant()?a$j(o,h,i):new r$r(h,i)):r="string"==typeof h&&"color"===i.value_type?a$j(o,h,i):new e$t(h);else {const t=i.default_value;let s;if(void 0!==t)if("color"===i.value_type){s=a$j(o,t,i).evaluate(o);}else s=t;else s=null;r=new e$t(s);}this._evaluator=r;}isLayoutType(){return this._is_layout}isConstant(){return !this._has_zoom&&!this._has_fdata&&!this._has_fstate}hasZoom(){return this._has_zoom}hasFData(){return this._has_fdata}hasFState(){return this._has_fstate}evaluate(t,s,e){return this._evaluator.evaluate(t,s,e)}analyzeExpression(s){const e=s[0];if("literal"!==e){"zoom"===e?this._has_zoom=!0:"feature-state"===e?this._has_fstate=!0:("get"!==e&&"has"!==e||2!==s.length)&&"id"!==e&&"geometry-type"!==e&&"properties"!==e||(this._has_fdata=!0);for(let e=1;e<s.length;++e){const a=s[e];n$Y(a)&&this.analyzeExpression(a);}}}}

class a$i{constructor(a,r,s){const o=r.source;if("string"!=typeof o)throw new SyntaxError("Vector tile layer requires a 'source' property.");const _=a.__getSource(o);if(!_)throw new Error(`No source instance with name '${o}' found.`);const i=r["source-layer"];if("string"!=typeof i)throw new SyntaxError("Vector tile layer requires a 'source-layer' property.");const l=r.layout||{};if(!n$Z(l))throw new SyntaxError("Layer's 'layout' property is invalid type.");const u=r.paint||{};if(!n$Z(u))throw new SyntaxError("Layer's 'paint' property is invalid type.");const n=l.visibility||"visible",c={zoom:0,image_names:a.__image_manager.getImageNames()},p=new o$r(c,{name:"filter",category:"layout",value_type:"boolean",default_value:!0},r.filter);if(p.hasFState())throw new Error("Layer's 'filter' property cannot use the 'feature-state' operator.");const h=new o$r(c,{name:"minzoom",category:"paint",value_type:"number",default_value:0},r.minzoom),d=new o$r(c,{name:"maxzoom",category:"paint",value_type:"number",default_value:24},r.maxzoom),f=new Map,y=new Map,v={cached_properties:[],cached_paint_properties:[],cached_layout_properties:[]},m={cached_properties:[],cached_paint_properties:[],cached_layout_properties:[]};for(const t of s){const a="layout"===t.category?l[t.name]:u[t.name],r=new o$r(c,t,a);if(r.isLayoutType()&&r.hasFState())throw new Error("Layer's '${property.name}' property cannot use the 'feature-state' operator.");if(f.set(t.name,r),r.hasFData()||r.hasFState()){m.cached_properties.push(r);r.hasFData()&&!r.hasFState()&&!r.hasZoom()||(r.isLayoutType()?m.cached_layout_properties.push(r):m.cached_paint_properties.push(r));}else r.hasZoom()?(v.cached_properties.push(r),r.isLayoutType()?v.cached_layout_properties.push(r):v.cached_paint_properties.push(r)):y.set(r,r.evaluate(c));}this.style_manager=a,this.id=r.id,this.type=r.type,this.__source_inst=_,this.__source_layer=i,this.__filter=p,this.__minzoom=h,this.__maxzoom=d,this.__flake_property_data=v,this.__feature_property_data=m,this._evaluated_value_cache=y,this._visibility="visible"===n,this._properties=f;}get visibility(){return this._visibility}set visibility(e){this._visibility=e;}__getProperty(e){const t=this._properties.get(e);if(void 0!==t)return t;throw new Error(`unexpected property '${e}'`)}__getProperties(){return this._properties.values()}__getConstantValue(e){return this._evaluated_value_cache.get(e)}}class r$q{constructor(e,t,a){this.style_layer=e,this._layer_features=new Map,this.__last_zoom=a.zoom,this._tile_layer=t,this._evaluated_value_cache=new Map;for(const t of e.__flake_property_data.cached_properties){const e=t.evaluate(a);this._evaluated_value_cache.set(t,e);}}dispose(){for(const e of this._layer_features.values())e.dispose();}__createInitialLayerFeatures(e){const t=this.style_layer,a=a=>{const r=t.__filter;if(r.hasFData()){for(const t of a)if(r.evaluate(e,t)){const a=this.createLayerFeature(t,e);this._layer_features.set(t,a);}}else if(r.evaluate(e))for(const t of a){const a=this.createLayerFeature(t,e);this._layer_features.set(t,a);}};t.__isSupported(1)&&a(this._tile_layer.point_features),t.__isSupported(2)&&a(this._tile_layer.linestring_features),t.__isSupported(3)&&a(this._tile_layer.polygon_features);}__evaluateFeatures(e){const t=this.startEvaluation(e),a={added_features:new Set,deleted_features:new Set,evaluated_properties:new Set};this.update_evaluated_value_cache(e,a),this.filterFeatures(e,a);for(const t of this._layer_features.values())t.__updateEvaluatedValueCache(e,a);0===this._layer_features.size&&a.evaluated_properties.clear(),t(a);for(const e of a.added_features)this._layer_features.set(e.feature,e);for(const e of a.deleted_features)e.dispose();this.__last_zoom=e.zoom;}getOwnEvaluatedValue(e){return this._evaluated_value_cache.get(e)}update_evaluated_value_cache(e,t){if(e.zoom===this.__last_zoom)return;const a=this.style_layer.__flake_property_data;for(const t of a.cached_paint_properties){const a=t.evaluate(e);this._evaluated_value_cache.set(t,a);}if(Math.round(e.zoom)!==Math.round(this.__last_zoom))for(const r of a.cached_layout_properties){const a=r.evaluate(e);this._evaluated_value_cache.set(r,a),t.evaluated_properties.add(r);}}filterFeatures(e,t){const a=this.style_layer,r=a.__filter;if(!r.hasZoom())return;if(Math.round(e.zoom)===Math.round(this.__last_zoom))return;const s=a=>{const s=this._layer_features;if(r.hasFData())for(const o of a){const a=s.get(o);if(r.evaluate(e,o)){if(void 0===a){const a=this.createLayerFeature(o,e);t.added_features.add(a);}}else void 0!==a&&(t.deleted_features.add(a),s.delete(o));}else if(r.evaluate(e)){for(const r of a)if(!s.has(r)){const a=this.createLayerFeature(r,e);t.added_features.add(a);}}else for(const e of a){const a=s.get(e);void 0!==a&&(t.deleted_features.add(a),s.delete(e));}};a.__isSupported(1)&&s(this._tile_layer.point_features),a.__isSupported(2)&&s(this._tile_layer.linestring_features),a.__isSupported(3)&&s(this._tile_layer.polygon_features);}}class s$n{constructor(e,t,a){this.feature=e,this.layer_flake=t,this._evaluated_value_cache=new Map;const r=t.style_layer,s=r.style_manager,o=r.__feature_property_data;for(const t of o.cached_properties){let r;t.hasFState()&&(r=s.__findExprFeatureState(e.id));const o=t.evaluate(a,e,r);this._evaluated_value_cache.set(t,o);}}dispose(){}getEvaluatedValue(e){const t=this._evaluated_value_cache.get(e);if(void 0!==t)return t;const a=this.layer_flake.getOwnEvaluatedValue(e);return void 0!==a?a:this.layer_flake.style_layer.__getConstantValue(e)}getEvaluatedColor(e,t){const a=this.getEvaluatedValue(e);return t[0]=a.r,t[1]=a.g,t[2]=a.b,t[3]=a.a,t}__updateEvaluatedValueCache(e,t){const a=this.layer_flake,r=a.style_layer,s=r.style_manager,o=r.__feature_property_data,_=e.zoom!==a.__last_zoom;for(const t of o.cached_paint_properties)if(t.hasFState()){const a=s.__findExprFeatureState(this.feature.id),r=t.evaluate(e,this.feature,a);this._evaluated_value_cache.set(t,r);}else if(_){const a=t.evaluate(e,this.feature);this._evaluated_value_cache.set(t,a);}if(Math.round(e.zoom)!==Math.round(a.__last_zoom))for(const a of o.cached_layout_properties){const r=a.evaluate(e,this.feature);this._evaluated_value_cache.set(a,r),t.evaluated_properties.add(a);}}}

class t$x{constructor(){}static createModuleByBese64(r){return __awaiter(this,void 0,void 0,(function*(){const e=yield t$x._createArrayBuffer(r);return WebAssembly.compile(e)}))}static createEmObjectByBese64(r,a){return __awaiter(this,void 0,void 0,(function*(){const e=yield t$x._createArrayBuffer(r),i=yield a({wasmBinary:e});return delete i.wasmBinary,i}))}static createEmObjectByModule(t,r){return __awaiter(this,void 0,void 0,(function*(){return r({instantiateWasm:(e,r)=>(WebAssembly.instantiate(t,e).then((e=>{r(e);})).catch((e=>{console.error("error: "+e.message);})),{})})}))}static _createArrayBuffer(t){return __awaiter(this,void 0,void 0,(function*(){const e=yield fetch("data:application/wasm;base64,"+t);if(!e.ok)throw new Error(e.statusText);return e.arrayBuffer()}))}}

var A$2="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AAshAEGECkEwNgIADAYLQYAKIAA2AgAgA0F/Rg0FIAIgBmohBgwICyABQX9HDQcMBQsAC0EAIQUMCAtBACEDDAYLQYQKQTA2AgAMAQsgAEEDIAZrQXxxIgJqIQECQCACQQFOQQAgACABTxsNAD8AQRB0IAFJBEAgARABRQ0BC0GACiABNgIADAELQYQKQTA2AgALQcQNQcQNKAIAQQRyNgIACyAFQf7///8HSw0BQYAKKAIAIgEgBUEDakF8cSICaiEAAkACQAJ/AkAgAkEBSA0AIAAgAUsNACABDAELIAA/AEEQdE0NASAAEAENAUGACigCAAshAEGECkEwNgIAQX8hAQwBC0GACiAANgIACz8AQRB0IABJBEAgABABRQ0CC0GACiAANgIAIAAgAU0NASABQX9GDQEgAEF/Rg0BIAAgAWsiBiAEQShqTQ0BC0G4DUG4DSgCACAGaiIANgIAQbwNKAIAIABJBEBBvA0gADYCAAsCQAJAAkBBoAooAgAiAgRAQcgNIQADQCABIAAoAgAiAyAAKAIEIgVqRg0CIAAoAggiAA0ACwwCC0GYCigCACIAQQAgACABTRtFBEBBmAogATYCAAtBACEAQcwNIAY2AgBByA0gATYCAEGoCkF/NgIAQawKQeANKAIANgIAQdQNQQA2AgADQCAAQQN0IgJBuApqIAJBsApqIgM2AgAgAkG8CmogAzYCACAAQQFqIgBBIEcNAAtBlAogBkEoayIAQXggAWtBB3FBACABQQhqQQdxGyICayIDNgIAQaAKIAEgAmoiAjYCACACIANBAXI2AgQgACABakEoNgIEQaQKQfANKAIANgIADAILIAAtAAxBCHENACABIAJNDQAgAiADSQ0AIAAgBSAGajYCBEGgCiACQXggAmtBB3FBACACQQhqQQdxGyIAaiIBNgIAQZQKQZQKKAIAIAZqIgMgAGsiADYCACABIABBAXI2AgQgAiADakEoNgIEQaQKQfANKAIANgIADAELQZgKKAIAIgUgAUsEQEGYCiABNgIAIAEhBQsgASAGaiEDQcgNIQACQAJAAkACQAJAAkADQCADIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQcgNIQADQCACIAAoAgAiA08EQCADIAAoAgRqIgMgAksNAwsgACgCCCEADAALAAsgACABNgIA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";

var n$X,t$w=(n$X="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(t){var e,r;(t=void 0!==(t=t||{})?t:{}).ready=new Promise((function(n,t){e=n,r=t;}));var o,i={};for(o in t)t.hasOwnProperty(o)&&(i[o]=t[o]);var a="";"undefined"!=typeof document&&document.currentScript&&(a=document.currentScript.src),n$X&&(a=n$X),a=0!==a.indexOf("blob:")?a.substr(0,a.lastIndexOf("/")+1):"",t.print||console.log.bind(console);var u=t.printErr||console.warn.bind(console);for(o in i)i.hasOwnProperty(o)&&(t[o]=i[o]);i=null,t.arguments&&t.arguments,t.thisProgram&&t.thisProgram,t.quit&&t.quit;var c,s,f,l=[];function p(n,t){if(!c){c=new WeakMap;for(var e=0;e<h.length;e++){var r=h.get(e);r&&c.set(r,e);}}if(c.has(n))return c.get(n);var o=function(){if(l.length)return l.pop();try{h.grow(1);}catch(n){if(!(n instanceof RangeError))throw n;throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH."}return h.length-1}();try{h.set(o,n);}catch(e){if(!(e instanceof TypeError))throw e;var i=function(n,t){if("function"==typeof WebAssembly.Function){for(var e={i:"i32",j:"i64",f:"f32",d:"f64"},r={parameters:[],results:"v"==t[0]?[]:[e[t[0]]]},o=1;o<t.length;++o)r.parameters.push(e[t[o]]);return new WebAssembly.Function(r,n)}var i=[1,0,1,96],a=t.slice(0,1),u=t.slice(1),c={i:127,j:126,f:125,d:124};for(i.push(u.length),o=0;o<u.length;++o)i.push(c[u[o]]);"v"==a?i.push(0):i=i.concat([1,c[a]]),i[1]=i.length-2;var s=new Uint8Array([0,97,115,109,1,0,0,0].concat(i,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),f=new WebAssembly.Module(s);return new WebAssembly.Instance(f,{e:{f:n}}).exports.f}(n,t);h.set(o,i);}return c.set(n,o),o}t.wasmBinary&&(s=t.wasmBinary),t.noExitRuntime&&t.noExitRuntime,"object"!=typeof WebAssembly&&I("no native wasm support detected");var m,y,d=!1;function _(n){m=n,t.HEAP8=new Int8Array(n),t.HEAP16=new Int16Array(n),t.HEAP32=new Int32Array(n),t.HEAPU8=y=new Uint8Array(n),t.HEAPU16=new Uint16Array(n),t.HEAPU32=new Uint32Array(n),t.HEAPF32=new Float32Array(n),t.HEAPF64=new Float64Array(n);}"undefined"!=typeof TextDecoder&&new TextDecoder("utf8"),"undefined"!=typeof TextDecoder&&new TextDecoder("utf-16le");var h,v=t.INITIAL_MEMORY||262144;(f=t.wasmMemory?t.wasmMemory:new WebAssembly.Memory({initial:v/65536,maximum:32768}))&&(m=f.buffer),v=m.byteLength,_(m);var w=[],b=[],g=[],A=[],R=0,W=null;function I(n){t.onAbort&&t.onAbort(n),u(n+=""),d=!0,n="abort("+n+"). Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(n);throw r(e),e}function E(n){return t=n,e="data:application/octet-stream;base64,",String.prototype.startsWith?t.startsWith(e):0===t.indexOf(e);var t,e;}t.preloadedImages={},t.preloadedAudios={};var S,x="sdfield.wasm";function P(){try{if(s)return new Uint8Array(s);throw "both async and sync fetching of the wasm failed"}catch(n){I(n);}}function k(n){for(;n.length>0;){var e=n.shift();if("function"!=typeof e){var r=e.func;"number"==typeof r?void 0===e.arg?h.get(r)():h.get(r)(e.arg):r(void 0===e.arg?null:e.arg);}else e(t);}}function T(n){try{return f.grow(n-m.byteLength+65535>>>16),_(f.buffer),1}catch(n){}}E(x)||(S=x,x=t.locateFile?t.locateFile(S,a):a+S),b.push({func:function(){H();}});var M={abort:function(){I();},emscripten_memcpy_big:function(n,t,e){y.copyWithin(n,t,t+e);},emscripten_resize_heap:function(n){n>>>=0;var t,e,r=y.length,o=2147483648;if(n>o)return !1;for(var i=1;i<=4;i*=2){var a=r*(1+.5/i);if(T(Math.min(o,((t=Math.max(n,a))%(e=65536)>0&&(t+=e-t%e),t))))return !0}return !1},memory:f};!function(){var n={env:M,wasi_snapshot_preview1:M};function e(n,e){var r=n.exports;t.asm=r,h=t.asm.__indirect_function_table,function(n){if(R--,t.monitorRunDependencies&&t.monitorRunDependencies(R),0==R&&W){var e=W;W=null,e();}}();}function o(n){e(n.instance);}function i(t){return (s||"function"!=typeof fetch?Promise.resolve().then(P):fetch(x,{credentials:"same-origin"}).then((function(n){if(!n.ok)throw "failed to load wasm binary file at '"+x+"'";return n.arrayBuffer()})).catch((function(){return P()}))).then((function(t){return WebAssembly.instantiate(t,n)})).then(t,(function(n){u("failed to asynchronously prepare wasm: "+n),I(n);}))}if(R++,t.monitorRunDependencies&&t.monitorRunDependencies(R),t.instantiateWasm)try{return t.instantiateWasm(n,e)}catch(n){return u("Module.instantiateWasm callback failed with error: "+n),!1}(s||"function"!=typeof WebAssembly.instantiateStreaming||E(x)||"function"!=typeof fetch?i(o):fetch(x,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,n).then(o,(function(n){return u("wasm streaming compile failed: "+n),u("falling back to ArrayBuffer instantiation"),i(o)}))}))).catch(r);}();var F,H=t.___wasm_call_ctors=function(){return (H=t.___wasm_call_ctors=t.asm.__wasm_call_ctors).apply(null,arguments)};function O(n){function r(){F||(F=!0,t.calledRun=!0,d||(k(b),k(g),e(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),function(){if(t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;)n=t.postRun.shift(),A.unshift(n);var n;k(A);}()));}R>0||(function(){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)n=t.preRun.shift(),w.unshift(n);var n;k(w);}(),R>0||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("");}),1),r();}),1)):r()));}if(t._converter_create=function(){return (t._converter_create=t.asm.converter_create).apply(null,arguments)},t._converter_destroy=function(){return (t._converter_destroy=t.asm.converter_destroy).apply(null,arguments)},t._converter_get_write_position=function(){return (t._converter_get_write_position=t.asm.converter_get_write_position).apply(null,arguments)},t._converter_build_sdf=function(){return (t._converter_build_sdf=t.asm.converter_build_sdf).apply(null,arguments)},t.___errno_location=function(){return (t.___errno_location=t.asm.__errno_location).apply(null,arguments)},t.stackSave=function(){return (t.stackSave=t.asm.stackSave).apply(null,arguments)},t.stackRestore=function(){return (t.stackRestore=t.asm.stackRestore).apply(null,arguments)},t.stackAlloc=function(){return (t.stackAlloc=t.asm.stackAlloc).apply(null,arguments)},t.addFunction=function(n,t){return p(n,t)},W=function n(){F||O(),F||(W=n);},t.run=O,t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();return O(),t.ready});

let e$s;t$x.createEmObjectByBese64(A$2,t$w).then((s=>{e$s=s;}));const r$p=.05,a$h=-Math.sqrt(2),f$5=4096,i$q=512;

const i$p=1/r$p+a$h;class n$W{constructor(t){this.glenv=t,this._canvas_width=1,this._canvas_height=1,this._canvas_context=this._create_canvas_context(),this._cache_nodes=new Map,this._num_nodes_created=0,this._num_nodes_referenced=0;}get_handle(t,e,_){const s=Math.min(Math.max(t,0),i$p);let a=this._cache_nodes.get(e);a||(a=_(this._canvas_context,s),this._cache_nodes.set(e,a),++this._num_nodes_created);const n=new m$d(a,s);return 1===a.ref_count&&++this._num_nodes_referenced,this._try_reduce_cache(),n}_try_reduce_cache(){if(this._cache_nodes.size<=150)return;if(this._cache_nodes.size<=3*this._num_nodes_referenced)return;const t=Math.max(Math.round(2*this._num_nodes_referenced),150),e=[];for(const t of this._cache_nodes.values())0===t.ref_count&&e.push(t);const _=this._cache_nodes.size-t;e.sort(((t,e)=>t.unreferenced_time-e.unreferenced_time)),e.length=_;for(const t of e){const e=t.getNodeKey();this._cache_nodes.delete(e);}}_create_canvas_context(){const t=document.createElement("canvas");t.width=this._canvas_width,t.height=this._canvas_height;const e=t.getContext("2d",{willReadFrequently:!0});if(!e)throw new Error("Cannot get context of canvas");return this.setupCanvasContext(e),e}_create_sdf_texture(t){const e=this.glenv.context,_=e.TEXTURE_2D,s=e.createTexture();if(null===s)throw new Error("Failed to create texture");return e.bindTexture(_,s),this._create_sdfield_image(t,((t,s,a)=>{e.texImage2D(_,0,e.LUMINANCE,s,a,0,e.LUMINANCE,e.UNSIGNED_BYTE,t);})),e.texParameteri(_,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(_,e.TEXTURE_MIN_FILTER,e.LINEAR),e.bindTexture(_,null),s}_create_sdfield_image(s,a){const i=Math.ceil(s.sdf_max_width+.5),n=s.canvas_width+2*i,h=s.canvas_height+2*i,r=4*Math.ceil(n/4);if(n>f$5||h>i$q)throw new Error("Symbol image is too large");const c=s.canvas_width,d=s.canvas_height,o=e$s._converter_create(c,d,i);try{const t=c*d,e=this._get_image_data(s).data;let i=3,u=e$s._converter_get_write_position(o);const x=e$s.HEAPU8;for(let _=0;_<t;++_)x[u]=e[i],i+=4,u+=1;const m=e$s._converter_build_sdf(o),l=e$s.HEAPU8;a(new Uint8Array(l.buffer,m,r*h),n,h);}finally{e$s._converter_destroy(o);}}_ensure_canvas_info(t){const e=Math.max(t.canvas_width,this._canvas_width),_=Math.max(t.canvas_height,this._canvas_height);(e>this._canvas_width||_>this._canvas_height)&&(this._canvas_width=e,this._canvas_height=_,this._canvas_context=this._create_canvas_context());}_get_image_data(t){this._ensure_canvas_info(t);const e=this._canvas_context;return e.clearRect(0,0,t.canvas_width,t.canvas_height),this.drawImage(e,t),e.getImageData(0,0,t.canvas_width,t.canvas_height)}__make_unreferenced(t){t.unreferenced_time=this._num_nodes_created,--this._num_nodes_referenced;}}class h$8 extends n$W{constructor(t){super(t);}getHandle(t,e,_,s){const a=Math.max(_,.1);return this.get_handle(s,c$9(t,e),((_,s)=>{_.font=e;const i=_.measureText(t);return new u$9(this,t,e,a,s,i)}))}setupCanvasContext(t){t.textAlign="left",t.textBaseline="top",t.fillStyle="rgba( 255, 255, 255, 1.0 )";}drawImage(t,e){const _=e;t.font=_.style,t.fillText(_.text,e.bbox_L,e.bbox_A);}}function c$9(t,e){return `${e} ~~~ ${t}`}function d$8(t){return !(t.canvas_width<1)&&(!(t.canvas_height<1)&&(!(t.anchor_dist_x<0)&&(!(t.anchor_dist_y<0)&&(!!isFinite(t.bbox_L)&&!!isFinite(t.bbox_A)))))}class o$q{constructor(t,e){this.ref_count=0,this.unreferenced_time=0,this.image_cache=t,this.sdf_max_width=e;}is_valid(){return !(this.ref_count<0)&&!(this.sdf_max_width<0)}add_ref(){++this.ref_count;}release(){--this.ref_count,0==this.ref_count&&this.image_cache.__make_unreferenced(this);}}class u$9 extends o$q{constructor(t,e,_,s,a,i){super(t,a),this.text=e,this.style=_;const n=i.actualBoundingBoxLeft,h=i.actualBoundingBoxRight,r=i.actualBoundingBoxAscent,c=i.actualBoundingBoxDescent;this.canvas_width=Math.max(Math.ceil(n+h),1),this.canvas_height=Math.max(Math.ceil(r+c),1),this.anchor_dist_x=i.width,this.anchor_dist_y=s,this.bbox_L=n,this.bbox_A=r,this.sdf_texture=t._create_sdf_texture(this);}is_valid(){return !!super.is_valid()&&!!d$8(this)}getNodeKey(){return c$9(this.text,this.style)}}class m$d{constructor(t,e){this._cache_node=t,this._disp_ext_size=e,e>t.sdf_max_width&&(t.sdf_max_width=Math.max(e,t.sdf_max_width+5),t.sdf_texture=t.image_cache._create_sdf_texture(t)),this._texture=t.sdf_texture,t.add_ref();}is_valid(){return !(this._disp_ext_size<0)&&!(this._disp_ext_size>this._cache_node.sdf_max_width)}checkRebuild(t){t=Math.min(Math.max(t,0),i$p);const e=this._cache_node;let _=!1;return t>e.sdf_max_width&&(e.sdf_max_width=Math.max(t,e.sdf_max_width+5),e.sdf_texture=e.image_cache._create_sdf_texture(e),_=!0),t>this._disp_ext_size?(this._disp_ext_size=Math.min(t+3.5,e.sdf_max_width),_=!0):t<this._disp_ext_size-3.5&&(this._disp_ext_size=Math.max(this._disp_ext_size-3.5,0),_=!0),this._texture!==e.sdf_texture&&(this._texture=e.sdf_texture,_=!0),_}getTexture(){return this._texture}getImageInfo(){const t=this._cache_node,e=Math.ceil(t.sdf_max_width+.5),_=t.canvas_width+2*e,s=t.canvas_height+2*e,a=e+t.bbox_L,i=e+t.canvas_height-t.bbox_A,n=this._disp_ext_size;return {texture_width:_,texture_height:s,display_lower_x:e-n,display_lower_y:e-n,display_upper_x:_-e+n,display_upper_y:s-e+n,anchor_lower_x:a,anchor_lower_y:i-t.anchor_dist_y,anchor_upper_x:a+t.anchor_dist_x,anchor_upper_y:i}}dispose(){this._cache_node.release();}}

class i$o{constructor(e){this.id=e;}}class m$c extends i$o{constructor(e,t){super(e);const r=document.createElement("canvas");r.width=t.width,r.height=t.height,this.image=r;const s=r.getContext("2d");if(!s)throw new Error("Cannot get context of canvas");s.drawImage(t,0,0,t.width,t.height);}}

function h$7(e,t,r){m$b.set(e,t);}const m$b=new Map;

var i$n;!function(i){i.OMIT="omit",i.SAME_ORIGIN="same-origin",i.INCLUDE="include";}(i$n||(i$n={}));

var o$p;!function(o){o.createOpaqueColor=function(o){return e$z.createVector3(o)},o.createColor=function(o){return e$z.createVector4(o?e$z.isVector4(o)?o:[o[0],o[1],o[2],1]:void 0)},o.copyOpaqueColor=function(t,o){return o[0]=t[0],o[1]=t[1],o[2]=t[2],o},o.copyColor=function(o,r){return r[0]=o[0],r[1]=o[1],r[2]=o[2],r[3]=e$z.isVector3(o)?1:o[3],r},o.premultiply=function(o,r){if(e$z.isVector4(o)){const t=o[3];0===t?r[0]=r[1]=r[2]=r[3]=0:(r[0]=o[0]/t,r[1]=o[1]/t,r[2]=o[2]/t,r[3]=t);}else r[0]=o[0],r[1]=o[1],r[2]=o[2],r[3]=1;return r},o.toRGBString=function(r){const e=o.floatToByte(r[0]),n=o.floatToByte(r[1]),c=o.floatToByte(r[2]);if(e$z.isVector4(r)){return `rgba(${e},${n},${c},${o.floatToByte(r[3])})`}return `rgb(${e},${n},${c})`},o.floatToByte=function(t){return 1===t?255:256*t|0};}(o$p||(o$p={}));var r$o=o$p;

class _$a{constructor(){this._empty=!0,this._min_lon=0,this._max_lon=0,this._min_lat=0,this._max_lat=0,this._min_alt=0,this._max_alt=0;}empty(){return this._empty}_add(t,_,i){if(this._empty)this._empty=!1,t-=360*Math.floor(t/360+.5),this._min_lon=this._max_lon=t,this._min_lat=this._max_lat=_,this._min_alt=this._max_alt=i;else {const n=this._calcRightPosition(this._min_lon,t);if(n<=this._max_lon);else {const _=this._calcRightPosition(this._max_lon,t)-this._max_lon,i=n-360-this._min_lon;Math.abs(_)<=Math.abs(i)?this._max_lon=this._max_lon+_:this._min_lon=this._min_lon+i;}_<this._min_lat?this._min_lat=_:_>this._max_lat&&(this._max_lat=_),i<this._min_alt?this._min_alt=i:i>this._max_alt&&(this._max_alt=i);}}_calcRightPosition(t,_){let i=_-t;return i-=360*Math.floor(i/360),t+i}addPoint(t){this._add(t.longitude,t.latitude,t.altitude);}addPoints(...t){t.forEach((t=>{this._add(t.longitude,t.latitude,t.altitude);}));}addPointsAsArray(t){for(let _=0;_<t.length;_+=3)this._add(t[_],t[_+1],t[_+2]);}merge(t){if(!t.empty())if(this._empty)this._min_lon=t._min_lon,this._max_lon=t._max_lon,this._min_lat=t._min_lat,this._max_lat=t._max_lat,this._min_alt=t._min_alt,this._max_alt=t._max_alt,this._empty=!1;else {let _=this._calcRightPosition(this._min_lon,t._min_lon);const i=this._calcRightPosition(this._min_lon,t._max_lon);_>i&&(_-=360);let n=!1;_>=this._min_lon&&_<=this._max_lon&&(n=!0);let a=!1;if(i>=this._min_lon&&i<=this._max_lon&&(a=!0),n&&a);else if(n)this._max_lon=i;else if(a)this._min_lon=_;else if(this._min_lon>=_&&this._max_lon<=i)this._min_lon=t._min_lon,this._max_lon=t._max_lon;else {const t=i-this._max_lon,n=_-360-this._min_lon;Math.abs(t)<=Math.abs(n)?this._max_lon=this._max_lon+t:this._min_lon=this._min_lon+n;}this._min_lat=Math.min(this._min_lat,t._min_lat),this._max_lat=Math.max(this._max_lat,t._max_lat),this._min_alt=Math.min(this._min_alt,t._min_alt),this._max_alt=Math.max(this._max_alt,t._max_alt);}}getPoint(_,i,n=0){return this._empty?null:new r$z((1-_)*this._min_lon+_*this._max_lon,(1-i)*this._min_lat+i*this._max_lat,(1-n)*this._min_alt+n*this._max_alt)}getSouthWest(){return this._empty?null:new r$z(this._min_lon,this._min_lat,this._min_alt)}getNorthEast(){return this._empty?null:new r$z(this._max_lon,this._max_lat,this._max_alt)}getCenter(){return this._empty?null:this.getPoint(.5,.5,.5)}getLongitudeDistance(){const t=this.getPoint(0,.5),_=this.getPoint(1,.5);return t&&_?t.getGeographicalDistance(_):null}getLatitudeDistance(){const t=this.getPoint(.5,0),_=this.getPoint(.5,1);return t&&_?t.getGeographicalDistance(_):null}}

class o$o{constructor(o,r){this.position=o||e$z.createVector3(),this.direction=r||e$z.createVector3([0,0,-1]);}clone(){return new o$o(e$z.createVector3(this.position),e$z.createVector3(this.direction))}static transform_A(o,r,i){return e$z.transformPosition_A(o,r.position,i.position),e$z.transformDirection_A(o,r.direction,i.direction),i}}

class e$r{constructor(s){this._canvas_size=s,this.fov=46,this.near=1,this.far=1e3,this.view_to_gocs=e$z.setIdentity(e$z.createMatrix());}copyViewParameters(s){this.fov=s.fov,this.near=s.near,this.far=s.far,e$z.copyMatrix(s.view_to_gocs,this.view_to_gocs);}getCanvasToView(s){var e=s||e$z.createMatrix(),i=this._canvas_size.width,a=this._canvas_size.height,_=this.near,r=this.far,o=this.fov*e$z.DEGREE/2,h=a/i,n=_*Math.tan(o)/Math.sqrt(1+h*h),v=n*h;return e[0]=2*n/(_*i),e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*v/(_*a),e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=0,e[11]=(_-r)/(_*r),e[12]=-n/_,e[13]=v/_,e[14]=-1,e[15]=1/_,e}getCanvasToGocs(t){var s=this.getCanvasToView(t),e=s[0],i=s[5],a=s[11],_=s[12],r=s[13],o=s[15],h=this.view_to_gocs,n=h[0],v=h[1],c=h[2],p=h[4],u=h[5],l=h[6],w=h[8],m=h[9],f=h[10],x=h[12],g=h[13],d=h[14],M=s;return M[0]=n*e,M[1]=v*e,M[2]=c*e,M[4]=p*i,M[5]=u*i,M[6]=l*i,M[8]=x*a,M[9]=g*a,M[10]=d*a,M[12]=n*_+p*r-w+x*o,M[13]=v*_+u*r-m+g*o,M[14]=c*_+l*r-f+d*o,M}getViewToCanvas(s){var e=s||e$z.createMatrix(),i=this._canvas_size.width,a=this._canvas_size.height,_=this.near,r=this.far,o=this.fov*e$z.DEGREE/2,h=a/i,n=_*Math.tan(o)/Math.sqrt(1+h*h),v=n*h;return e[0]=_*i/(2*n),e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-_*a/(2*v),e[6]=0,e[7]=0,e[8]=-i/2,e[9]=-a/2,e[10]=r/(_-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=_*r/(_-r),e[15]=0,e}getCanvasRay(i,a){var _=i[0],r=i[1],o=a||new o$o,h=this.getCanvasToGocs(e$r._temp_mat),n=_*h[0]+r*h[4]+h[12],v=_*h[1]+r*h[5]+h[13],c=_*h[2]+r*h[6]+h[14],p=_*h[3]+r*h[7]+h[15],u=o.position;u[0]=n/p,u[1]=v/p,u[2]=c/p;var l=this.view_to_gocs,w=o.direction;return w[0]=u[0]-l[12],w[1]=u[1]-l[13],w[2]=u[2]-l[14],e$z.normalize3(w,w),o}get canvas_size(){return this._canvas_size}createRenderInfo(t,s,i,a){const _=this._canvas_size;return new e$r.RenderInfo(this,_.width,_.height,t,s,i,a)}}e$r._temp_mat=e$z.createMatrix(),function(s){s.RenderInfo=class{constructor(s,e,i,a,_,r,o){this._view_to_clip=e$z.createMatrix(),this._volume_planes=[];for(var h=0;h<6;++h)this._volume_planes.push(e$z.createVector4());this._pixel_step=0,this._setup_view_to_clip(s,e,i,a,_,r,o),this._setup_volume_planes(),this._setup_pixel_step(e,i);}get view_to_clip(){return this._view_to_clip}get volume_planes(){return this._volume_planes}get pixel_step(){return this._pixel_step}_setup_view_to_clip(s,e,i,a=0,_=0,r=e,o=i){const h=2*a/e,n=2*_/i,v=r/e,c=o/i,p=i/e,u=s.fov*e$z.DEGREE/2,l=s.near*Math.tan(u)/Math.sqrt(1+p*p),w=(h-v)*l,m=(h+v)*l,f=(n-c)*l*p,x=(n+c)*l*p;e$z.frustum_matrix(w,m,f,x,s.near,s.far,this._view_to_clip);}_setup_volume_planes(){var t=this._view_to_clip,s=this._volume_planes;this._add_matrix_rows(t,3,2,s[0]),this._sub_matrix_rows(t,3,2,s[1]),this._add_matrix_rows(t,3,0,s[2]),this._sub_matrix_rows(t,3,0,s[3]),this._add_matrix_rows(t,3,1,s[4]),this._sub_matrix_rows(t,3,1,s[5]);for(var e=0;e<6;++e){var i=s[e],a=i[0],_=i[1],r=i[2],o=1/Math.sqrt(a*a+_*_+r*r);i[0]*=o,i[1]*=o,i[2]*=o,i[3]*=o;}}_setup_pixel_step(t,s){var e=this._view_to_clip,i=e[0],a=e[5],_=e[11],r=2*(e[15]-_),o=r/(i*t),h=r/(a*s);this._pixel_step=Math.sqrt(o*o+h*h)*Math.SQRT1_2;}_add_matrix_rows(t,s,e,i){return i[0]=t[s]+t[e],i[1]=t[s+4]+t[e+4],i[2]=t[s+8]+t[e+8],i[3]=t[s+12]+t[e+12],i}_sub_matrix_rows(t,s,e,i){return i[0]=t[s]-t[e],i[1]=t[s+4]-t[e+4],i[2]=t[s+8]-t[e+8],i[3]=t[s+12]-t[e+12],i}};}(e$r||(e$r={}));var i$m=e$r;

class t$v{constructor(t){const e=this._getContextWebGL(t,{depth:!0,antialias:!0});if(!e)throw new Error("It doesn't appear your computer can support WebGL.");this._canvas=t,this.context=e,this.context2=e instanceof WebGL2RenderingContext?e:null;const n=this._getExtensions(e);this.OES_element_index_uint=n.OES_element_index_uint,this.EXT_texture_filter_anisotropic=n.EXT_texture_filter_anisotropic,this.WEBGL_depth_texture=n.WEBGL_depth_texture;}_getContextWebGL(t,e){const n=["webgl2","webgl","experimental-webgl"];for(let i=0;i<n.length;++i){const _=t.getContext(n[i],e);if(_ instanceof WebGLRenderingContext||_ instanceof WebGL2RenderingContext)return _}return null}_getExtensions(t){return {OES_element_index_uint:t.getExtension("OES_element_index_uint"),WEBGL_depth_texture:t.getExtension("WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture"),EXT_texture_filter_anisotropic:t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")}}get canvas(){return this._canvas}get is_webgl2(){return null!==this.context2}}

class t$u{constructor(){this._is_started_=!1;}attach(t){if(this._viewer)throw new Error("RenderCallback instance is already attached");this._viewer=t,this._is_started_=!1;}detach(){this._is_started_&&(this.onStop(),this._is_started_=!1),this._viewer=void 0;}onUpdateFrameInner(t){this._is_started_||(this.onStart(),this._is_started_=!0),this.onUpdateFrame(t);}get viewer(){return this._viewer}onStart(){}onUpdateFrame(t){}onStop(){}}

class r$n extends t$u{constructor(){super();}}

var A$1;!function(A){A[A.ABSOLUTE=0]="ABSOLUTE",A[A.RELATIVE=1]="RELATIVE",A[A.CLAMP=2]="CLAMP";}(A$1||(A$1={}));var E$4=A$1;

class i$l{constructor(i,s){this._altitude_mode=E$4.ABSOLUTE,this._need_to_create_regions=!1,this._animation=new i$u,this._visibility=!0,this._pickable=!0,this._anchor_mode=!1,this.scene=i,s&&s.json&&this._setupEntityByJson(s.json);}get visibility(){return this._visibility}setVisibility(t){this._visibility=t;}get anchor_mode(){return this._anchor_mode}setAnchorMode(t){this._anchor_mode=t;}get animation(){return this._animation}set altitude_mode(t){if(this._altitude_mode!==t){var e=this._altitude_mode;this._altitude_mode=t,this.onChangeAltitudeMode(e);}}get altitude_mode(){return this._altitude_mode}onChangeAltitudeMode(t){}getPrimitiveProducer(){}getFlakePrimitiveProducer(){}setPickable(t){this._pickable=t;}isPickable(){return this._pickable}_setupEntityByJson(e){if(e.altitude_mode)switch(e.altitude_mode){case"absolute":this._altitude_mode=E$4.ABSOLUTE;break;case"relative":this._altitude_mode=E$4.RELATIVE;break;case"clamp":this._altitude_mode=E$4.CLAMP;break;default:console.error("unrecognized altitude_mode: "+e.altitude_mode);}void 0!==e.visibility&&this.setVisibility(e.visibility);}}!function(e){e.PrimitiveProducer=class{constructor(t){this._need_to_create_regions=!1,this._entity=t;}getEntity(){return this._entity}needToCreateRegions(){this._need_to_create_regions=!0;}checkToCreateRegions(){var t=this._need_to_create_regions;return this._need_to_create_regions=!1,t}needsElevation(){return this.getEntity().altitude_mode!==E$4.ABSOLUTE}createRegions(){return []}onChangeElevation(t){}};let i;e.FlakePrimitiveProducer=class{constructor(t){this._updated=!1,this._entity=t;}getEntity(){return this._entity}notifyForUpdate(){this._updated=!0;}getAreaStatus(t){return i.EMPTY}createMesh(t,e,i){return null}checkForUpdate(){let t=this._updated;return this._updated=!1,t}},function(t){t[t.EMPTY=0]="EMPTY",t[t.FULL=1]="FULL",t[t.PARTIAL=2]="PARTIAL";}(i=e.AreaStatus||(e.AreaStatus={}));}(i$l||(i$l={}));var s$m=i$l;

class e$q{constructor(e){this.flake=e;}getRenderObject(){return this.flake.getRenderObject(this.lod)}}

class _$9{constructor(t){this._globe=t.viewer.globe;const{view_pos_Q:i,view_dir_wU:s}=_$9._createViewVectors(t);this._view_pos_Q=i,this._view_dir_wU=s,this._clip_planes=_$9._createClipPlanes(t,this._globe);var a=t.viewer,r=a.dem_provider,o=a.tile_texture_cache;this._min_image_z=o.getImageZMin();var l=e$z.LOG2PI-r.getResolutionPower()+1;this._max_zbias=Math.max(o.getImageZBias(),l),this._rflake_list=[],this._debug_stats=a.debug_stats,this._num_procA_flakes=0,this._num_procB_flakes=0,this._view_dir_N=e$z.createVector3(),this._view_dir_V=e$z.createVector3();}static _createViewVectors(t){var _=t.view_to_gocs,i=t.pixel_step,s=e$z.createVector3(),a=e$z.createVector3();return s[0]=_[12],s[1]=_[13],s[2]=_[14],a[0]=-_[8]*i,a[1]=-_[9]*i,a[2]=-_[10]*i,{view_pos_Q:s,view_dir_wU:a}}static _createClipPlanes(t,_){var i=t.view_to_gocs,s=t.gocs_to_view,a=t.getVolumePlanes(),r=[];const o=_.getElevationRange(),l=e$z.EARTH_RADIUS+o.min,h=e$z.EARTH_RADIUS+o.max;var c=i[12],n=i[13],v=i[14],m=c*c+n*n+v*v,d=l*l,g=h*h,p=Math.sqrt((m-d)*(g-d))-d,u=e$z.createVector4(),w=1/Math.sqrt(m);u[0]=c*w,u[1]=n*w,u[2]=v*w,u[3]=p*w,r.push(u);for(var f=Math.sqrt(m+g+2*p),M=0;M<6;++M){var k=a[M],L=e$z.createVector4();1==M&&k[3]>f&&((k=e$z.createVector4(k))[3]=f),e$z.transformPlane_A(s,k,L),r.push(L);}return r}traverse(){const e=this._globe.getRootYRange();for(let t=e.lower;t<=e.upper;++t){const e=this._globe.getRootFlake(t);this._collectFlakes(e);}return this._debug_stats&&(this._debug_stats.num_procA_flakes=this._num_procA_flakes,this._debug_stats.num_procB_flakes=this._num_procB_flakes),this._rflake_list}_collectFlakes(e){if(null!==this._debug_stats&&(this._num_procA_flakes+=1),e.isInvisible(this._clip_planes))return;if(e.z<this._min_image_z)return void this._collectNextLevelFlakes(e);null!==this._debug_stats&&(this._num_procB_flakes+=1);const t=this._getLevelOfDetailRange(e),i=t.mid+this._max_zbias;if(t.max+this._max_zbias<0);else if(t.max-t.min>_$9.MAX_LOD_INTERVAL||i>e.z)return void this._collectNextLevelFlakes(e);this._addRenderFlake(e,t);}_collectNextLevelFlakes(e){for(var t=0;t<2;++t)for(var _=0;_<2;++_)this._collectFlakes(e.newChild(_,t));}_getLevelOfDetailRange(t){for(var _=Math.PI,i=t.z,s=t.x,a=t.y,r=Math.pow(2,1-i)*_,o=s*r-_,l=_-(a+1)*r,h=_/32,c=Math.ceil(r/h),n=r/c,v=e$z.EARTH_RADIUS+t.base_height,m=this._view_pos_Q,d=this._view_dir_wU,g=this._view_dir_N,p=this._view_dir_V,u=Number.MAX_VALUE,w=-Number.MAX_VALUE,f=0,M=l;f<c+1;++f,M+=n)for(var k=Math.exp(M),L=k*k,A=(L-1)/(L+1),b=2*k/(L+1),x=1/(v*b),R=0,V=o;R<c+1;++R,V+=n){var D=Math.sin(V),I=Math.cos(V);g[0]=b*I,g[1]=b*D,g[2]=A,p[0]=v*g[0]-m[0],p[1]=v*g[1]-m[1],p[2]=v*g[2]-m[2];var O=e$z.dot3(d,p);if(O<=0)return {min:-1e3,max:1e3,mid:0};var U=O*x;u=Math.min(u,U),w=Math.max(w,U);}var F=-e$z.maprayLog2(w),N=-e$z.maprayLog2(u);return {min:F,max:N,mid:(F+N)/2}}_calcLOD(t,_,i){var s=Math.sin(t),a=Math.cos(t),r=Math.exp(_),o=r*r,l=(o-1)/(o+1),h=2*r/(o+1),c=this._view_dir_N;c[0]=h*a,c[1]=h*s,c[2]=l;var n=this._view_dir_V,v=this._view_pos_Q;n[0]=i*c[0]-v[0],n[1]=i*c[1]-v[1],n[2]=i*c[2]-v[2];var m=this._view_dir_wU,d=i*h/e$z.dot3(m,n);return e$z.maprayLog2(d)}_setCornerLODs(t){var _=Math.PI,i=t.flake,s=i.z,a=i.x,r=i.y,o=Math.pow(2,1-s)*_,l=a*o-_,h=(a+1)*o-_,c=_-(r+1)*o,n=_-r*o,v=e$z.EARTH_RADIUS+i.base_height;t.lod_00=this._calcLOD(l,c,v),t.lod_10=this._calcLOD(h,c,v),t.lod_01=this._calcLOD(l,n,v),t.lod_11=this._calcLOD(h,n,v);}_addRenderFlake(e,_){var i=new e$q(e);i.lod=_.mid,this._setCornerLODs(i),this._rflake_list.push(i);}}_$9.MAX_LOD_INTERVAL=.5;

class e$p{constructor(e,t,o){this._glenv=e,this.vs_object=this._compile_shader("VERTEX_SHADER",t);try{this.fs_object=this._compile_shader("FRAGMENT_SHADER",o);}catch(t){throw e.context.deleteShader(this.vs_object),t}}dispose(){const e=this._glenv.context;e.deleteShader(this.vs_object),e.deleteShader(this.fs_object),this.vs_object=null,this.fs_object=null;}_compile_shader(e,t){const o=this._glenv.context,r=o.createShader(o[e]);if(!r)throw new Error(`Failed to create ${e} object`);try{if(o.shaderSource(r,t),o.compileShader(r),!o.getShaderParameter(r,o.COMPILE_STATUS)){const t=o.getShaderInfoLog(r);throw new Error(`${e} compilation failed: ${t}`)}}catch(e){throw o.deleteShader(r),e}return r}}

class e$o{constructor(o,e,r){const i=new e$p(o,e,r);this.glenv=o,this._program=this._link_shaders(i.vs_object,i.fs_object),this._vertex_attribs=this._create_vertex_attribs(),this._uniform_location=this._create_uniform_location(),i.dispose();}_link_shaders(t,o){const e=this.glenv.context,r=e.createProgram();if(!r)throw new Error("Failed to create a program object");try{if(e.attachShader(r,t),e.attachShader(r,o),e.linkProgram(r),!e.getProgramParameter(r,e.LINK_STATUS)){const i=e.getProgramInfoLog(r);throw e.detachShader(r,o),e.detachShader(r,t),new Error("Failed to link shader objects: "+i)}}catch(t){throw e.deleteProgram(r),t}return r}_create_vertex_attribs(){const t=this.glenv.context,o=this._program,e=[],r=t.getProgramParameter(o,t.ACTIVE_ATTRIBUTES);for(let i=0;i<r;++i){const r=t.getActiveAttrib(o,i),n={name:r.name,location:t.getAttribLocation(o,r.name)};e.push(n);}return e}_create_uniform_location(){const t=this.glenv.context,o=this._program,e={},r=t.getProgramParameter(o,t.ACTIVE_UNIFORMS);for(let i=0;i<r;++i){const r=t.getActiveUniform(o,i),n=t.getUniformLocation(o,r.name);e[r.name]=n;}return e}_setRenderId(t){this.setVector4("u_rid",[(t>>12&15)/15,(t>>8&15)/15,(t>>4&15)/15,(15&t)/15]);}dispose(){this.glenv.context.deleteProgram(this._program),this._program=null;}bindProgram(){this.glenv.context.useProgram(this._program);}setBoolean(t,o){const e=this._uniform_location[t];if(void 0!==e){this.glenv.context.uniform1i(e,o?1:0);}}setInteger(t,o){const e=this._uniform_location[t];if(void 0!==e){this.glenv.context.uniform1i(e,o);}}setIntegerArray(t,o){const e=this._uniform_location[t];if(void 0!==e){this.glenv.context.uniform1iv(e,o);}}setIVector3(t,o){const e=this._uniform_location[t];if(void 0!==e){this.glenv.context.uniform3iv(e,o);}}setIVector3Array(t,o){const e=this._uniform_location[t];if(void 0!==e){this.glenv.context.uniform3iv(e,o);}}setFloat(t,o){const e=this._uniform_location[t];if(void 0!==e){this.glenv.context.uniform1f(e,o);}}setVector2(t,e){const i=this._uniform_location[t];if(void 0!==i){const t=this.glenv.context;e instanceof Float64Array?(e$z.copyVector2(e,r$m),t.uniform2fv(i,r$m)):t.uniform2fv(i,e);}}setVector2Array(t,o){const e=this._uniform_location[t];if(void 0!==e){this.glenv.context.uniform2fv(e,o);}}setVector3(t,e){const r=this._uniform_location[t];if(void 0!==r){const t=this.glenv.context;e instanceof Float64Array?(e$z.copyVector3(e,i$k),t.uniform3fv(r,i$k)):t.uniform3fv(r,e);}}setVector4(t,e){const r=this._uniform_location[t];if(void 0!==r){const t=this.glenv.context;e instanceof Float64Array?(e$z.copyVector4(e,n$V),t.uniform4fv(r,n$V)):t.uniform4fv(r,e);}}setMatrix(t,e){const r=this._uniform_location[t];if(void 0!==r){const t=this.glenv.context;e instanceof Float64Array?(e$z.copyMatrix(e,s$l),t.uniformMatrix4fv(r,!1,s$l)):t.uniformMatrix4fv(r,!1,e);}}bindVertexAttribs(t){const o=this.glenv.context,e=this._vertex_attribs,r=e.length;for(let i=0;i<r;++i){const r=e[i],n=t[r.name],s=r.location;void 0!==n?(o.bindBuffer(o.ARRAY_BUFFER,n.buffer),o.enableVertexAttribArray(s),o.vertexAttribPointer(s,n.num_components,n.component_type,n.normalized,n.byte_stride,n.byte_offset)):o.disableVertexAttribArray(s);}}bindTexture2D(t,o){const e=this.glenv.context;e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,o);}}const r$m=new Float32Array(2),i$k=new Float32Array(3),n$V=new Float32Array(4),s$l=new Float32Array(16);

class r$l extends e$o{constructor(t,r,a){super(t.glenv,r,a),this._flake_to_clip=e$z.createMatrixf();}numDrawings(){return 1}isWireframe(){return !1}setFlakeParameter(t,e,r,a){return !1}setCommonParameter(t,e){e.mul_flake_to_gocs(t.gocs_to_clip,this._flake_to_clip),this.setMatrix("u_obj_to_clip",this._flake_to_clip);}}

var n$U="/**\n * Modified from GPU Gems 2 (https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html)\n * Includes the following third-party code.\n *\n * s_p_oneil@hotmail.com\n * Copyright (c) 2000, Sean O'Neil\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of this project nor the names of its contributors\n *   may be used to endorse or promote products derived from this software\n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nattribute vec4 a_position;         // 位置 (地表断片座標系)\nattribute vec2 a_uv;               // uv 座標\n\nuniform mat4  u_obj_to_clip;       // 地表断片座標系からクリップ座標系への変換\n\nuniform vec4  u_texcoord_rect_hi;  // 高レベル画像 左下座標: (x, y), 座標サイズ: (z, w)\nuniform vec4  u_texcoord_rect_lo;  // 低レベル画像 左下座標: (x, y), 座標サイズ: (z, w)\nuniform vec4  u_corner_lod;        // uv = (0,0), (1,0), (0,1), (1,1) の LOD\n\n#ifdef NIGHTIMAGE\n    uniform mat4  u_obj_to_gocs;       // 地表断片座標系からGOCS座標系への変換\n    uniform float u_opacity;           // 不透明度\n    uniform vec3  u_sun_direction;     // 太陽方向\n\n    varying float v_opacity;           // 不透明度(太陽方向による処理)\n#elif defined(ATMOSPHERE)\n    uniform mat4  u_obj_to_gocs;       // 地表断片座標系からGOCS座標系への変換\n    uniform vec3  u_sun_direction;     // 太陽方向\n    uniform vec3  u_camera_position;   // The camera's current position\n    uniform float u_camera_height;     // The camera's current height\n    uniform float u_camera_height2;    // The camera's current height^2\n\n    uniform float u_kr;                 // Kr\n    uniform float u_km;                 // Km\n    uniform float u_scale_depth;        // scale_depth\n    uniform float u_esun;               // Kr\n\n    varying vec4  v_color;\n    varying vec4  v_secondary_color;\n#endif\n\nvarying vec2  v_texcoord_hi;       // 高レベル画像のテクスチャ座標\nvarying vec2  v_texcoord_lo;       // 低レベル画像のテクスチャ座標\nvarying float v_lod;               // 補間された LOD\n\n#ifdef NIGHTIMAGE\n    float sigmoid( float a, float x )\n    {\n        return 1.0 / ( 1.0 + exp( -( a * x )) );\n    }\n#elif defined(ATMOSPHERE)\n    const float loop_float = 2.0;         // loop\n    const int   loop_int   = 2;           // loop\n\n    const float planet_radius = 6378137.0;\n    const float atmosphere_radius = planet_radius * 1.025;\n\n    const float PI = 3.14159265358932384626;\n\n    const vec3 inv_wave_length = vec3( 5.60204474633241, 9.47328443792304, 19.64380261047720 );\n\n    const float outer_radius  = atmosphere_radius;                   // The outer (atmosphere) radius\n    const float outer_radius2 = atmosphere_radius*atmosphere_radius; // outer_radius^2\n    const float inner_radius  = planet_radius;                       // The inner (planetary) radius\n    const float inner_radius2 = planet_radius*planet_radius;         // inner_radius^2\n\n    float Kr_ESun = u_kr * u_esun;      // Kr * ESun\n    float Km_ESun = u_km * u_esun;      // Km * ESun\n    float Kr_4PI  = u_kr * 4.0 * PI;  // Kr * 4 * PI\n    float Km_4PI  = u_km * 4.0 * PI;  // Km * 4 * PI\n\n    const float radius_scale = 1.0 / ( atmosphere_radius - planet_radius );   // 1 / (outer_radius - inner_radius)\n    float scale_over_scale_depth = radius_scale / u_scale_depth;          // radius_scale / scale_depth\n\n    float scale( float angle )\n    {\n        float x = 1.0 - angle;\n        return u_scale_depth * exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * ( -6.80 + x * 5.25 ) ) ) );\n    }\n#endif\n\nvoid main()\n{\n    gl_Position = u_obj_to_clip * a_position;\n\n    // uv 座標をテクスチャ座標に変換\n    v_texcoord_hi = u_texcoord_rect_hi.xy + u_texcoord_rect_hi.zw * a_uv;\n    v_texcoord_lo = u_texcoord_rect_lo.xy + u_texcoord_rect_lo.zw * a_uv;\n\n    // LOD の補間\n    float u = a_uv.x;\n    float v = a_uv.y;\n\n    float lod_00 = u_corner_lod.x;  // uv = (0,0) の LOD\n    float lod_10 = u_corner_lod.y;  // uv = (1,0) の LOD\n    float lod_01 = u_corner_lod.z;  // uv = (0,1) の LOD\n    float lod_11 = u_corner_lod.w;  // uv = (1,1) の LOD\n\n    float lod_u0 = mix( lod_00, lod_10, u );  // uv = (u, 0) の LOD\n    float lod_u1 = mix( lod_01, lod_11, u );  // uv = (u, 1) の LOD\n    float lod_uv = mix( lod_u0, lod_u1, v );  // uv = (u, v) の LOD\n\n    v_lod = lod_uv;\n\n#ifdef NIGHTIMAGE\n    vec3 ground_vector = normalize( vec3( u_obj_to_gocs * a_position ) );\n    float dir = dot( ground_vector, u_sun_direction );\n    float sun_opacity = 1.0 - sigmoid( 5.0, dir );\n    v_opacity = sun_opacity * u_opacity;  // 不透明度を適用\n#elif defined(ATMOSPHERE)\n    vec3  vertex_position = vec3( u_obj_to_gocs * a_position );\n    vec3  ray             = vertex_position - u_camera_position;\n    float far_length      = length( ray );\n    ray /= far_length;\n\n    #ifdef FROMSPACE\n        float B           = 2.0 * dot( u_camera_position, ray );\n        float C           = u_camera_height2 - outer_radius2;\n        float det         = max( 0.0, B * B - 4.0 * C );\n        float near_length = 0.5 * ( -B - sqrt( det ) );\n\n        vec3 start_position = u_camera_position + ray * near_length;\n        far_length -= near_length;\n        float depth = exp( ( inner_radius - outer_radius ) / ( atmosphere_radius - planet_radius ));\n    #else\n        vec3 start_position = u_camera_position;\n        float depth = exp( ( inner_radius - u_camera_height ) / ( atmosphere_radius - planet_radius ));\n    #endif\n\n    float camera_angle  = dot( -ray, vertex_position ) / length( vertex_position );\n    float light_angle   = dot( u_sun_direction, vertex_position ) / length( vertex_position );\n    float camera_scale  = scale( camera_angle );\n    float light_scale   = scale( light_angle );\n    float camera_offset = depth * camera_scale;\n    float temp          = light_scale + camera_scale;\n\n    float sample_length = far_length / loop_float;\n    float scaled_length = sample_length * radius_scale;\n    vec3  sample_ray    = ray * sample_length;\n    vec3  sample_point  = start_position + sample_ray * 0.5;\n\n    vec3 front_color = vec3( 0.0, 0.0, 0.0 );\n    vec3 attenuate   = vec3( 0.0, 0.0, 0.0 );\n    for ( int i=0; i<loop_int; i++ )\n    {\n        float sample_height = length( sample_point );\n        float sample_depth  = exp( scale_over_scale_depth * ( inner_radius - sample_height ) );\n        float scatter = sample_depth * temp - camera_offset;\n        attenuate = exp( -scatter * ( inv_wave_length * Kr_4PI + Km_4PI ) );\n        front_color += attenuate * ( sample_depth * scaled_length );\n        sample_point += sample_ray;\n    }\n\n    v_color.rgb = front_color * ( inv_wave_length * Kr_ESun + Km_ESun );\n    v_secondary_color.rgb = attenuate;\n#endif\n}\n";

var o$n="precision mediump float;\n\nvarying vec2  v_texcoord_hi;    // 高レベル画像のテクスチャ座標\nvarying vec2  v_texcoord_lo;    // 低レベル画像のテクスチャ座標\nvarying float v_lod;            // 補間された LOD\n\n#ifdef NIGHTIMAGE\n    varying float v_opacity;           // 不透明度(太陽方向による処理)\n#elif defined(ATMOSPHERE)\n    uniform float u_opacity;           // 不透明度\n    uniform float u_exposure;          // Exposure\n    varying vec4  v_color;\n    varying vec4  v_secondary_color;\n#else\n    uniform float u_opacity;           // 不透明度\n#endif\n\nuniform sampler2D u_image_hi;   // 高レベル画像\nuniform sampler2D u_image_lo;   // 低レベル画像\n\n/** 画像パラメータ\n *\n *  x = u_image_lo の LOD\n *  y = 1 / (u_image_hi の LOD - x)\n *\n *  ただし u_image_hi と u_image_lo が同じ画像のときは y = 0\n */\nuniform vec2 u_image_param;\n\n\nvoid main()\n{\n    vec4 color_hi = texture2D( u_image_hi, v_texcoord_hi );\n    vec4 color_lo = texture2D( u_image_lo, v_texcoord_lo );\n\n    // 画像の混合率\n    float lo_lod = u_image_param.x;\n    float  delta = u_image_param.y;\n    float  ratio = clamp( (v_lod - lo_lod) * delta, 0.0, 1.0 );\n\n\n    // 不透明度を適用\n#ifdef NIGHTIMAGE\n    gl_FragColor = mix( color_lo, color_hi, ratio );\n    gl_FragColor.a *= v_opacity;\n#elif defined(ATMOSPHERE)\n    vec4 color            = mix( color_lo, color_hi, ratio );\n    vec4 atmosphere_color = v_color + color * v_secondary_color;\n\n    atmosphere_color   = 1.0 - exp( atmosphere_color * u_exposure );\n    atmosphere_color.a = 1.0;\n\n    gl_FragColor = atmosphere_color;\n    gl_FragColor.a *= u_opacity;\n#else\n    gl_FragColor = mix( color_lo, color_hi, ratio );\n    gl_FragColor.a *= u_opacity;\n#endif\n}\n";

var n$T="/**\n * マウスピック用ID描画シェーダ (フラグメントシェーダ)\n */\n\nprecision highp float;\nuniform vec4 u_rid; // rid\n\nvoid main()\n{\n    gl_FragColor = u_rid;\n}\n";

class t$t{constructor(){}status(t){return "@@_ImageProvider.Status.READY"}}!function(t){var a;t.Range=class{constructor(t,a){this._min=t,this._max=a;}get min(){return this._min}get max(){return this._max}},(a=t.Status||(t.Status={})).NOT_READY="@@_ImageProvider.Status.NOT_READY",a.READY="@@_ImageProvider.Status.READY",a.FAILED="@@_ImageProvider.Status.FAILED";}(t$t||(t$t={}));var a$g=t$t;

class r$k extends a$g{constructor(){super();}requestTile(e,r,t,s){}cancelRequest(){}getImageSize(){return 4096}getZoomLevelRange(){return new a$g.Range(0,0)}}

class t$s{constructor(t,e,s,i){this.z=t,this.x=e,this.y=s,this.texture=i;}dispose(t){t.deleteTexture(this.texture),this.texture=null;}}

class e$n{getResolutionPower(){return 8}}

class t$r extends e$n{constructor(e){var _,l,E;let r;super(),r=void 0===e?{}:"number"==typeof e?{max_level:e}:e,this._max_level=null!==(_=r.max_level)&&void 0!==_?_:9,this._buffers=[],this._rho=null!==(l=r.rho)&&void 0!==l?l:8;const i=t$r.HEADER_BYTES+s$k*this._num_samples(),o=null!==(E=r.height)&&void 0!==E?E:0;for(let e=0;e<=this._max_level;++e){const t=new ArrayBuffer(i);this._setTileData(t,e,o),this._buffers.push(t);}}requestTile(e,t,s,_){Promise.resolve().then((()=>{_(this._buffers[e]);}));}cancelRequest(){}getResolutionPower(){return this._rho}_setTileData(e,s,_){const l=new DataView(e);l.setUint8(t$r.OFFSET_QLEVEL_00,this._max_level-s),l.setUint8(t$r.OFFSET_QLEVEL_10,this._max_level-s),l.setUint8(t$r.OFFSET_QLEVEL_01,this._max_level-s),l.setUint8(t$r.OFFSET_QLEVEL_11,this._max_level-s),l.setFloat32(t$r.OFFSET_HMIN,_,!0),l.setFloat32(t$r.OFFSET_HMAX,_,!0);const E=this._setOmegaArray(l);this._setHeight(l,E,_);}_setOmegaArray(e){let s=t$r.OFFSET_ω;for(let l=0;l<3;++l){let E=1<<2*l;for(var _=0;_<E;++_)e.setFloat32(s,t$r.OMEGA_VALUE,!0),s+=4;}return s}_setHeight(e,t,_){let l=t;const E=this._num_samples();for(let t=0;t<E;++t)e.setFloat32(l,_,!0),l+=s$k;}_num_samples(){const e=1+(1<<this._rho);return e*e}}t$r.OFFSET_QLEVEL_00=0,t$r.OFFSET_QLEVEL_10=1,t$r.OFFSET_QLEVEL_01=2,t$r.OFFSET_QLEVEL_11=3,t$r.OFFSET_HMIN=4,t$r.OFFSET_HMAX=8,t$r.OFFSET_ω=12,t$r.HEADER_BYTES=96,t$r.OMEGA_VALUE=-99;const s$k=4;

class s$j{constructor(s,t,h){var i=Math.pow(2,s.z-1),_=1<<t;this._sx=i/Math.PI*_,this._sy=-this._sx,this._ox=(i-s.x)*_,this._oy=(i-s.y)*_,this._body=h,this._pitch=4*(_+1),this._max=_;}}

class a$f extends s$j{constructor(t,s,a){super(t,s,a);}sample(t,s){var a=this._sx*t+this._ox,e=Math.floor(a),r=e+1,h=this._sy*s+this._oy,m=Math.floor(h),o=m+1,i=a-e,l=h-m;return (this._sampleInt(e,m)*(1-i)+this._sampleInt(r,m)*i)*(1-l)+(this._sampleInt(e,o)*(1-i)+this._sampleInt(r,o)*i)*l}_sampleInt(t,a){var e=e$z.clamp(t,0,this._max),r=e$z.clamp(a,0,this._max),h=this._pitch*r+4*e;return this._body.getFloat32(h,!0)}}

class s$i extends s$j{constructor(t,s,r){super(t,s,r);}sample(t,s){var r=Math.round(this._sx*t+this._ox),o=Math.round(this._sy*s+this._oy),e=this._pitch*o+4*r;return this._body.getFloat32(e,!0)}}

class t$q{constructor(t,a){if(this._ρ=t,this._maps=[],t>=1){var r=this._create_first_map(a);this._maps.push(r);for(var e=r,s=-2;s>=-t;--s){var _=this._create_next_map(s,e);this._maps.push(_),e=_;}}}_create_first_map(t){for(var a=1<<this._ρ-1,r=new Float32Array(a*a),e=4*(2*a+1),s=a,_=0;_<a;++_)for(var o=2*_*e,l=_*s,i=0;i<a;++i){var h=t.getFloat32(o,!0),p=t.getFloat32(o+4,!0),F=t.getFloat32(o+8,!0),f=t.getFloat32(o+e,!0),g=t.getFloat32(o+e+4,!0),m=t.getFloat32(o+e+8,!0),v=t.getFloat32(o+2*e,!0),n=t.getFloat32(o+2*e+4,!0),c=t.getFloat32(o+2*(e+4),!0);r[l]=(h+2*p+F+2*f+4*g+2*m+v+2*n+c)/16,o+=8,l+=1;}return r}_create_next_map(t,a){for(var r=1<<this._ρ+t,e=new Float32Array(r*r),s=2*r,_=r,o=0;o<r;++o)for(var l=2*o*s,i=o*_,h=0;h<r;++h){var p=a[l],F=a[l+1],f=a[l+s],g=a[l+s+1];e[i]=(p+F+f+g)/4,l+=2,i+=1;}return e}sample(t,a,r){return this._maps[this._ρ-t-1][r*(1<<t)+a]}}

class r$j{constructor(t,e,i,s,h){this.z=t,this.x=e,this.y=i,this._ρ=s;var a=new DataView(h);this._qlevels=[a.getUint8(r$j.OFFSET_QLEVEL_00),a.getUint8(r$j.OFFSET_QLEVEL_10),a.getUint8(r$j.OFFSET_QLEVEL_01),a.getUint8(r$j.OFFSET_QLEVEL_11)],this.height_min=a.getFloat32(r$j.OFFSET_HMIN,!0),this.height_max=a.getFloat32(r$j.OFFSET_HMAX,!0),this._ω=this._createωArray(a),this._body=new DataView(h,r$j.HEADER_BYTES),this._size=1+(1<<s);}isLeaf(t,e,i){if(t>this.z)return 0==this.getQuadLevel(t,e,i);var s=this._qlevels;return 0==s[0]||0==s[1]||0==s[2]||0==s[3]}getQuadLevel(t,e,i){var s=Math.pow(2,this.z-t),r=Math.floor(2*((e+.5)*s-this.x)),h=Math.floor(2*((i+.5)*s-this.y));return this._qlevels[2*h+r]}getQuadLevelDirect(e,i){var s=Math.round(Math.pow(2,this.z+1)),r=e$z.clamp(Math.floor(e*s),0,s-1)%2,h=e$z.clamp(Math.floor(i*s),0,s-1)%2;return this._qlevels[2*h+r]}getHeights(t,e){var i=4*(e*this._size+t),s=4*this._size,h=r$j._getHeights_result;return h[0]=this._body.getFloat32(i,!0),h[1]=this._body.getFloat32(i+4,!0),h[2]=this._body.getFloat32(i+s,!0),h[3]=this._body.getFloat32(i+s+4,!0),h}getDivisionPowers(e,i,s,h){var a=e.z,_=this.z,o=e$z.LOG2PI-this._ρ+1,l=this._getComplexity(a,e.x,e.y),n=Math.min(_+this._ρ,Math.round(i+o+l))-a,E=r$j._getDivisionPowers_result;return E[0]=Math.max(s,n),E[1]=Math.max(h,n),E}newSampler(t){return new(t.z-this.z>this._ρ?a$f:s$i)(this,this._ρ,this._body)}newLinearSampler(){return new a$f(this,this._ρ,this._body)}newAvgHeightMaps(){return new t$q(this._ρ,this._body)}"_createωArray"(t){for(var e=[],i=0,s=0;s<3;++s){for(var h=1<<2*s,a=new Float32Array(h),_=0;_<h;++_)a[_]=t.getFloat32(r$j.OFFSET_ω+i,!0),i+=4;e.push(a);}return e}_getComplexity(t,e,i){var s,h,a=t-this.z,_=Math.round(Math.pow(2,a));a<=2?(s=e-_*this.x,h=i-_*this.y):(s=Math.floor(4*((e+.5)/_-this.x)),h=Math.floor(4*((i+.5)/_-this.y)));var o=Math.min(a,2),l=this._ω[o];return Math.min(l[h*(1<<o)+s],r$j.ω_limit)}}r$j.OFFSET_QLEVEL_00=0,r$j.OFFSET_QLEVEL_10=1,r$j.OFFSET_QLEVEL_01=2,r$j.OFFSET_QLEVEL_11=3,r$j.OFFSET_HMIN=4,r$j.OFFSET_HMAX=8,r$j.OFFSET_ω=12,r$j.HEADER_BYTES=96,r$j.ω_limit=6,r$j._getHeights_result=[0,0,0,0],r$j._getDivisionPowers_result=[0,0];

class a$e{constructor(){}static getCenter(a,h){switch(a.z){case 0:return function(a,h){const s=Math.PI,M=2*s,n=s-(a+1)*M,c=s-a*M,o=Math.exp(n),i=Math.exp(c),e=o*o,r=i*i,u=e$z.EARTH_RADIUS/2;return h[0]=0,h[1]=0,h[2]=2*u*(r/(r+1)-1/(e+1)),h}(a.y,h);case 1:return function(a,h,s){const M=Math.PI,n=M-(h+1)*M,c=M-h*M,o=a*M-M,i=(a+1)*M-M,e=Math.exp(n),r=Math.exp(c),u=e*e,p=r*r,x=e$z.EARTH_RADIUS/2,f=2*e/(u+1),A=2*r/(p+1);s[0]=0,s[1]=n+c<0?o+i<0?x*-A:x*A:o+i<0?x*-f:x*f;return s[2]=2*x*(p/(p+1)-1/(u+1)),s}(a.x,a.y,h);default:return function(a,h,s,M){var n=Math.PI,c=Math.pow(2,1-a)*n,o=n-(s+1)*c,i=n-s*c,e=h*c-n,r=(h+1)*c-n,u=Math.exp(o),p=Math.exp(i),x=u*u,f=p*p,A=e$z.EARTH_RADIUS/2,I=2*u/(x+1),R=2*p/(f+1);o+i<0?e+r<-n?(M[0]=A*(R*Math.cos(e)+I*Math.cos(r)),M[1]=A*(R*Math.sin(r)+I*Math.sin(e))):e+r<0?(M[0]=A*(I*Math.cos(e)+R*Math.cos(r)),M[1]=A*(R*Math.sin(e)+I*Math.sin(r))):e+r<n?(M[0]=A*(I*Math.cos(r)+R*Math.cos(e)),M[1]=A*(I*Math.sin(e)+R*Math.sin(r))):(M[0]=A*(R*Math.cos(r)+I*Math.cos(e)),M[1]=A*(I*Math.sin(r)+R*Math.sin(e))):e+r<-n?(M[0]=A*(I*Math.cos(e)+R*Math.cos(r)),M[1]=A*(I*Math.sin(r)+R*Math.sin(e))):e+r<0?(M[0]=A*(R*Math.cos(e)+I*Math.cos(r)),M[1]=A*(I*Math.sin(e)+R*Math.sin(r))):e+r<n?(M[0]=A*(R*Math.cos(r)+I*Math.cos(e)),M[1]=A*(R*Math.sin(e)+I*Math.sin(r))):(M[0]=A*(I*Math.cos(r)+R*Math.cos(e)),M[1]=A*(R*Math.sin(r)+I*Math.sin(e)));return M[2]=2*A*(f/(f+1)-1/(x+1)),M}(a.z,a.x,a.y,h)}}}

class i$j{constructor(e,t,i,_){const s=e.context;this._center=this._createCenter(t);const r=this._createVertices(s,t,i,_);this._vertices=r.vertices,this._num_vertices=r.num_vertices,this._num_quads_x=r.num_quads_x,this._num_quads_y=r.num_quads_y,this._vertex_attribs=this._getVertexAttribs(s),this._index_type=this._num_vertices<65536?s.UNSIGNED_SHORT:s.UNSIGNED_INT,this._indices=null,this._num_indices=0,this._wire_indices=null,this._num_wire_indices=0,this._gl=s;}_createCenter(i){return a$e.getCenter(i,e$z.createVector3())}_createVertices(e,t,i,_){const s=e.ARRAY_BUFFER,r=e.createBuffer(),n=this._createVerticesData(t,i,_);if(null===r)throw new Error("failed to gl.createBuffer");return e.bindBuffer(s,r),e.bufferData(s,n.array,e.STATIC_DRAW),e.bindBuffer(s,null),{vertices:r,num_vertices:n.num_vertices,num_quads_x:n.num_quads_x,num_quads_y:n.num_quads_y}}_createVerticesData(t,_,s){for(var r=Math.pow(2,1-t.z)*Math.PI,n=t.x*r-Math.PI,u=Math.PI-(t.y+1)*r,a=1<<_[0],c=1<<_[1],d=1/a,h=1/c,m=r/a,f=r/c,l=this._center,o=s.newSampler(t),E=(a+1)*(c+1),v=new Float32Array(i$j.VERTEX_SIZE*E),x=0,y=0,I=u;y<c+1;++y,I+=f)for(var q=Math.exp(I),A=q*q,T=(A-1)/(A+1),w=2*q/(A+1),R=0,b=n;R<a+1;++R,b+=m){var S=Math.sin(b),B=Math.cos(b),p=o.sample(b,I),F=e$z.EARTH_RADIUS+p,N=F*(w*B),g=F*(w*S),V=F*T;v[x++]=N-l[0],v[x++]=g-l[1],v[x++]=V-l[2],v[x++]=R*d,v[x++]=y*h;}return {array:v,num_vertices:E,num_quads_x:a,num_quads_y:c}}_getVertexAttribs(e){const t=e.FLOAT,_=i$j.VERTEX_BYTES;return {a_position:{buffer:this._vertices,num_components:3,component_type:t,normalized:!1,byte_stride:_,byte_offset:i$j.OFFSET_P},a_uv:{buffer:this._vertices,num_components:2,component_type:t,normalized:!1,byte_stride:_,byte_offset:i$j.OFFSET_UV}}}_createIndices(){for(var e=this._gl,t=6*(this._num_quads_x*this._num_quads_y),i=new(this._index_type===e.UNSIGNED_INT?Int32Array:Int16Array)(t),_=0,s=0;s<this._num_quads_y;++s)for(var r=0;r<this._num_quads_x;++r){var n=(this._num_quads_x+1)*s+r,u=n+1,a=n+this._num_quads_x+1,c=a+1;i[_++]=n,i[_++]=u,i[_++]=a,i[_++]=a,i[_++]=u,i[_++]=c;}var d=e.ELEMENT_ARRAY_BUFFER,h=e.createBuffer();e.bindBuffer(d,h),e.bufferData(d,i,e.STATIC_DRAW),e.bindBuffer(d,null),this._indices=h,this._num_indices=t;}_createWireIndices(){for(var e=this._gl,t=this._index_type===e.UNSIGNED_INT?Int32Array:Int16Array,i=2*(2*this._num_quads_x*this._num_quads_y+this._num_quads_x+this._num_quads_y),_=new t(i),s=0,r=0;r<this._num_quads_y+1;++r)for(var n=0;n<this._num_quads_x;++n){var u=(this._num_quads_x+1)*r+n,a=u+1;_[s++]=u,_[s++]=a;}for(n=0;n<this._num_quads_x+1;++n)for(r=0;r<this._num_quads_y;++r){var c=(this._num_quads_x+1)*r+n,d=c+this._num_quads_x+1;_[s++]=c,_[s++]=d;}var h=e.ELEMENT_ARRAY_BUFFER,m=e.createBuffer();e.bindBuffer(h,m),e.bufferData(h,_,e.STATIC_DRAW),e.bindBuffer(h,null),this._wire_indices=m,this._num_wire_indices=i;}get num_vertices(){return this._num_vertices}get indices(){return null===this._indices&&this._createIndices(),this._indices}get num_indices(){return null===this._indices&&this._createIndices(),this._num_indices}get wire_indices(){return null===this._wire_indices&&this._createWireIndices(),this._wire_indices}get num_wire_indices(){return null===this._wire_indices&&this._createWireIndices(),this._num_wire_indices}dispose(){var e=this._gl;this._vertex_attribs={},e.deleteBuffer(this._vertices),this._vertices=null,this._indices&&(e.deleteBuffer(this._indices),this._indices=null),this._wire_indices&&(e.deleteBuffer(this._wire_indices),this._wire_indices=null);}mul_flake_to_gocs(e,t){const i=e[0],_=e[4],s=e[8],r=e[12],n=e[1],u=e[5],a=e[9],c=e[13],d=e[2],h=e[6],m=e[10],f=e[14],l=e[3],o=e[7],E=e[11],v=e[15],x=this._center[0],y=this._center[1],I=this._center[2];return t[0]=i,t[1]=n,t[2]=d,t[3]=l,t[4]=_,t[5]=u,t[6]=h,t[7]=o,t[8]=s,t[9]=a,t[10]=m,t[11]=E,t[12]=i*x+_*y+s*I+r,t[13]=n*x+u*y+a*I+c,t[14]=d*x+h*y+m*I+f,t[15]=l*x+o*y+E*I+v,t}draw(e){var t=this._gl,i=e.isWireframe();e.bindVertexAttribs(this._vertex_attribs);var _=i?this.wire_indices:this.indices;t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,_);var s=i?t.LINES:t.TRIANGLES,r=i?this.num_wire_indices:this.num_indices;t.drawElements(s,r,this._index_type,0);}}i$j.VERTEX_SIZE=5,i$j.VERTEX_BYTES=4*i$j.VERTEX_SIZE,i$j.OFFSET_P=0,i$j.OFFSET_UV=12;

class s$h{constructor(t,s,r,e){this._glenv=t,this.mesh=s,this.material=r,this.transform=e,this.pivot=null,this.bbox=null,this.properties=null,this.sort_z=0;}fastClone(){const r=new s$h(this._glenv,this.mesh,this.material,e$z.createMatrix(this.transform));return this.pivot&&(r.pivot=e$z.createVector3(this.pivot)),this.bbox&&(r.bbox=this.bbox.map((s=>e$z.createVector3(s)))),r.properties=this.properties,r}isVisible(s){const o=e$m;e$z.mul_AA(s.gocs_to_view,this.transform,o);const n=this.bbox;if(n){!function(t,s){for(let r=0;r<2;++r){const e=t[r][2];for(let o=0;o<2;++o){const n=t[o][1];for(let a=0;a<2;++a){const h=t[a][0],c=i$i[a+2*o+4*r];c[0]=s[0]*h+s[4]*n+s[8]*e+s[12],c[1]=s[1]*h+s[5]*n+s[9]*e+s[13],c[2]=s[2]*h+s[6]*n+s[10]*e+s[14];}}}}(n,o);for(const t of s.getVolumePlanes())if(r$i(t))return !1}const a=this.pivot;return this.sort_z=a?o[2]*a[0]+o[6]*a[1]+o[10]*a[2]+o[14]:o[14],!0}isTranslucent(t){return this.material.isTranslucent(t,this)}draw(t){const s=this.material;s.bindProgram(),s.setParameters(t,this),this.mesh.draw(s);}}function r$i(t){for(const s of i$i){if(s[0]*t[0]+s[1]*t[1]+s[2]*t[2]+t[3]>=0)return !1}return !0}const e$m=e$z.createMatrix(),i$i=[];for(let s=0;s<8;++s)i$i.push(e$z.createVector3());

class s$g{constructor(t,e,r){this.z=t.z,this.x=t.x,this.y=t.y,this._glenv=e,this._base_mesh=r,this._edata_list=[],this._transform=null;}addEntityData(t,e){this._edata_list.push({mesh:t,producer:e});}get num_entities(){return this._edata_list.length}getBaseMesh(){return this._base_mesh}getEntityPrimitive(s,i){let a=this._edata_list[s],{material:h,properties:n}=a.producer.getMaterialAndProperties(i);if(null===this._transform){this._transform=e$z.setIdentity(e$z.createMatrix());let r=a$e.getCenter(this,e$z.createVector3());this._transform[12]=r[0],this._transform[13]=r[1],this._transform[14]=r[2];}const o=new s$h(this._glenv,a.mesh,h,this._transform);return o.properties=n,{entity:a.producer.getEntity(),primitive:o}}}

class t$p{constructor(){this._area_list=[],this._flat_area_list=null;}isEmpty(){return 0==this._area_list.length}clear(){this._area_list.length=0,this._flat_area_list=null;}addTileArea(t){this._area_list.push({z:t.z,x:t.x,y:t.y}),this._flat_area_list=null;}getFlatAreaList(){return null===this._flat_area_list&&(this._flat_area_list=this._createFlatAreaList()),this._flat_area_list}_createFlatAreaList(){for(var t=new e$l,r=0;r<this._area_list.length;++r){var l=this._area_list[r];t.addDescendant(l.z,l.x,l.y);}return t.reduceTree(),t.collectFlatAreas(0,new Uint8Array(64),[])}}class e$l{constructor(){this.present=!1,this.children=new Array(4).fill(null);}addDescendant(t,r,l){if(!0!==this.present)if(0==t)this.present=!0,this.children.fill(null);else {var a=Math.round(Math.pow(2,t-1)),s=Math.floor(r/a)+2*Math.floor(l/a);null===this.children[s]&&(this.children[s]=new e$l),this.children[s].addDescendant(t-1,r%a,l%a);}}reduceTree(){if(!0===this.present)return 1;for(var t=0,e=0;e<4;++e){var r=this.children[e];null!==r&&(t+=r.reduceTree());}return 4==t?(this.present=!0,this.children.fill(null),1):0}collectFlatAreas(t,e,r){if(!0===this.present)r.push(new Uint8Array(e.slice(0,t)));else for(var l=0;l<4;++l){var a=this.children[l];null!==a&&(e[t]=l,a.collectFlatAreas(t+1,e,r));}return r}}

class e$k{constructor(t,r,n){this._glenv=t;const a=t.context,T=e$k._getBindingPoint(a,null==n?void 0:n.target),i=a.createBuffer();if(null===i)throw new Error("Failed to create buffer");a.bindBuffer(T,i),a.bufferData(T,r,a.STATIC_DRAW),a.bindBuffer(T,null),this._handle=i;}get handle(){return this._handle}dispose(){this._glenv.context.deleteBuffer(this._handle),this._handle=null;}static _getBindingPoint(e,t="@@_Target.ATTRIBUTE"){switch(t){case"@@_Target.ATTRIBUTE":return e.ARRAY_BUFFER;case"@@_Target.INDEX":return e.ELEMENT_ARRAY_BUFFER}}}!function(e){var t;(t=e.Target||(e.Target={})).ATTRIBUTE="@@_Target.ATTRIBUTE",t.INDEX="@@_Target.INDEX";}(e$k||(e$k={}));var t$o=e$k;

class t$n{constructor(e,n){let r;this._glenv=e,r=n instanceof t$n.Initializer?n:new _$8(e,n).initializer;const{draw_mode:a,num_vertices:i,attrib_data:s,index_data:o}=this._initByInitializer(r);this._draw_mode=a,this._num_vertices=i,this._attrib_data=s,this._index_data=o;}_initByInitializer(e){const t=this._convertDrawMode(e.draw_mode),_=e.num_vertices,n={},r=e.attribute_data;for(const e of r)n[e.id]={mesh_buffer:e.buffer,buffer:e.buffer.handle,num_components:e.num_components,component_type:this._convertComponentType(e.component_type),normalized:e.normalized,byte_stride:e.byte_stride,byte_offset:e.byte_offset};let a=null;if(e.index_data){const t=e.index_data;a={mesh_buffer:t.buffer,buffer:t.buffer.handle,num_indices:t.num_indices,type:this._convertComponentType(t.type),byte_offset:t.byte_offset};}return {draw_mode:t,num_vertices:_,attrib_data:n,index_data:a}}_convertDrawMode(e){const t=this._glenv.context;switch(e){case"@@_POINTS":return t.POINTS;case"@@_LINES":return t.LINES;case"@@_TRIANGLES":return t.TRIANGLES;case"@@_LINE_LOOP":return t.LINE_LOOP;case"@@_LINE_STRIP":return t.LINE_STRIP;case"@@_TRIANGLE_STRIP":return t.TRIANGLE_STRIP;case"@@_TRIANGLE_FAN":return t.TRIANGLE_FAN;default:throw new Error("mapray: invalid Mesh.DrawMode: "+e)}}_convertComponentType(e){const t=this._glenv.context;switch(e){case"@@_BYTE":return t.BYTE;case"@@_UNSIGNED_BYTE":return t.UNSIGNED_BYTE;case"@@_SHORT":return t.SHORT;case"@@_UNSIGNED_SHORT":return t.UNSIGNED_SHORT;case"@@_UNSIGNED_INT":return t.UNSIGNED_INT;case"@@_FLOAT":return t.FLOAT;default:throw new Error("mapray: invalid Mesh.ComponentType: "+e)}}dispose(){this._attrib_data={},this._index_data=null;}draw(e){const t=this._glenv.context;e.bindVertexAttribs(this._attrib_data);const _=this._index_data;null!==_?(t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,_.buffer),t.drawElements(this._draw_mode,_.num_indices,_.type,_.byte_offset)):t.drawArrays(this._draw_mode,0,this._num_vertices);}get gl_draw_mode(){return this._draw_mode}}!function(e){var t,_;e.Initializer=class{constructor(e,t){this.draw_mode=e,this.num_vertices=t,this.attribute_data=[],this._index_data=null;}get index_data(){return this._index_data}addIndex(e,t,_,n){var r;this._index_data={buffer:e,num_indices:t,type:_,byte_offset:null!==(r=null==n?void 0:n.byte_offset)&&void 0!==r?r:0};}addAttribute(e,t,_,n,r){var a,i,s;const o={id:e,buffer:t,num_components:_,component_type:n,normalized:null!==(a=null==r?void 0:r.normalized)&&void 0!==a&&a,byte_stride:null!==(i=null==r?void 0:r.byte_stride)&&void 0!==i?i:0,byte_offset:null!==(s=null==r?void 0:r.byte_offset)&&void 0!==s?s:0};this.attribute_data.push(o);}},(t=e.DrawMode||(e.DrawMode={})).POINTS="@@_POINTS",t.LINES="@@_LINES",t.TRIANGLES="@@_TRIANGLES",t.LINE_LOOP="@@_LINE_LOOP",t.LINE_STRIP="@@_LINE_STRIP",t.TRIANGLE_STRIP="@@_TRIANGLE_STRIP",t.TRIANGLE_FAN="@@_TRIANGLE_FAN",(_=e.ComponentType||(e.ComponentType={})).BYTE="@@_BYTE",_.UNSIGNED_BYTE="@@_UNSIGNED_BYTE",_.SHORT="@@_SHORT",_.UNSIGNED_SHORT="@@_UNSIGNED_SHORT",_.UNSIGNED_INT="@@_UNSIGNED_INT",_.FLOAT="@@_FLOAT";}(t$n||(t$n={}));class _$8{constructor(r,a){const i=n$S.createVertexInfo(a.vtype),s=n$S.numVertexComponents(i),o=a.vertices.length/s;this._initializer=new t$n.Initializer(_$8._toDrawMode(a),o),a.indices&&this._addIndex(r,a.indices,o);const d=new t$o(r,n$S.toTypedArray(a.vertices,"@@_FLOAT")),N=4*s;let c=0;for(let e=0;e<i.length;++e){const t=i[e].size;this._initializer.addAttribute(i[e].name,d,t,"@@_FLOAT",{byte_stride:N,byte_offset:c}),c+=4*t;}}get initializer(){return this._initializer}_addIndex(t,_,r){const a=r<65536?"@@_UNSIGNED_SHORT":"@@_UNSIGNED_INT",i=new t$o(t,n$S.toTypedArray(_,a),{target:"@@_Target.INDEX"});this._initializer.addIndex(i,_.length,a);}static _toDrawMode(e){switch(e.ptype){case"triangles":default:return "@@_TRIANGLES";case"lines":return "@@_LINES";case"points":return "@@_POINTS"}}}class n$S{constructor(){}static createVertexInfo(e){if(Array.isArray(e))return e;let t=null;switch(e){case"P":case n$S.ENUM_VTYPE_P:t=[{name:n$S.ANAME_P,size:n$S.FSIZE_P}];break;case"PN":case n$S.ENUM_VTYPE_PN:t=[{name:n$S.ANAME_P,size:n$S.FSIZE_P},{name:n$S.ANAME_N,size:n$S.FSIZE_N}];break;case"PT":case n$S.ENUM_VTYPE_PT:t=[{name:n$S.ANAME_P,size:n$S.FSIZE_P},{name:n$S.ANAME_T,size:n$S.FSIZE_T}];break;case"PNT":case n$S.ENUM_VTYPE_PNT:t=[{name:n$S.ANAME_P,size:n$S.FSIZE_P},{name:n$S.ANAME_N,size:n$S.FSIZE_N},{name:n$S.ANAME_T,size:n$S.FSIZE_T}];break;default:throw new Error("mapray: unknown vtype: "+e)}return t}static numVertexComponents(e){let t=0;for(const _ of e)t+=_.size;return t}static toTypedArray(e,t){switch(t){case"@@_UNSIGNED_SHORT":return e instanceof Uint16Array?e:new Uint16Array(e);case"@@_UNSIGNED_INT":return e instanceof Uint32Array?e:new Uint32Array(e);case"@@_FLOAT":return e instanceof Float32Array?e:new Float32Array(e);default:throw new Error("mapray: invalid component type: "+t)}}}n$S.ENUM_VTYPE_P=0,n$S.ENUM_VTYPE_PN=1,n$S.ENUM_VTYPE_PT=2,n$S.ENUM_VTYPE_PNT=3,n$S.ANAME_P="a_position",n$S.ANAME_N="a_normal",n$S.ANAME_T="a_texcoord",n$S.FSIZE_P=3,n$S.FSIZE_N=3,n$S.FSIZE_T=2;var r$h=t$n;

class e$j{constructor(e){this._point_features=[],this._lines_features=[],this._polygon_features=[],this._setupFeatures(e);}get point_features(){return this._point_features}get linestring_features(){return this._lines_features}get polygon_features(){return this._polygon_features}hasFeature(){return this._point_features.length>0||this._lines_features.length>0||this._polygon_features.length>0}_setupFeatures(e){for(const t of e.features)switch(t.type){case 1:this._point_features.push(new n$R(t,e));break;case 2:this._lines_features.push(new c$8(t,e));break;case 3:this._polygon_features.push(new i$h(t,e));break;default:continue}}}var t$m;function r$g(e){return e>>>1^-(1&e)}!function(e){e[e.MoveTo=1]="MoveTo",e[e.LineTo=2]="LineTo",e[e.ClosePath=7]="ClosePath";}(t$m||(t$m={}));class s$f{constructor(e){this.num_vertices=e,this.vertices=new Float32Array(2*e);}}class o$m{constructor(e,t,r){this.type=e,this.id=t.id,this.properties={},this._setupProperties(t.tags,r.keys,r.values);}_setupProperties(e,t,r){for(let s=0;s<e.length;s+=2){const o=e[s],n=e[s+1],c=t[o],i=r[n];this.properties[c]=i;}}}class n$R extends o$m{constructor(e,t){super(1,e,t),this.points=n$R.create_geometry(e.geometry,1/t.extent);}static create_geometry(e,t){let o=0;const n=e[o++],c=n>>>3;if(1!==(7&n)||c<1)throw new Error("unexpected command");const i=new s$f(c),u=i.vertices;let a=0,h=0;for(let s=0;s<c;++s){const n=a+r$g(e[o++]),c=h+r$g(e[o++]);u[2*s]=n*t,u[2*s+1]=c*t,a=n,h=c;}return i}}class c$8 extends o$m{constructor(e,t){super(2,e,t),this.geom_parts=c$8.create_geometry(e.geometry,1/t.extent);}static create_geometry(e,t){const o=[];let n=0,c=0;if(0==e.length)throw new Error("empty LineStringFeature is unexpected");for(let i=0;i<e.length;){let u,a,h;{const s=e[i++],o=s>>>3;if(1!==(7&s)||1!==o)throw new Error("unexpected command");const h=n+r$g(e[i++]),p=c+r$g(e[i++]);u=h*t,a=p*t,n=h,c=p;}{const o=e[i++],p=o>>>3;if(2!==(7&o)||p<1)throw new Error("unexpected command");h=new s$f(1+p);const l=h.vertices;l[0]=u,l[1]=a;for(let s=0;s<p;++s){const o=n+r$g(e[i++]),u=c+r$g(e[i++]);l[2*s+2]=o*t,l[2*s+3]=u*t,n=o,c=u;}}o.push(h);}return o}}class i$h extends o$m{constructor(e,t){super(3,e,t),this.geom_parts=i$h.create_geometry(e.geometry,1/t.extent);}static create_geometry(e,t){const o=[];let n=0,c=0;if(0==e.length)throw new Error("empty PolygonFeature is unexpected");for(let i=0;i<e.length;){let u,a,h;{const s=e[i++],o=s>>>3;if(1!==(7&s)||1!==o)throw new Error("unexpected command");const h=n+r$g(e[i++]),p=c+r$g(e[i++]);u=h*t,a=p*t,n=h,c=p;}{const o=e[i++],p=o>>>3;if(2!==(7&o)||p<2)throw new Error("unexpected command");h=new s$f(1+p);const l=h.vertices;l[0]=u,l[1]=a;for(let s=0;s<p;++s){const o=n+r$g(e[i++]),u=c+r$g(e[i++]);l[2*s+2]=o*t,l[2*s+3]=u*t,n=o,c=u;}}{const t=e[i++],r=t>>>3;if(7!==(7&t)||1!==r)throw new Error("unexpected command")}o.push(h);}return o}}

var t$l,r$f;!function(t){t[t.Variant=0]="Variant",t[t.Bit_64=1]="Bit_64",t[t.LengthDelimited=2]="LengthDelimited",t[t.Bit_32=5]="Bit_32",t[t.Unknown=999]="Unknown";}(t$l||(t$l={})),function(t){t[t._29=536870912]="_29",t[t._32=4294967296]="_32",t[t._35=34359738368]="_35";}(r$f||(r$f={}));const e$i=new TextDecoder;class i$g{constructor(t,r,e){this._byte_array=new Uint8Array(t,r,e),this._data_view=new DataView(t,r,e),this._wire_type=999,this._cursor=0,this._end_of_msg=this._byte_array.byteLength,this._eom_stack=[];}isEndOfMessage(){return this._cursor>=this._end_of_msg}readKey(){const t=this.read_uint_variant();this._wire_type=7&t;return t>>>3}skipValue(){switch(this._wire_type){case 0:for(;this._byte_array[this._cursor++]>=128;);break;case 1:this._cursor+=8;break;case 2:this._cursor+=this.read_uint_variant();break;case 5:this._cursor+=4;break;default:throw new Error("unrecognized wire type: "+this._wire_type)}}enterEmbeddedMessage(){const t=this.read_uint_variant(),r=this._cursor+t,e=this._end_of_msg;this._end_of_msg=r,this._eom_stack.push(e);}leaveEmbeddedMessage(){if(!(this._eom_stack.length>0))throw new Error("not in the embedded message");this._cursor=this._end_of_msg,this._end_of_msg=this._eom_stack.pop();}readBoolValue(){return 0!=this.read_uint_variant()}readEnumValue(){return this.readInt32Value()}readUint32Value(){return this.read_uint_variant()}readUint64Value(){return this.read_uint_variant()}readSint32Value(){return this.read_sint_variant_zigzag()}readSint64Value(){return this.read_sint_variant_zigzag()}readInt32Value(){const[t]=this.read_uint_variant_pair();return 0|t}readInt64Value(){const[t,r]=this.read_uint_variant_pair();return r<268435456?34359738368*r+t:34359738368*r-0x10000000000000000+t}readFixed32Value(){const t=this._data_view.getUint32(this._cursor,!0);return this._cursor+=4,t}readFixed64Value(){const t=this._data_view.getUint32(this._cursor,!0);this._cursor+=4;const r=this._data_view.getUint32(this._cursor,!0);return this._cursor+=4,t+4294967296*r}readSfixed32Value(){const t=this._data_view.getInt32(this._cursor,!0);return this._cursor+=4,t}readSfixed64Value(){const t=this._data_view.getUint32(this._cursor,!0);this._cursor+=4;const r=this._data_view.getUint32(this._cursor,!0);return this._cursor+=4,r<2147483648?4294967296*r+t:4294967296*r-0x10000000000000000+t}readFloatValue(){const t=this._data_view.getFloat32(this._cursor,!0);return this._cursor+=4,t}readDoubleValue(){const t=this._data_view.getFloat64(this._cursor,!0);return this._cursor+=8,t}readStringValue(){const t=this.read_uint_variant(),r=this._byte_array.slice(this._cursor,this._cursor+t);return this._cursor+=t,e$i.decode(r)}readBytesValue(){const t=this.read_uint_variant(),r=this._byte_array.slice(this._cursor,this._cursor+t);return this._cursor+=t,r.buffer}readPackedRepeatedValue(t){const r=new Array,e=this.read_uint_variant(),i=this._cursor+e;for(;this._cursor<i;)r.push(t.call(this));if(this._cursor!=i)throw new Error("invalid packed repeated data");return r}read_uint_variant(){let t=0;for(let r=1;;r*=128){const e=this._byte_array[this._cursor++];if(t+=(127&e)*r,0==(128&e))return t}}read_sint_variant_zigzag(){const t=this._byte_array[this._cursor++],r=1&t?-1:1;let e=((126&t)>>>1)+(1&t);if(0==(128&t))return r*e;for(let t=64;;t*=128){const i=this._byte_array[this._cursor++];if(e+=(127&i)*t,0==(128&i))return r*e}}read_uint_variant_pair(){let t=0;for(let r=1;34359738368!=r;r*=128){const e=this._byte_array[this._cursor++];if(t+=(127&e)*r,0==(128&e))return [t,0]}let r=0;for(let e=1;;e*=128){const i=this._byte_array[this._cursor++];if(r+=(127&i)*e,0==(128&i))return [t,r]}}}

var a$d,t$k,s$e,r$e,n$Q;!function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.POINT=1]="POINT",e[e.LINESTRING=2]="LINESTRING",e[e.POLYGON=3]="POLYGON";}(a$d||(a$d={})),function(e){e[e.layers=3]="layers";}(t$k||(t$k={})),function(e){e[e.version=15]="version",e[e.name=1]="name",e[e.features=2]="features",e[e.keys=3]="keys",e[e.values=4]="values",e[e.extent=5]="extent";}(s$e||(s$e={})),function(e){e[e.string_value=1]="string_value",e[e.float_value=2]="float_value",e[e.double_value=3]="double_value",e[e.int_value=4]="int_value",e[e.uint_value=5]="uint_value",e[e.sint_value=6]="sint_value",e[e.bool_value=7]="bool_value";}(r$e||(r$e={})),function(e){e[e.id=1]="id",e[e.tags=2]="tags",e[e.type=3]="type",e[e.geometry=4]="geometry";}(n$Q||(n$Q={}));class i$f{}class u$8{constructor(a,t={}){const s=t.layer_filter||(()=>!0);this.layers=[],u$8.check_header(new Uint8Array(a,t.byteOffset,t.length));const r=new i$g(a,t.byteOffset,t.length);for(;!r.isEndOfMessage();){if(3===r.readKey()){r.enterEmbeddedMessage();try{this.layers.push(new l$9(r,s));}catch(e){if(!(e instanceof i$f))throw e}r.leaveEmbeddedMessage();}else r.skipValue();}}static check_header(e){if(e.byteLength>=2&&31==e[0]&&139==e[1])throw new Error("Does not support gzip compression")}}class l$9{constructor(e,a){for(this.version=1,this.name="",this.features=[],this.keys=[],this.values=[],this.extent=4096;!e.isEndOfMessage();){switch(e.readKey()){case 15:this.version=e.readUint32Value();break;case 1:if(this.name=e.readStringValue(),!a(this.name))throw new i$f;break;case 2:e.enterEmbeddedMessage(),this.features.push(new o$l(e)),e.leaveEmbeddedMessage();break;case 3:this.keys.push(e.readStringValue());break;case 4:e.enterEmbeddedMessage(),this.values.push(d$7(e)),e.leaveEmbeddedMessage();break;case 5:this.extent=e.readUint32Value();break;default:e.skipValue();}}}}class o$l{constructor(a){this.id=0,this.type=0;let t=[],s=[];for(;!a.isEndOfMessage();){switch(a.readKey()){case 1:this.id=a.readUint64Value();break;case 2:{const s=a.readPackedRepeatedValue(i$g.prototype.readUint32Value);t=t.concat(s);}break;case 3:this.type=a.readEnumValue();break;case 4:{const t=a.readPackedRepeatedValue(i$g.prototype.readUint32Value);s=s.concat(t);}break;default:a.skipValue();}}this.tags=Uint32Array.from(t),this.geometry=Uint32Array.from(s);}}function d$7(e){const a=e.readKey();switch(a){case 1:return e.readStringValue();case 2:return e.readFloatValue();case 3:return e.readDoubleValue();case 4:return e.readInt64Value();case 5:return e.readUint64Value();case 6:return e.readSint64Value();case 7:return e.readBoolValue();default:throw new Error("unknown field id="+a+" in vector_tile.Tile.Value")}}function c$7(e,a){return new u$8(e,a)}

class s$d{constructor(e,t){this._style_manager=e,this._source_states=new Map,this._layer_flakes=new Map,this.dem_sampler=t.newLinearSampler();}dispose(){for(const e of this._layer_flakes.values())e.dispose();this._layer_flakes.clear();}getPrimitives(e,t){const s=this.tryTileLayer(e,t);if(null===s)return [];if(t.zoom<e.__minzoom.evaluate(t)||t.zoom>=e.__maxzoom.evaluate(t))return [];return this.evaluateLayer(e,s,t).getPrimitives(t)}cancelRequest(){for(const e of this._source_states.values())e.cancelRequest();}evaluateLayer(e,t,s){let a=this._layer_flakes.get(e);return void 0===a?(a=e.__createLayerFlake(t,s),a.__createInitialLayerFeatures(s),a.completeInitialization(s),this._layer_flakes.set(e,a)):a.__evaluateFeatures(s),a}tryTileLayer(e,t){const s=e.__source_inst,l=this._source_states.get(s);if(void 0!==l)return l.getTileLayer(e.__source_layer)||null;if(this._canRequestTile()){const{promise:e,canceller:l}=s.tile_provider.requestTile(t);this._countTileRequested(1);const i=new a$c(s,l);this._source_states.set(s,i),e.then((e=>{"@@_CANCELLED"===i.tile_status?i.makeFail():i.loadTileLayers(e),this._countTileRequested(-1);})).catch((()=>{i.makeFail(),this._countTileRequested(-1);}));}return null}_canRequestTile(){return this._style_manager.__canRequestTile()}_countTileRequested(e){return this._style_manager.__countTileRequested(e)}}class a$c{constructor(e,t){this._source=e,this._tile_status="@@_REQUESTED",this._canceller=t,this._tile_layers=new Map;}get tile_status(){return this._tile_status}loadTileLayers(s){const a=c$7(s,{layer_filter:this._source.layer_filter});for(const t of a.layers)this._tile_layers.set(t.name,new e$j(t));this._tile_status="@@_EXISTENCE";}makeFail(){this._tile_status="@@_FAILED";}getTileLayer(e){return this._tile_layers.get(e)}cancelRequest(){"@@_REQUESTED"===this._tile_status&&null!==this._canceller&&(this._canceller(),this._canceller=null,this._tile_status="@@_CANCELLED");}}var l$8;!function(e){e.REQUESTED="@@_REQUESTED",e.CANCELLED="@@_CANCELLED",e.EXISTENCE="@@_EXISTENCE",e.FAILED="@@_FAILED";}(l$8||(l$8={}));

class n$P{constructor(t,s,_){var i,h,a;const r=s.getResolutionPower(),o=null==_?void 0:_.pole_info;this.glenv=t,this.dem_provider=s,this.npole_provider=new t$r({rho:r,height:null!==(i=null==o?void 0:o.north_height)&&void 0!==i?i:0}),this.spole_provider=new t$r({rho:r,height:null!==(h=null==o?void 0:o.south_height)&&void 0!==h?h:0}),this._status="@@_NOT_READY",this._num_ready_belts=0;const n=null!==(a=null==o?void 0:o.enabled)&&void 0!==a&&a;this._belt_lower_y=n?d$6:0,this._belt_upper_y=n?f$4:0,this._belts=[];for(let t=this._belt_lower_y;t<=this._belt_upper_y;++t)this._belts.push(new c$6(this,t));}_belt(t){return this._belts[t-this._belt_lower_y]}cancel(){for(let t of this._belts)t.cancel();}get status(){return this._status}get dem_area_updated(){return this._belt(0).dem_area_updated}get root_flake(){return this.getRootFlake(0)}getRootFlake(t){return this._belt(t).root_flake}getRootYRange(){return {lower:this._belt_lower_y,upper:this._belt_upper_y}}getElevationRange(){let t=Number.MAX_VALUE,e=-Number.MAX_VALUE;for(const s of this._belts)t=Math.min(s.root_flake.height_min,t),e=Math.max(s.root_flake.height_max,e);return {min:t,max:e}}putNextEntityProducers(t){return this._belt(0).putNextEntityProducers(t)}getNumDemWaitingRequests(){let t=0;for(const e of this._belts)t+=e.getNumDemWaitingRequests();return t}findHighestAccuracy(t,e){const s=Math.floor(e);return s<this._belt_lower_y||s>this._belt_upper_y?null:this._belt(s).findHighestAccuracy(t,e)}getExistingElevations(t,e,s,_,i,h,a){return this._belt(0).getExistingElevations(t,e,s,_,i,h,a)}findRayDistance(t,e){let s=e;for(const e of this._belts)s=e.root_flake.findRayDistance(t,s);return s}endFrame(){for(const t of this._belts)return t.endFrame()}updateStatus(t){"@@_NOT_READY"===this._status&&("@@_READY"===t?(++this._num_ready_belts,this._num_ready_belts===this._belts.length&&(this._status=t)):"@@_FAILED"===t&&(this._status=t));}setupDebugPickInfo(){for(const t of this._belts)return t.setupDebugPickInfo()}popDebugPickInfo(){return this._belt(0).popDebugPickInfo()}}class c$6{constructor(e,s){this.globe=e,this.glenv=e.glenv,this.belt_y=s,this.dem_provider=s>0?e.spole_provider:s<0?e.npole_provider:e.dem_provider,this._status="@@_NOT_READY",this._dem_area_updated=new t$p,this._prev_producers=new Set,this.rho=this.dem_provider.getResolutionPower(),this.dem_zbias=e$z.LOG2PI-this.rho+1,this._hist_stats=new m$a,this._flake_reduce_thresh=1.5,this._flake_reduce_factor=1.2,this._num_cache_flakes=0,this._num_touch_flakes=0,this._mesh_reduce_lower=300,this._mesh_reduce_thresh=1.5,this._mesh_reduce_factor=1.2,this._num_cache_meshes=0,this._num_touch_meshes=0,this._max_dem_requesteds=10,this._num_dem_requesteds=0,this._frame_counter=0,this._root_cancel_id=void 0,this._requestRoot();}cancel(){if("@@_READY"===this._status){for(const t of this._root_flake.children)null!==t&&t.dispose();this._root_flake.cancelStyleFlake();}else "@@_NOT_READY"===this._status&&(this.dem_provider.cancelRequest(this._root_cancel_id),this._root_cancel_id=void 0);}get dem_area_updated(){return this._dem_area_updated}get root_flake(){const t=this._root_flake;return t.touch(),t}get frame_counter(){return this._frame_counter}increment_touch_flakes(){++this._num_touch_flakes;}increment_cache_flakes(){++this._num_cache_flakes;}decrement_cache_flakes(){--this._num_cache_flakes;}increment_cache_meshes(){++this._num_cache_meshes;}decrement_cache_meshes(){--this._num_cache_meshes;}increment_touch_meshes(){++this._num_touch_meshes;}increment_dem_requesteds(){++this._num_dem_requesteds;}decrement_dem_requesteds(){--this._num_dem_requesteds;}is_reached_limit_dem_request(){return this._num_dem_requesteds>=this._max_dem_requesteds}get avg_height(){return this._avg_height}get debug_pick_info(){return this._debug_pick_info}putNextEntityProducers(t){let e=new Set,s=[],_=[];for(let i of t){let t=i.checkForUpdate();this._prev_producers.has(i)?(t&&_.push(i),this._prev_producers.delete(i)):s.push(i),e.add(i);}let i=this._prev_producers;for(let t of i)this._root_flake.removeEntityProducer(t);for(let t of s)this._root_flake.addEntityProducer(t);for(let t of _)this._root_flake.updateEntityProducer(t);this._prev_producers=e;}getNumDemWaitingRequests(){return this._num_dem_requesteds}findHighestAccuracy(e,s){var _=this._root_flake;if(!_)return null;for(var i=2,h=i*e,a=i*s,r=_;;){var o=e$z.clamp(Math.floor(h),0,i-1)%2,n=e$z.clamp(Math.floor(a),0,i-1)%2,c=_.children[o+2*n];if(_.touch(),!c)break;_.isDemState("@@_LOADED")&&(r=_),_=c,i*=2,h*=2,a*=2;}return r.requestHighestAccuracy(e,s),r.getDemBinary()}getExistingElevations(e,s,_,i,h,a,r){for(var o=2*Math.PI,n=1<<this.rho,c=_,m=a,l=0;l<e;++l){var u=s[c],d=s[c+1],f=u+180*Math.floor((90-d)/360+Math.floor((90+d)/360)),g=f-360-360*Math.floor((f-180)/360),p=90-Math.abs(90-d+360*Math.floor((90+d)/360)),y=g*e$z.DEGREE/o+.5,v=.5-e$z.invGudermannian(p*e$z.DEGREE)/o;if(v>=0&&v<=1){var x=this._findHighestAccuracy2(y,v);if(x){var M=Math.pow(2,x.z),E=n*(M*y-x.x),b=n*(M*v-x.y),D=e$z.clamp(Math.floor(E),0,n-1),k=e$z.clamp(Math.floor(b),0,n-1),A=x.getHeights(D,k),R=A[0],z=A[1],w=A[2],F=A[3],P=E-D,T=b-k;h[m]=(R*(1-P)+z*P)*(1-T)+(w*(1-P)+F*P)*T;}else h[m]=0;}else h[m]=0;c+=i,m+=r;}return h}_findHighestAccuracy2(e,s){var _=this._root_flake;if(!_)return null;for(var i=2,h=i*e,a=i*s,r=_;;){var o=e$z.clamp(Math.floor(h),0,i-1)%2,n=e$z.clamp(Math.floor(a),0,i-1)%2,c=_.children[o+2*n];if(!c)break;_.isDemState("@@_LOADED")&&(r=_),_=c,i*=2,h*=2,a*=2;}return r.getDemBinary()}endFrame(){var t=this._hist_stats.getMaxValue(this._num_touch_flakes);this._num_cache_flakes>this._flake_reduce_thresh*t&&this._reduceFlakes(t),this._num_cache_meshes>this._mesh_reduce_lower&&this._num_cache_meshes>this._mesh_reduce_thresh*this._num_touch_meshes&&this._reduceMeshes(),this._dem_area_updated.clear(),this._num_touch_flakes=0,this._num_touch_meshes=0,++this._frame_counter;}_requestRoot(){const t=this.belt_y;this._root_cancel_id=this.dem_provider.requestTile(0,0,t,(e=>{if(e){var _=new r$j(0,0,t,this.rho,e);this._avg_height=_.newAvgHeightMaps(),this._root_flake=new g$6(null,0,0,t),this._root_flake.setupRoot(this,_),this._status="@@_READY",this._dem_area_updated.addTileArea(_);}else this._status="@@_FAILED";this.globe.updateStatus(this._status),this._root_cancel_id=void 0,--this._num_dem_requesteds;})),++this._num_dem_requesteds;}_reduceFlakes(t){var e=this._root_flake.flattenFlakes();e.sort(((t,e)=>t.compareForReduce(e)));var s=Math.floor(this._flake_reduce_factor*t);e.slice(s).forEach((t=>t.dispose()));}_reduceMeshes(){var t=this._root_flake.flattenMeshes();t.sort(((t,e)=>t.compareForReduce(e)));var e=Math.floor(this._mesh_reduce_factor*this._num_touch_meshes);t.slice(e).forEach((t=>t.dispose()));}setupDebugPickInfo(){}popDebugPickInfo(){if(!this._debug_pick_info)return;const t=this._debug_pick_info;return this._debug_pick_info=void 0,t}}!function(e){var _;(_=e.Status||(e.Status={})).NOT_READY="@@_NOT_READY",_.READY="@@_READY",_.FAILED="@@_FAILED";class i{constructor(t,e,s,_){this.z=e,this.x=s,this.y=_,this._parent=t,this.children=[null,null,null,null],t&&(this.belt=t.belt),this._dem_data=null,this._dem_state="@@_NONE",this._entity_map=null,this._meshes=[],this._style_flake=null,this._prev_Za_dem=null,this._prev_Zr_dem=null,this._base_height=0,this._height_min=0,this._height_max=0,this._dem_zlimit=0,this._gocs_x_min=0,this._gocs_x_max=0,this._gocs_y_min=0,this._gocs_y_max=0,this._gocs_z_min=0,this._gocs_z_max=0,this._aframe=-1,this.belt&&this.belt.increment_cache_flakes();}get globe(){return this.belt.globe}getDemBinary(){return this._dem_data}isDemState(t){return this._dem_state===t}get base_height(){return this._base_height}get height_min(){return this._height_min}get height_max(){return this._height_max}setupRoot(t,e){this.belt=t,this._dem_data=e,this._dem_state="@@_LOADED",this._entity_map=new Map,this._estimate(),t.increment_cache_flakes();}newChild(t,e){var s=t+2*e,_=this.children[s];return _||(_=new i(this,this.z+1,2*this.x+t,2*this.y+e),this.children[s]=_),_._estimate(),_.touch(),_}getRenderObject(e){var s,_=Math.pow(2,-e)*i.ε;s=_<=2?Math.max(Math.ceil(e$z.LOG2PI-this.z-e$z.maprayLog2(Math.acos(1-_))),0):0;var h,a=this._getCosφ();h=_*a<=2?Math.max(Math.ceil(e$z.LOG2PI-this.z+e$z.maprayLog2(a/Math.acos(1-_*a))),0):0;var r=this._getMeshNode(e,s,h);return r.touch(),r.getRenderObject()}getEntityProducers(){return this._getEntityMap().keys()}addEntityProducer(t){switch(t.getAreaStatus(this)){case s$m.AreaStatus.PARTIAL:this._entity_map.set(t,!1);for(let e of this.children)e&&null!==e._entity_map&&e.addEntityProducer(t);break;case s$m.AreaStatus.FULL:this._addEntityFullProducer(t);}}_addEntityFullProducer(t){this._entity_map.set(t,!0);for(let e of this.children)e&&null!==e._entity_map&&e._addEntityFullProducer(t);}removeEntityProducer(t){if(this._entity_map.has(t)){this._entity_map.delete(t),this._removeEntityMeshes(t);for(let e of this.children)e&&null!==e._entity_map&&e.removeEntityProducer(t);}}updateEntityProducer(t){this.removeEntityProducer(t),this.addEntityProducer(t);}findRayDistance(t,e){let s;for(s=this;"@@_LOADED"!==s._dem_state;)s=s._parent;if(this.z-s.z===this.belt.rho)return this._findQuadRayDistance(t,e,s);if(this._cullForRayDistance(t,e))return e;{let s=e;for(let e=0;e<2;++e)for(let _=0;_<2;++_)s=this.newChild(_,e).findRayDistance(t,s);return s}}ensureStyleFlake(t){if(null!==this._style_flake)return this._style_flake;let e=this;for(;"@@_NONE"===e._dem_state;)e=e._parent;if("@@_FAILED"===e._dem_state||"@@_REQUESTED"===e._dem_state)return null;const s=e.getDemBinary();if(s.z===this.z)this._style_flake=new s$d(t,s);else {const e=s.getQuadLevel(this.z,this.x,this.y);if(e>0)return this._requestAncestorDemTile(Math.min(s.z+e,this.z)),null;this._style_flake=new s$d(t,s);}return this._style_flake}cancelStyleFlake(){null!==this._style_flake&&(this._style_flake.cancelRequest(),this._style_flake.dispose(),this._style_flake=null);}dispose(){var t,e=this._parent;if(!e)return;const s=this.belt;null!==this._style_flake&&(this._style_flake.dispose(),this._style_flake=null);for(var _=this._meshes;_.length>0;)_[0].dispose();var i=this.children;for(t=0;t<4;++t){var h=i[t];h&&h.dispose();}var a=e.children;for(t=0;t<4;++t)if(a[t]===this){a[t]=null;break}this._parent=null,"@@_REQUESTED"===this._dem_state&&(s.dem_provider.cancelRequest(this._dem_data),s.decrement_dem_requesteds()),this.cancelStyleFlake(),s.decrement_cache_flakes();}removeMeshNode(t){const e=this._meshes.length;for(let s=0;s<e;++s)if(this._meshes[s]===t){this._meshes.splice(s,1);break}}flattenFlakes(){const t=[];return this._flattenFlakes(t),t}flattenMeshes(){const t=[];return this._flattenMeshes(t),t}compareForReduce(t){var e=t,s=e._aframe-this._aframe;return 0!==s?s:this.z-e.z}_flattenFlakes(t){t.push(this);for(var e=this.children,s=0;s<4;++s){var _=e[s];_&&_._flattenFlakes(t);}}_flattenMeshes(t){Array.prototype.push.apply(t,this._meshes);for(var e=this.children,s=0;s<4;++s){var _=e[s];_&&_._flattenMeshes(t);}}touch(){const t=this.belt;this._aframe!==t.frame_counter&&(this._aframe=t.frame_counter,t.increment_touch_flakes());}_getMeshNode(t,e,s){for(var _=this._getMeshDemBinary(t),i=_.getDivisionPowers(this,t,e,s),h=this._meshes,a=h.length,r=0;r<a;++r){var o=h[r];if(o.match(_,i))return o}var n=new l$7(this,_,i);return h.unshift(n),n}_getMeshDemBinary(e){var s=e$z.clamp(Math.round(e+this.belt.dem_zbias),0,this._dem_zlimit),_=this._findNearestDemTile(s);if(_.z<s){var i=_.getQuadLevel(this.z,this.x,this.y);i>0&&this._requestAncestorDemTile(Math.min(_.z+i,s));}return _}_findNearestDemTile(t){let e=this;const s=this.z-t;for(let t=0;t<s;++t)e=e._parent;for(;"@@_LOADED"!==e._dem_state;)e=e._parent;return e._dem_data}_requestAncestorDemTile(t){const e=this.belt;if(!e.is_reached_limit_dem_request()){for(var _=this,i=this.z-t,h=0;h<i;++h)_=_._parent;for(;;){var a=_._dem_state;if("@@_LOADED"===a||"@@_REQUESTED"===a)break;if("@@_FAILED"!==a){var r=e.dem_provider;_._dem_data=r.requestTile(_.z,_.x,_.y,(t=>{_._parent&&(t?(_._dem_data=new r$j(_.z,_.x,_.y,e.rho,t),_._dem_state="@@_LOADED",e.dem_area_updated.addTileArea(_)):(_._dem_data=null,_._dem_state="@@_FAILED"),e.decrement_dem_requesteds());})),_._dem_state="@@_REQUESTED",e.increment_dem_requesteds();break}_=_._parent;}}}isInvisible(t){for(var e=this._gocs_x_min,s=this._gocs_x_max,_=this._gocs_y_min,i=this._gocs_y_max,h=this._gocs_z_min,a=this._gocs_z_max,r=0;r<t.length;++r){var o=t[r],n=o[0],c=o[1],m=o[2],l=o[3],u=n*e+c*_,d=n*s+c*_,f=n*e+c*i,g=n*s+c*i,p=-m*h-l,y=-m*a-l;if(u<p&&d<p&&f<p&&g<p&&u<y&&d<y&&f<y&&g<y)return !0}return !1}"_getCosφ"(){const t=this.z,e=this.y;if(0===t&&0===e)return 1;{const s=Math.pow(2,1-t),_=Math.abs(1-s*e),i=Math.abs(1-s*(e+1)),h=Math.exp(Math.PI*Math.min(_,i));return 2*h/(h*h+1)}}_estimate(){if(this._prev_Za_dem!==this){var t,e=this.z,s=this.belt.rho;if(e<s){if((t=this._findNearestDemTile(e))===this._prev_Zr_dem)return;this._prev_Zr_dem=t,this._estimate_low(t),this._dem_zlimit=e;}else {var _=this._findNearestDemTile(e-s);if(_.isLeaf(e,this.x,this.y))this._estimate_leaf(_);else {if(t=this._findNearestDemTile(_.z+s),_===this._prev_Za_dem&&t===this._prev_Zr_dem)return;this._prev_Za_dem=_,this._prev_Zr_dem=t,this._estimate_high(_,t);}this._dem_zlimit=_.z+s;}switch(e){case 0:this._updateBoundingBox_0();break;case 1:this._updateBoundingBox_1();break;default:this._updateBoundingBox_N();}}}_estimate_low(t){const e=this.z,s=this.x,_=this.y,h=this._calcAlpha(),a=_-(1<<e)*Math.floor(_/(1<<e));this._base_height=this.belt.avg_height.sample(e,s,a),this._height_min=Math.max(this._base_height+h*i.Fm,t.height_min),this._height_max=Math.min(this._base_height+h*i.Fp,t.height_max),(t.z==e||t.isLeaf(e,s,_))&&(this._prev_Za_dem=this);}_estimate_high(t,e){const s=this.belt;var _=this.z,h=this.x,a=this.y,r=t.z,o=t.x,n=t.y,c=s.rho,m=Math.pow(2,r-_),l=1<<c,u=Math.floor(l*((h+.5)*m-o)),d=Math.floor(l*((a+.5)*m-n)),f=l*(h*m-o)-u,g=l*((h+1)*m-o)-u,p=l*(a*m-n)-d,y=l*((a+1)*m-n)-d,v=t.getHeights(u,d),x=v[0],M=v[1],E=v[2],b=v[3],D=(x*(1-f)+M*f)*(1-p)+(E*(1-f)+b*f)*p,k=(x*(1-g)+M*g)*(1-p)+(E*(1-g)+b*g)*p,A=(x*(1-f)+M*f)*(1-y)+(E*(1-f)+b*f)*y,R=(x*(1-g)+M*g)*(1-y)+(E*(1-g)+b*g)*y,z=this._calcAlpha();if(this._base_height=.25*(D+k+A+R),this._height_min=Math.max(this._base_height+z*i.Fm,e.height_min),this._height_max=Math.min(this._base_height+z*i.Fp,e.height_max),r<_-c){var w=t.getQuadLevel(_,h,a);this._requestAncestorDemTile(Math.min(r+w,_-c));}else (e.z==_||e.isLeaf(_,h,a))&&(this._prev_Za_dem=this);}_estimate_leaf(t){var e=this.z,s=this.x,_=this.y,i=t.z,h=t.x,a=t.y,r=Math.pow(2,i-e),o=1<<this.belt.rho,n=Math.floor(o*((s+.5)*r-h)),c=Math.floor(o*((_+.5)*r-a)),m=o*(s*r-h)-n,l=o*((s+1)*r-h)-n,u=o*(_*r-a)-c,d=o*((_+1)*r-a)-c,f=t.getHeights(n,c),g=f[0],p=f[1],y=f[2],v=f[3],x=(g*(1-m)+p*m)*(1-u)+(y*(1-m)+v*m)*u,M=(g*(1-l)+p*l)*(1-u)+(y*(1-l)+v*l)*u,E=(g*(1-m)+p*m)*(1-d)+(y*(1-m)+v*m)*d,b=(g*(1-l)+p*l)*(1-d)+(y*(1-l)+v*l)*d;this._base_height=.25*(x+M+E+b),this._height_min=Math.min(x,M,E,b),this._height_max=Math.max(x,M,E,b),this._prev_Za_dem=this;}_calcAlpha(){var t=Math.pow(2,1-this.z);return t*i.πr/Math.cosh((1-t*(this.y+.5))*Math.PI)}_updateBoundingBox_0(){const e=Math.PI,s=2*e,_=e-(this.y+1)*s,i=e-this.y*s,h=Math.exp(_),a=Math.exp(i),r=h*h,o=a*a,n=2*h/(r+1),c=2*a/(o+1),m=(r-1)/(r+1),l=(o-1)/(o+1),u=e$z.EARTH_RADIUS+this._height_min,d=e$z.EARTH_RADIUS+this._height_max;this.y<0?(this._gocs_x_min=-d*n,this._gocs_x_max=d*n,this._gocs_y_min=-d*n,this._gocs_y_max=d*n,this._gocs_z_min=u*m,this._gocs_z_max=d*l):this.y>0?(this._gocs_x_min=-d*c,this._gocs_x_max=d*c,this._gocs_y_min=-d*c,this._gocs_y_max=d*c,this._gocs_z_min=d*m,this._gocs_z_max=u*l):(this._gocs_x_min=-d,this._gocs_x_max=d,this._gocs_y_min=-d,this._gocs_y_max=d,this._gocs_z_min=d*m,this._gocs_z_max=d*l);}_updateBoundingBox_1(){const e=Math.PI,s=e,_=e-(this.y+1)*s,i=e-this.y*s,h=Math.exp(_),a=Math.exp(i),r=h*h,o=a*a,n=2*h/(r+1),c=2*a/(o+1),m=(r-1)/(r+1),l=(o-1)/(o+1),u=e$z.EARTH_RADIUS+this._height_min,d=e$z.EARTH_RADIUS+this._height_max;_+i<0?(0===this.x?(this._gocs_x_min=-d*c,this._gocs_x_max=d*c,this._gocs_y_min=-d*c,this._gocs_y_max=0):(this._gocs_x_min=-d*c,this._gocs_x_max=d*c,this._gocs_y_min=0,this._gocs_y_max=d*c),this._gocs_z_min=d*m,this._gocs_z_max=u*l):(0===this.x?(this._gocs_x_min=-d*n,this._gocs_x_max=d*n,this._gocs_y_min=-d*n,this._gocs_y_max=0):(this._gocs_x_min=-d*n,this._gocs_x_max=d*n,this._gocs_y_min=0,this._gocs_y_max=d*n),this._gocs_z_min=u*m,this._gocs_z_max=d*l);}_updateBoundingBox_N(){var e=Math.PI,s=this.z,_=this.x,i=this.y,h=Math.pow(2,1-s)*e,a=e-(i+1)*h,r=e-i*h,o=_*h-e,n=(_+1)*h-e,c=Math.exp(a),m=Math.exp(r),l=c*c,u=m*m,d=e$z.EARTH_RADIUS+this._height_min,f=e$z.EARTH_RADIUS+this._height_max,g=2*c/(l+1),p=2*m/(u+1);a+r<0?(o+n<-e?(this._gocs_x_min=f*p*Math.cos(o),this._gocs_x_max=d*g*Math.cos(n),this._gocs_y_min=f*p*Math.sin(n),this._gocs_y_max=d*g*Math.sin(o)):o+n<0?(this._gocs_x_min=d*g*Math.cos(o),this._gocs_x_max=f*p*Math.cos(n),this._gocs_y_min=f*p*Math.sin(o),this._gocs_y_max=d*g*Math.sin(n)):o+n<e?(this._gocs_x_min=d*g*Math.cos(n),this._gocs_x_max=f*p*Math.cos(o),this._gocs_y_min=d*g*Math.sin(o),this._gocs_y_max=f*p*Math.sin(n)):(this._gocs_x_min=f*p*Math.cos(n),this._gocs_x_max=d*g*Math.cos(o),this._gocs_y_min=d*g*Math.sin(n),this._gocs_y_max=f*p*Math.sin(o)),this._gocs_z_min=f*(l-1)/(l+1),this._gocs_z_max=d*(u-1)/(u+1)):(o+n<-e?(this._gocs_x_min=f*g*Math.cos(o),this._gocs_x_max=d*p*Math.cos(n),this._gocs_y_min=f*g*Math.sin(n),this._gocs_y_max=d*p*Math.sin(o)):o+n<0?(this._gocs_x_min=d*p*Math.cos(o),this._gocs_x_max=f*g*Math.cos(n),this._gocs_y_min=f*g*Math.sin(o),this._gocs_y_max=d*p*Math.sin(n)):o+n<e?(this._gocs_x_min=d*p*Math.cos(n),this._gocs_x_max=f*g*Math.cos(o),this._gocs_y_min=d*p*Math.sin(o),this._gocs_y_max=f*g*Math.sin(n)):(this._gocs_x_min=f*g*Math.cos(n),this._gocs_x_max=d*p*Math.cos(o),this._gocs_y_min=d*p*Math.sin(n),this._gocs_y_max=f*g*Math.sin(o)),this._gocs_z_min=d*(l-1)/(l+1),this._gocs_z_max=f*(u-1)/(u+1));}requestHighestAccuracy(e,s){var _=this._dem_data.getQuadLevelDirect(e,s);if(0!=_){for(var i=this,h=Math.round(Math.pow(2,this.z+1)),a=h*e,r=h*s,o=0;o<_;++o){var n=e$z.clamp(Math.floor(a),0,h-1)%2,c=e$z.clamp(Math.floor(r),0,h-1)%2;i=i.newChild(n,c),h*=2,a*=2,r*=2;}i._requestAncestorDemTile(i.z);}}_findQuadRayDistance(t,e,s){var _=this._getQuadPositions(s,i._temp_positions),h=i._findTriRayDistance(t,e,_[0],_[2],_[1]);return h===e?i._findTriRayDistance(t,e,_[1],_[2],_[3]):h}static _findTriRayDistance(e,s,_,h,a){var r=e.direction,o=i._temp_ray_1;o[0]=h[0]-_[0],o[1]=h[1]-_[1],o[2]=h[2]-_[2];var n=i._temp_ray_2;n[0]=a[0]-_[0],n[1]=a[1]-_[1],n[2]=a[2]-_[2];var c=e$z.cross3(o,n,i._temp_ray_3),m=e$z.dot3(c,r);if(m<0){var l=e.position,u=i._temp_ray_4;u[0]=_[0]-l[0],u[1]=_[1]-l[1],u[2]=_[2]-l[2];var d=e$z.dot3(c,u)/m;if(d>=0&&d<s){var f=i._temp_ray_5;f[0]=l[0]+d*r[0],f[1]=l[1]+d*r[1],f[2]=l[2]+d*r[2];var g=i._temp_ray_6;g[0]=_[0]-f[0],g[1]=_[1]-f[1],g[2]=_[2]-f[2];var p=i._temp_ray_7;p[0]=h[0]-f[0],p[1]=h[1]-f[1],p[2]=h[2]-f[2];var y=i._temp_ray_8;if(y[0]=a[0]-f[0],y[1]=a[1]-f[1],y[2]=a[2]-f[2],e$z.dot3(e$z.cross3(g,p,i._temp_ray_9),c)>=0&&e$z.dot3(e$z.cross3(p,y,i._temp_ray_10),c)>=0&&e$z.dot3(e$z.cross3(y,g,i._temp_ray_11),c)>=0)return d}}return s}_getQuadPositions(e,s){for(var _=this.x,i=this.y,h=e.x,a=e.y,r=1<<this.belt.rho,o=e._dem_data.getHeights(_-r*h,i-r*a),n=Math.pow(2,1-this.z)*Math.PI,c=_*n-Math.PI,m=0,l=Math.PI-i*n;m<2;++m,l-=n)for(var u=Math.exp(l),d=u*u,f=(d-1)/(d+1),g=2*u/(d+1),p=0,y=c;p<2;++p,y+=n){var v=p+2*m,x=e$z.EARTH_RADIUS+o[v],M=Math.sin(y),E=Math.cos(y),b=s[v];b[0]=x*g*E,b[1]=x*g*M,b[2]=x*f;}return s}_cullForRayDistance(t,e){var s=t.position,_=s[0],i=s[1],h=s[2],a=this._gocs_x_min,r=this._gocs_x_max,o=this._gocs_y_min,n=this._gocs_y_max,c=this._gocs_z_min,m=this._gocs_z_max;if(a<=_&&_<=r&&o<=i&&i<=n&&c<=h&&h<=m)return !1;var l,u,d,f,g=t.direction,p=g[0],y=g[1],v=g[2];if(_<a&&p>0){if((l=(a-_)/p)<e&&(f=h+l*v,o<=(d=i+l*y)&&d<=n&&c<=f&&f<=m))return !1}else if(_>r&&p<0&&(l=(r-_)/p)<e&&(f=h+l*v,o<=(d=i+l*y)&&d<=n&&c<=f&&f<=m))return !1;if(i<o&&y>0){if((l=(o-i)/y)<e&&(f=h+l*v,a<=(u=_+l*p)&&u<=r&&c<=f&&f<=m))return !1}else if(i>n&&y<0&&(l=(n-i)/y)<e&&(f=h+l*v,a<=(u=_+l*p)&&u<=r&&c<=f&&f<=m))return !1;if(h<c&&v>0){if((l=(c-h)/v)<e&&(d=i+l*y,a<=(u=_+l*p)&&u<=r&&o<=d&&d<=n))return !1}else if(h>m&&v<0&&(l=(m-h)/v)<e&&(d=i+l*y,a<=(u=_+l*p)&&u<=r&&o<=d&&d<=n))return !1;return !0}_removeEntityMeshes(t){for(let e of this._meshes)e.removeEntityMesh(t);}_getEntityMap(){if(null===this._entity_map){let t=this._parent._getEntityMap(),e=new Map;for(let[s,_]of t)if(_)e.set(s,!0);else switch(s.getAreaStatus(this)){case s$m.AreaStatus.PARTIAL:e.set(s,!1);break;case s$m.AreaStatus.FULL:e.set(s,!0);}this._entity_map=e;}return this._entity_map}}i.ε=.0625,i.Fm=-2,i.Fp=2,i.πr=Math.PI*e$z.EARTH_RADIUS,i._temp_positions=[e$z.createVector3(),e$z.createVector3(),e$z.createVector3(),e$z.createVector3()],i._temp_ray_1=e$z.createVector3(),i._temp_ray_2=e$z.createVector3(),i._temp_ray_3=e$z.createVector3(),i._temp_ray_4=e$z.createVector3(),i._temp_ray_5=e$z.createVector3(),i._temp_ray_6=e$z.createVector3(),i._temp_ray_7=e$z.createVector3(),i._temp_ray_8=e$z.createVector3(),i._temp_ray_9=e$z.createVector3(),i._temp_ray_10=e$z.createVector3(),i._temp_ray_11=e$z.createVector3(),e.Flake=i;}(n$P||(n$P={}));class m$a{constructor(){this._history=[],this._max_value=0,this._hsize=200;}getMaxValue(t){var e=this._history,s=this._max_value;return e.length<this._hsize?t>s&&(this._max_value=t):t>=s?(this._max_value=t,e.shift()):e[0]<s?e.shift():(e.shift(),this._max_value=m$a._find_max(e)),e.push(t),this._max_value}static _find_max(t){let e=t[0];const s=t.length;for(let _=1;_<s;++_){const s=t[_];s>e&&(e=s);}return e}}class l$7{constructor(t,e,s){this._flake=t,this._dem=e,this._dpows=[...s],this._aframe=-1,this._base_mesh=new i$j(t.globe.glenv,t,s,e),this._entity_meshes=new Map,t.belt.increment_cache_meshes();}getRenderObject(){var t;let e=this._flake,s=new s$g(e,e.globe.glenv,this._base_mesh);for(let _ of e.getEntityProducers()){let i=this._getEntityMesh(_);"CACHED_EMPTY_MESH"!==i&&(void 0===i&&(i=null!==(t=_.createMesh(e,this._dpows,this._dem))&&void 0!==t?t:"CACHED_EMPTY_MESH",this._setEntityMesh(_,i),"CACHED_EMPTY_MESH"===i)||s.addEntityData(i,_));}return s}match(t,e){return this._dem===t&&this._dpows[0]===e[0]&&this._dpows[1]===e[1]}touch(){const t=this._flake.belt;this._aframe!==t.frame_counter&&(this._aframe=t.frame_counter,t.increment_touch_meshes());}dispose(){if(!this._base_mesh)return;const t=this._flake;t.removeMeshNode(this),this._base_mesh.dispose(),this._base_mesh=null;for(let t of this._entity_meshes.values())t instanceof r$h&&t.dispose();t.belt.decrement_cache_meshes();}compareForReduce(t){return t._aframe-this._aframe}removeEntityMesh(t){this._entity_meshes.delete(t);}_getEntityMesh(t){return this._entity_meshes.get(t)}_setEntityMesh(t,e){this._entity_meshes.set(t,e);}}var u$7;!function(t){t.NONE="@@_NONE",t.LOADED="@@_LOADED",t.REQUESTED="@@_REQUESTED",t.FAILED="@@_FAILED";}(u$7||(u$7={}));const d$6=-3,f$4=3,g$6=n$P.Flake;var p$1=n$P;

class o$k{constructor(e,t,s){var r,_,o;const u=null==s?void 0:s.pole_info;this.glenv=e,this.main_provider=t,this.npole_provider=new f$3(t,null!==(r=null==u?void 0:u.north_color)&&void 0!==r?r:n$O),this.spole_provider=new f$3(t,null!==(_=null==u?void 0:u.south_color)&&void 0!==_?_:l$6);const c=null!==(o=null==u?void 0:u.enabled)&&void 0!==o&&o;this._belt_lower_y=c?d$6:0,this._belt_upper_y=c?f$4:0,this._belts=[];for(let e=this._belt_lower_y;e<=this._belt_upper_y;++e)this._belts.push(new h$6(this,e));}_belt(e){return this._belts[e-this._belt_lower_y]}cancel(){for(const e of this._belts)e.cancel();}getImageZBias(){return this._belt(0).getImageZBias()}getImageZMin(){return this._belt(0).getImageZMin()}getNumWaitingRequests(){let e=0;for(const t of this._belts)e+=t.getNumWaitingRequests();return e}findNearestAncestors(e,t,s,r){const _=Math.round(Math.pow(2,e)),i=Math.floor(s/_);if(this._belt_lower_y<=i&&i<=this._belt_upper_y){return this._belt(i).findNearestAncestors(_,t,s,r)}return [null,null]}endFrame(){for(const e of this._belts)e.endFrame();}}const n$O=e$z.createVector3([.8,.8,.8]),l$6=e$z.createVector3([.8,.8,.8]);class h$6{constructor(e,s){const r=e.glenv;let _;_=s<0?e.npole_provider:s>0?e.spole_provider:e.main_provider,this._glenv=r,this._provider=new r$k,this._min_image_z=0,this._max_image_z=0,this._image_zbias=0;this._croot=new u$6,this._max_accesses=0,this._frame_counter=0,this._lower_bound=1,this._upper_bound=1.2,this._num_requesteds=0,this._max_requesteds=75,this._new_requesteds=[];const i=r.context,a=r.EXT_texture_filter_anisotropic;a?(this._aniso_ext=a,this._max_aniso=i.getParameter(a.MAX_TEXTURE_MAX_ANISOTROPY_EXT)):(this._aniso_ext=null,this._max_aniso=0),this._use_mipmap=!1;const o="@@_ImageProvider.Status.READY"===_.status((e=>{"@@_ImageProvider.Status.READY"===e?(this._flush(),this._resetImageProvider(_)):"@@_ImageProvider.Status.FAILED"===e&&console.error("ImageProvider.Status.FAILED in TileTextureCache");}));this._resetImageProvider(o?_:new r$k);}_resetImageProvider(e){this._provider=e;const s=e.getZoomLevelRange();this._min_image_z=s.min,this._max_image_z=s.max,this._image_zbias=e$z.maprayLog2(2*Math.PI/e.getImageSize()),this._provider instanceof r$k||(0===s.min?this.findNearestAncestors(1,0,0,1,100):1===s.min&&(this.findNearestAncestors(2,0,0,1,100),this.findNearestAncestors(2,0,1,1,100),this.findNearestAncestors(2,1,0,1,100),this.findNearestAncestors(2,1,1,1,100)));}cancel(){this._flush();}_flush(){new d$5(this,this._croot),this._croot=new u$6,this._max_accesses=0;}getImageZBias(){return this._image_zbias}getImageZMin(){return this._min_image_z}getNumWaitingRequests(){return this._num_requesteds}findNearestAncestors(e,t,s,_,i=-1){let a=0;const o=this._min_image_z;let n=0,l=Math.floor(s/e)*e,c=e/2,m=1/e,d=this._croot;for(;a<o;++a){const e=t<n+c?0:1,r=s<l+c?0:1,_=e+2*r,i=d.children;let a=i[_];null===a&&(a=new u$6,i[_]=a),n+=e*c,l+=r*c,c/=2,m*=2,d=a;}const E=this._max_image_z,f=e$z.clamp(_-1,o,E);let g=null,p=null;if(f<e$z.clamp(_,o,E)){for(;a<=f;++a){"@@_LOADED"===d.state?g=d:"@@_NONE"===d.state?(d.state="@@_REQUESTED",d.req_power=-1!==i?i:_-a,this._new_requesteds.push([d,a,Math.floor(t*m),Math.floor(s*m)])):"@@_REQUESTED"===d.state&&d.updateRequestPower(_-a);const e=t<n+c?0:1,r=s<l+c?0:1,o=e+2*r,h=d.children;let E=h[o];null===E&&(E=new u$6,h[o]=E),n+=e*c,l+=r*c,c/=2,m*=2,d=E;}p=g,"@@_LOADED"===d.state?p=d:"@@_NONE"===d.state?(d.state="@@_REQUESTED",d.req_power=-1!==i?i:_-a,this._new_requesteds.push([d,a,Math.floor(t*m),Math.floor(s*m)])):"@@_REQUESTED"===d.state&&d.updateRequestPower(_-a);}else for(;;++a){if("@@_LOADED"===d.state?g=d:"@@_NONE"===d.state?(d.state="@@_REQUESTED",d.req_power=-1!==i?i:_-a,this._new_requesteds.push([d,a,Math.floor(t*m),Math.floor(s*m)])):"@@_REQUESTED"===d.state&&d.updateRequestPower(_-a),a==f){p=g;break}const e=t<n+c?0:1,r=s<l+c?0:1,o=e+2*r,h=d.children;let E=h[o];null===E&&(E=new u$6,h[o]=E),n+=e*c,l+=r*c,c/=2,m*=2,d=E;}d.touch();const v=h$6._findNearestAncestors_result;return v[0]=null!==p?p.data:null,v[1]=null!==g?g.data:null,v}endFrame(){this._performNewRequests();const e=new c$5(this._croot,this._frame_counter);if(this._max_accesses=Math.max(e.num_accesses,this._max_accesses),e.num_loadeds>this._upper_bound*this._max_accesses){var t=Math.floor(this._lower_bound*this._max_accesses);this._reduceCache(t);}++this._frame_counter;}_performNewRequests(){const e=Math.min(this._max_requesteds-this._num_requesteds,this._new_requesteds.length);this._new_requesteds.sort((function(e,t){const s=e[0];return t[0].req_power-s.req_power}));var t=this;this._new_requesteds.slice(0,e).forEach((function(e){const[s,r,_,i]=e;t._requestTileTexture(r,_,i,s);})),this._new_requesteds.slice(e).forEach((function(e){e[0].state="@@_NONE";})),this._new_requesteds.length=0;}_requestTileTexture(e,t,r,_){_.data=this._provider.requestTile(e,t,r,(i=>{"@@_REQUESTED"===_.state&&(i?(_.data=new t$s(e,t,r,this._createTexture(i)),_.state="@@_LOADED"):(_.data=null,_.state="@@_FAILED"),--this._num_requesteds);})),++this._num_requesteds;}cancelTileTexture(e){this._provider.cancelRequest(e),--this._num_requesteds;}_createTexture(e){const t=this._glenv.context,s=this._aniso_ext,r=t.TEXTURE_2D,_=t.createTexture();if(null===_)throw new Error("failed to gl.createTexture()");return t.bindTexture(r,_),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),t.texImage2D(r,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!1),this._use_mipmap&&t.generateMipmap(r),t.texParameteri(r,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(r,t.TEXTURE_MIN_FILTER,this._use_mipmap?t.LINEAR_MIPMAP_LINEAR:t.LINEAR),t.texParameteri(r,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(r,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),s&&t.texParameterf(t.TEXTURE_2D,s.TEXTURE_MAX_ANISOTROPY_EXT,this._max_aniso),t.bindTexture(r,null),_}_reduceCache(e){const t=new m$9(this._croot);t.nodes.sort(((e,t)=>{const s=t.aframe-e.aframe;return 0==s&&"@@_LOADED"===e.state&&"@@_LOADED"===t.state?e.data.z-t.data.z:s}));const s=this._glenv.context,r=this._provider.getZoomLevelRange().min,_=r<=1?r:-1;t.nodes.slice(e).forEach((e=>{if("@@_LOADED"===e.state){if(e.data.z===_)return;e.data.dispose(s);}e.state="@@_NONE",e.data=null;})),t.clean();}}h$6._findNearestAncestors_result=[null,null];class u$6{constructor(){this.children=[null,null,null,null],this.state="@@_NONE",this.data=null,this.req_power=-1,this.aframe=-1;}updateRequestPower(e){e>this.req_power&&(this.req_power=e);}touch(){this.aframe=!0;}}class c$5{constructor(e,t){this.num_loadeds=0,this.num_accesses=0,this._frame=t,this._traverse(e);}_traverse(e){const t=e.children;let s=!0===e.aframe;for(let e=0;e<4;++e){const r=t[e];null!==r&&(s=this._traverse(r)||s);}return "@@_LOADED"===e.state&&(++this.num_loadeds,s&&++this.num_accesses),s&&(e.aframe=this._frame),s}}class m$9{constructor(e){this._root=e,this.nodes=[],this._traverse(e);}_traverse(e){const t=e.state;"@@_LOADED"!==t&&"@@_FAILED"!==t||this.nodes.push(e);const s=e.children;for(let e=0;e<4;++e){const t=s[e];null!==t&&this._traverse(t);}}clean(){this._clean_recur(this._root);}_clean_recur(e){let t="@@_NONE"===e.state;const s=e.children;for(let e=0;e<4;++e){const r=s[e];if(null!==r){const _=this._clean_recur(r);!0===_&&(s[e]=null),t=_&&t;}}return t}}class d$5{constructor(e,t){this._belt=e,this._traverse(t);}_traverse(e){const t=e.children;for(let e=0;e<4;++e){const s=t[e];null!==s&&this._traverse(s);}"@@_REQUESTED"===e.state&&(e.state="@@_NONE",this._belt.cancelTileTexture(e.data));}}var E$3;!function(e){e.NONE="@@_NONE",e.LOADED="@@_LOADED",e.REQUESTED="@@_REQUESTED",e.FAILED="@@_FAILED";}(E$3||(E$3={}));class f$3 extends a$g{constructor(e,t){super();const s=e$z.copyVector3(t,e$z.createVector3());this._status="@@_ImageProvider.Status.NOT_READY",this._status_callbacks=[],this._size=0,this._level=-1,this._image=f$3._createImage(1,s);const _=t=>{"@@_ImageProvider.Status.READY"===t?(this._size=e.getImageSize(),this._level=e.getZoomLevelRange().min,this._image=f$3._createImage(this._size,s)):"@@_ImageProvider.Status.FAILED"===t&&console.error("ImageProvider.Status.FAILED in PoleImageProvider"),this._status=t;for(const e of this._status_callbacks)e(t);this._status_callbacks.length=0;};"@@_ImageProvider.Status.READY"===e.status(_)&&Promise.resolve().then((()=>{_("@@_ImageProvider.Status.READY");}));}status(e){return "@@_ImageProvider.Status.NOT_READY"===this._status&&void 0!==e&&this._status_callbacks.push(e),this._status}requestTile(e,t,s,r){Promise.resolve().then((()=>{r(this._image);}));}cancelRequest(){}getImageSize(){return this._size}getZoomLevelRange(){return new a$g.Range(this._level,this._level)}static _createImage(e,t){const s=f$3._convertColorToRGB,r=r$t.createCanvasContext(e,e);return r.fillStyle=`rgb(${s(t[0])},${s(t[1])},${s(t[2])})`,r.fillRect(0,0,e,e),r.canvas}static _convertColorToRGB(e){return Math.round(255*e)}}

var n$N="attribute vec4 a_position;\nattribute vec2 a_uv;\n\nuniform mat4 u_obj_to_clip;\n\nvarying vec2 v_uv;\n\nvoid main()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    v_uv  = a_uv;\n}\n";

var v$2="precision mediump float;\n\nvarying vec2 v_uv;\n\nvoid main()\n{\n    vec4 color = (v_uv.x < 0.005 || v_uv.y < 0.005 || v_uv.x > 0.995 || v_uv.y > 0.995) ?\n                 vec4( 1, 1, 0, 1 ) : vec4( 0.5, 0.5, 0.5, 1 );\n    gl_FragColor = color;\n}\n";

class t$j extends r$l{constructor(r){super(r,n$N,v$2);}isWireframe(){return !0}setFlakeParameter(r,e,a,t){return this.setCommonParameter(r,a),!0}}

class s$c{constructor(_,h){var o,l;this._owner=_,this._glenv=_.glenv,this._viewer=_.viewer;var n=h instanceof a$g?{image_provider:h}:h;this._image_provider=n.image_provider,this._visibility=null===(o=n.visibility)||void 0===o||o,this._opacity=null!==(l=n.opacity)&&void 0!==l?l:1,this._type=n.type===s$c.LayerType.NIGHT?s$c.LayerType.NIGHT:s$c.LayerType.NORMAL,this._tile_cache=new o$k(this._glenv,this._image_provider,{pole_info:new x.PoleInfo(n.pole)});const y=this._viewer._render_cache||(this._viewer._render_cache={});this._type===s$c.LayerType.NIGHT?(y.surface_night_material||(y.surface_night_material=new _$6(this._viewer,{nightMaterial:!0})),this._material=y.surface_night_material):(y.surface_material||(y.surface_material=new _$6(this._viewer),y.wireframe_material=new t$j(this._viewer)),this._material=y.surface_material),this._image_provider.status((i=>{_.dirtyDrawingLayers();}));}get image_provider(){return this._image_provider}get visibility(){return this._visibility}get opacity(){return this._opacity}get type(){return this._type}get tile_cache(){return this._tile_cache}setImageProvider(i){this._image_provider!==i&&(this._owner.dirtyDrawingLayers(),i.status((i=>{this._owner.dirtyDrawingLayers();}))),this._image_provider=i,this._tile_cache.cancel(),this._tile_cache=new o$k(this._glenv,i);}setVisibility(i){this._visibility!=i&&this._owner.dirtyDrawingLayers(),this._visibility=i;}setOpacity(i){this._opacity=i;}getMateral(){return this._material}}!function(i){var e;(e=i.LayerType||(i.LayerType={}))[e.NORMAL=0]="NORMAL",e[e.NIGHT=1]="NIGHT";}(s$c||(s$c={}));var _$7=s$c;

class _$6 extends r$l{constructor(e,a={}){const o=_$6._getPreamble(a);super(e,o+n$U,o+(a.ridMaterial?n$T:o$n)),this.bindProgram(),this.setInteger("u_image_hi",_$6.TEXUNIT_IMAGE_HI),this.setInteger("u_image_lo",_$6.TEXUNIT_IMAGE_LO),a.ridMaterial&&this._setRenderId(1),this._viewer=e,this._tile_texture_cache=e.tile_texture_cache,this._dummy_tile_texture=this._createDummyTileTexture(e.glenv,[128,128,128,255]),this._image_zbias=0,this._flake_to_gocs=e$z.createMatrixf();}static _getPreamble(e){const t=!0===e.nightMaterial,r=!0===e.atmosphereFromSpaceMaterial,i=!0===e.atmosphereMaterial,s=[];return t&&s.push("#define NIGHTIMAGE"),(r||i)&&s.push("#define ATMOSPHERE"),r&&s.push("#define FROMSPACE"),s.join("\n")+"\n\n"}numDrawings(){return 1+this._viewer.layers.num_drawing_layers}setFlakeParameter(e,t,r,i){this.setCommonParameter(e,r);const s=this._getMaterialParameter(t,i);if(null!==s){const t=this._viewer.layers.getDrawingLayer(i-1);if(this.setVector4("u_corner_lod",s.corner_lod),this.setVector4("u_texcoord_rect_hi",s.image_hi.texcoord_rect),this.setVector4("u_texcoord_rect_lo",s.image_lo.texcoord_rect),this.setVector2("u_image_param",[s.image_lo.lod,s.image_hi.lod==s.image_lo.lod?0:1/(s.image_hi.lod-s.image_lo.lod)]),this.setFloat("u_opacity",0==i?1:t.opacity),i>0&&t.type===_$7.LayerType.NIGHT&&(this.setVector3("u_sun_direction",this._viewer.sun.sun_direction),r.mul_flake_to_gocs(o$j,this._flake_to_gocs),this.setMatrix("u_obj_to_gocs",this._flake_to_gocs)),0===i&&this._viewer.atmosphere){this.setVector3("u_sun_direction",this._viewer.sun.sun_direction),r.mul_flake_to_gocs(o$j,this._flake_to_gocs),this.setMatrix("u_obj_to_gocs",this._flake_to_gocs);const t=e.view_to_gocs;this.setVector3("u_camera_position",[t[12],t[13],t[14]]);const i=Math.sqrt(t[12]*t[12]+t[13]*t[13]+t[14]*t[14]);this.setFloat("u_camera_height",i),this.setFloat("u_camera_height2",i*i);const s=this._viewer.atmosphere.parameters;this.setFloat("u_kr",s.g_kr),this.setFloat("u_km",s.g_km),this.setFloat("u_scale_depth",s.g_scale_depth),this.setFloat("u_esun",s.g_esun),this.setFloat("u_exposure",s.g_exposure);}return this.bindTexture2D(_$6.TEXUNIT_IMAGE_HI,s.image_hi.texture),this.bindTexture2D(_$6.TEXUNIT_IMAGE_LO,s.image_lo.texture),!0}return !1}_getMaterialParameter(e,t){const r=0==t?this._tile_texture_cache:this._viewer.layers.getDrawingLayer(t-1).tile_cache;this._image_zbias=r.getImageZBias();const i=e.flake,s=i.z;if(s<r.getImageZMin())return null;const a=i.x,_=i.y,o=Math.ceil(e.lod+this._image_zbias);if(s<o)return null;const l=r.findNearestAncestors(s,a,_,o);return t>=1&&null===l[0]?null:{corner_lod:[e.lod_00,e.lod_10,e.lod_01,e.lod_11],image_hi:this._getImageParameter(l[0],s,a,_,o),image_lo:this._getImageParameter(l[1],s,a,_,o-1)}}_getImageParameter(e,t,r,i,s){if(null!==e){const s=Math.pow(2,e.z-t);return {lod:e.z-this._image_zbias,texture:e.texture,texcoord_rect:[r*s-e.x,1-(i+1)*s+e.y,s,s]}}{const e=Math.pow(2,-t);return {lod:-this._image_zbias,texture:this._dummy_tile_texture,texcoord_rect:[r*e-Math.floor(e*(r+.5)),1-(i+1)*e+Math.floor(e*(i+.5)),e,e]}}}_createDummyTileTexture(e,t){const r=e.context,i=r.TEXTURE_2D,s=r.createTexture();if(null===s)throw new Error("failed to createTexture()");return r.bindTexture(i,s),r.texImage2D(i,0,r.RGBA,1,1,0,r.RGBA,r.UNSIGNED_BYTE,new Uint8Array(t)),r.bindTexture(i,null),s}}_$6.TEXUNIT_IMAGE_HI=0,_$6.TEXUNIT_IMAGE_LO=1;const o$j=e$z.setIdentity(e$z.createMatrix());

var n$M="attribute vec4 a_position;\nattribute vec3 a_color;\n\nuniform mat4 u_obj_to_clip; // モデル座標系からクリップ座標系への変換\nuniform float u_point_size; // 点描画サイズ(負の場合は[m]、正の場合は[px])\n\nuniform float u_debug;      // デバッグ用パラメータ(正の場合のみ有効)\n\nvarying vec3 v_color;       // 色\n\n\nvoid main(void) {\n    gl_Position = u_obj_to_clip * a_position;\n\n    if ( u_point_size < 0.0 ) {\n        gl_PointSize = -u_point_size / gl_Position.w;\n    }\n    else {\n        gl_PointSize = u_point_size;\n    }\n\n    if ( u_debug < 0.0 ) {\n        v_color = a_color;\n    }\n    else {\n        float alpha = min( 1.0, u_debug );\n        v_color = vec3( alpha, 0.0, 1.0 - alpha );\n    }\n}\n";

var n$L="precision highp float;\n\n\nvarying vec3 v_color;       // 色\n\n\nvoid main(void) {\n#if POINT_SHAPE_TYPE == 0 // RECTANGLE\n    gl_FragColor = vec4( v_color,  1.0 );\n\n#elif POINT_SHAPE_TYPE == 1 // CIRCLE\n    if ( length( gl_PointCoord - 0.5 ) > 0.5 ) {\n        discard;\n    }\n    else {\n        gl_FragColor = vec4( v_color,  1.0 );\n    }\n\n#elif POINT_SHAPE_TYPE == 2 // CIRCLE_WITH_BORDER\n    float distance = length( gl_PointCoord - 0.5 );\n    if ( distance > 0.5 ) {\n        discard;\n    }\n    else if ( distance > 0.45 ) {\n        gl_FragColor = vec4( 0, 0, 0, 1.0 );\n    }\n    else {\n        gl_FragColor = vec4( v_color,  1.0 );\n    }\n\n#elif POINT_SHAPE_TYPE == 3 // GRADIENT_CIRCLE\n    vec2 p = 2.0 * gl_PointCoord - 1.0;\n    if ( length(p) > 1.0 ) {\n        discard;\n    }\n    else {\n        gl_FragColor = vec4( v_color * (1.0 - 0.3 * tan((p.x + p.y)*0.7853981633)),  1.0 );\n    }\n\n#endif\n}\n";

var o$i="attribute vec4 a_position;\n\nuniform mat4 u_obj_to_clip;\n\nvoid main(void) {\n    gl_Position = u_obj_to_clip * a_position;\n}\n";

var o$h="precision highp float;\n\nuniform vec3 u_color;\n\nvoid main(void) {\n    gl_FragColor = vec4(u_color, 1.0);\n}\n";

var o$g="attribute vec4 a_position;\n\nuniform mat4 u_obj_to_clip;\nvarying vec4 pos;\n\nvoid main(void) {\n    pos = gl_Position;\n    gl_Position = u_obj_to_clip * a_position;\n}\n";

var o$f="precision highp float;\n\nuniform vec4 u_color;\nvarying vec4 pos;\n\nvoid main(void) {\n    // gl_FragCoord.x, gl_FragCoord.y\n    if (mod(gl_FragCoord.x, 3.0) < 1.0 && mod(gl_FragCoord.y, 3.0) < 1.0) {\n        gl_FragColor = vec4(u_color.x, u_color.y, u_color.z, 1.0);\n    }\n    else {\n        discard;\n    }\n}\n";

var n$K="/**\n * 深度描画用シェーダ (頂点シェーダ)\n */\n\nattribute vec4 a_position;\nattribute float a_meta;\n\nuniform mat4 u_obj_to_clip; // モデル座標系からクリップ座標系への変換\nuniform float u_point_size; // 点描画サイズ(負の場合は[m]、正の場合は[px])\n\nvoid\nmain( void ) {\n    gl_Position = u_obj_to_clip * a_position;\n\n    if ( u_point_size < 0.0 ) {\n        gl_PointSize = -u_point_size / gl_Position.w;\n    }\n    else {\n        gl_PointSize = u_point_size;\n    }\n}\n";

var n$J="/**\n * 深度描画用シェーダ (fragment shader)\n */\n\nprecision highp float;\nuniform vec4 u_rid; // rid\n\nvoid main(void) {\n\n#if POINT_SHAPE_TYPE == 0 // RECTANGLE\n    gl_FragColor = u_rid;\n\n#elif POINT_SHAPE_TYPE > 0 // CIRCLE\n    if ( length( gl_PointCoord - 0.5 ) > 0.5 ) {\n        discard;\n    }\n    else {\n        gl_FragColor = u_rid;\n    }\n#endif\n}\n";

class h$5 extends e$o{constructor(t,e,i=n$M,_=n$L){const c=h$5._getPreamble(e);super(t.glenv,c+i,c+_),this.bindProgram(),this.setFloat("u_point_size",10),this.setFloat("u_debug",-1),this._local_to_clip=e$z.createMatrixf();}setPointSize(t){this.setFloat("u_point_size",t);}setDebug(t){this.setFloat("u_debug",t);}setDebugBoundsParameter(t,o){return m$8(t.gocs_to_clip,o,this._local_to_clip),this.setMatrix("u_obj_to_clip",this._local_to_clip),!0}static _getPreamble(t){const o=[],e=h$5._getShapeTypeShaderValue(t.point_shape_type);return o.push("#define POINT_SHAPE_TYPE "+e),o.join("\n")+"\n\n"}static _getShapeTypeShaderValue(t){switch(t){case h$4.PointShapeType.RECTANGLE:return 0;case h$4.PointShapeType.CIRCLE:return 1;case h$4.PointShapeType.CIRCLE_WITH_BORDER:return 2;case h$4.PointShapeType.GRADIENT_CIRCLE:return 3}}setRenderId(t){}}class u$5 extends e$o{constructor(t){super(t.glenv,o$i,o$h),this.bindProgram(),this._color=e$z.createVector3([0,.2,.4]),this.setVector3("u_color",this._color),this._local_to_clip=e$z.createMatrixf();}setDebugBoundsParameter(t,o,e){return m$8(t.gocs_to_clip,o,this._local_to_clip),this.setMatrix("u_obj_to_clip",this._local_to_clip),e&&(this._color[0]=e[0],this._color[1]=e[1],this._color[2]=e[2]),this.setVector3("u_color",this._color),!0}}class n$I extends e$o{constructor(t){super(t.glenv,o$g,o$f),this.bindProgram(),this._color=e$z.createVector4([.3,.9,1,.5]),this.setVector4("u_color",this._color),this._local_to_clip=e$z.createMatrixf();}setDebugBoundsParameter(t,o,e){return m$8(t.gocs_to_clip,o,this._local_to_clip),this.setMatrix("u_obj_to_clip",this._local_to_clip),e&&(this._color[0]=e[0],this._color[1]=e[1],this._color[2]=e[2],this._color[3]=e[3]||0),this.setVector4("u_color",this._color),!0}}class d$4 extends h$5{constructor(t,o){super(t,o,n$K,n$J);}setRenderId(t){this.setVector4("u_rid",[(t>>12&15)/15,(t>>8&15)/15,(t>>4&15)/15,(15&t)/15]);}}const m$8=(t,o,e)=>{const r=t[0],s=t[4],i=t[8],_=t[12],c=t[1],l=t[5],a=t[9],p=t[13],h=t[2],u=t[6],n=t[10],d=t[14],m=t[3],g=t[7],f=t[11],b=t[15],P=o[0],j=o[1],x=o[2];return e[0]=r,e[1]=c,e[2]=h,e[3]=m,e[4]=s,e[5]=l,e[6]=u,e[7]=g,e[8]=i,e[9]=a,e[10]=n,e[11]=f,e[12]=r*P+s*j+i*x+_,e[13]=c*P+l*j+a*x+p,e[14]=h*P+u*j+n*x+d,e[15]=m*P+g*j+f*x+b,e};

class _$5{constructor(e,t){this._glenv=e.glenv,this._scene=e,this._provider=t,this._root=_$5.Box.createRoot(this),this._points_per_pixel=.7,this._point_shape=_$5.PointShapeType.CIRCLE,this._point_size_type=_$5.PointSizeType.FLEXIBLE,this._point_size=1,this._point_size_limit=10,this._visibility=!0,this._dispersion=!0,this._debug_shader=!1,this._debug_render_box=!1,this._debug_render_ellipsoid=!1,this._debug_render_axis=!1,this._debug_render_section=!1,this._checkMaterials(),_$5._instances.push(this);}init(){return __awaiter(this,void 0,void 0,(function*(){yield this._provider.init();}))}destroy(){return __awaiter(this,void 0,void 0,(function*(){this._provider&&(yield this._provider.destroy()),this._root&&(yield this._root.dispose());const e=_$5._instances.indexOf(this);-1!==e&&_$5._instances.splice(e,1);}))}getVisibility(){return this._visibility}setVisibility(e){this._visibility=e;}get glenv(){return this._glenv}get scene(){return this._scene}get provider(){return this._provider}get root(){return this._root}getPointsPerPixel(){return this._points_per_pixel}setPointsPerPixel(e){this._points_per_pixel=e;}getPointShape(){return this._point_shape}setPointShape(e){this._point_shape=e;}getPointSizeType(){return this._point_size_type}setPointSizeType(e){this._point_size_type=e;}getPointSize(){return this._point_size}setPointSize(e){this._point_size=e;}getPointSizeLimit(){return this._point_size_limit}setPointSizeLimit(e){this._point_size_limit=e;}setRenderId(e){this._rid=e;}getRenderId(){return this._rid}getDispersion(){return this._dispersion}setDispersion(e){this._dispersion=e;}getDebugShader(){return this._debug_shader}setDebugShader(e){this._debug_shader=e;}getDebugRenderBox(){return this._debug_render_box}setDebugRenderBox(e){this._debug_render_box=e,this._updateDebugMesh();}getDebugRenderEllipsoid(){return this._debug_render_ellipsoid}setDebugRenderEllipsoid(e){this._debug_render_ellipsoid=e,this._updateDebugMesh();}getDebugRenderAxis(){return this._debug_render_axis}setDebugRenderAxis(e){this._debug_render_axis=e,this._updateDebugMesh();}getDebugRenderSection(){return this._debug_render_section}setDebugRenderSection(e){this._debug_render_section=e,this._updateDebugMesh();}_updateDebugMesh(){this._root&&this._root._updateDebugMeshes();}static requestTraverseSummary(){return __awaiter(this,void 0,void 0,(function*(){return new Promise((e=>{const t=i=>{e(i);const s=_$5.getTraverseDataRequestQueue().indexOf(t);-1!==s&&_$5.getTraverseDataRequestQueue().splice(s,1);};_$5.getTraverseDataRequestQueue().push(t);}))}))}static getTraverseDataRequestQueue(){return _$5._traverseDataRequestQueue||(_$5._traverseDataRequestQueue=[])}_checkMaterials(){const e=this._scene.viewer,t=e._render_cache||(e._render_cache={});if(!t.point_cloud_materials){const i=new Map;_$5.ListOfPointShapeTypes.forEach((t=>{i.set(t,new h$5(e,{point_shape_type:t}));})),t.point_cloud_materials=i;}if(!t.point_cloud_pick_materials){const i=new Map;_$5.ListOfPointShapeTypes.forEach((t=>{i.set(t,new d$4(e,{point_shape_type:t}));})),t.point_cloud_pick_materials=i;}t.point_cloud_debug_wire_material||(t.point_cloud_debug_wire_material=new u$5(e)),t.point_cloud_debug_face_material||(t.point_cloud_debug_face_material=new n$I(e));}getMaterial(e,t){const i=this._scene.viewer,s=i._render_cache||(i._render_cache={}),r=("SCENE"===t?s.point_cloud_materials:s.point_cloud_pick_materials).get(e);if(!r)throw new Error("pointcloud material not initialized");return r}static setStatisticsHandler(e){_$5._statistics=e?{statistics_obj:new _$5.Statistics,statistics_handler:e}:void 0;}static getStatistics(){return _$5._statistics}}_$5._instances=[],_$5._traverseDataRequestQueue=[],function(s){let r;var n;s.Statistics=class{constructor(){this._now=performance?()=>performance.now():()=>Date.now(),this.clear(),this.render_point_count=0,this.total_point_count=0,this.render_boxes=0,this.total_boxes=0,this.loading_boxes=0,this.created_boxes=0,this.disposed_boxes=0,this.total_time=0,this.traverse_time=0,this.render_time=0,this._start_time=-1,this._done_time=-1,this._done_traverse_time=-1;}start(){this._start_time=this._now();}doneTraverse(){this._done_traverse_time=this._now(),this.traverse_time+=this._done_traverse_time-this._start_time;}done(){this._done_time=this._now(),this.render_time+=this._done_time-this._done_traverse_time,this.total_time+=this._done_time-this._start_time;}clear(){this.render_point_count=0,this.total_point_count=0,this.render_boxes=0,this.total_boxes=0,this.loading_boxes=0,this.created_boxes=0,this.disposed_boxes=0,this.total_time=0,this.traverse_time=0,this.render_time=0,this._start_time=-1,this._done_time=-1,this._done_traverse_time=-1;}},function(e){e[e.RECTANGLE=0]="RECTANGLE",e[e.CIRCLE=1]="CIRCLE",e[e.CIRCLE_WITH_BORDER=2]="CIRCLE_WITH_BORDER",e[e.GRADIENT_CIRCLE=3]="GRADIENT_CIRCLE";}(r=s.PointShapeType||(s.PointShapeType={})),s.ListOfPointShapeTypes=[r.RECTANGLE,r.CIRCLE,r.CIRCLE_WITH_BORDER,r.GRADIENT_CIRCLE],(n=s.PointSizeType||(s.PointSizeType={}))[n.PIXEL=0]="PIXEL",n[n.MILLIMETERS=1]="MILLIMETERS",n[n.FLEXIBLE=2]="FLEXIBLE";class o{constructor(e,t,r,n,_){this._parent=e,e&&(this._owner=e._owner),this.level=t,this.x=r,this.y=n,this.z=_;const h=this.size=0===t?2147483648:t<31?1<<31-t:Math.pow(.5,t-31);this.proj_area=4*h*h,this.gocs_center=e$z.createVector3([s.MIN_INT+(2*r+1)*h,s.MIN_INT+(2*n+1)*h,s.MIN_INT+(2*_+1)*h]),this.gocs_min=e$z.createVector3([this.gocs_center[0]-h,this.gocs_center[1]-h,this.gocs_center[2]-h]),this.gocs_max=e$z.createVector3([this.gocs_center[0]+h,this.gocs_center[1]+h,this.gocs_center[2]+h]),this._status=o.Status.NOT_LOADED,this._children=[void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0],this._owner&&this._updateDebugMesh();}forEach(e){for(let t=0;t<this._children.length;t++){const i=this._children[t];i&&i.status===o.Status.LOADED&&i.forEach(e);}e(this);}_updateDebugMeshes(){this._updateDebugMesh();for(let e=0;e<this._children.length;e++){const t=this._children[e];t&&t._updateDebugMeshes();}}_updateDebugMesh(){const e=[],i=[],r=[];if(this._owner.getDebugRenderBox()){for(let t=0;t<s.CHILDREN_INDICES.length;t++)e.push(this.size*(2*s.CHILDREN_INDICES[t][2]-1),this.size*(2*s.CHILDREN_INDICES[t][1]-1),this.size*(2*s.CHILDREN_INDICES[t][0]-1));i.push(0,1,1,3,3,2,2,0,4,5,5,7,7,6,6,4,0,4,1,5,3,7,2,6),r.push(0,2,1,1,2,3,4,5,6,7,6,5,0,1,4,1,5,4,1,3,5,3,7,5,3,6,7,3,2,6,6,2,4,2,0,4);}if(this.average&&!isNaN(this.eigenVector[0][0])){if(this._owner.getDebugRenderAxis()){let t=e.length/3;for(let s=0;s<3;s++){const r=Math.max(.2,this.eigenVectorLength[s]),n=this.eigenVector[s];for(let t=0;t<3;t++)e.push(this.average[t]-r*n[t]);for(let t=0;t<3;t++)e.push(this.average[t]+r*n[t]);i.push(t++,t++);}}this._owner.getDebugRenderSection()&&this.level>20&&this.vertex_length>5e3&&this.eigenVectorLength[0]<.2*this.size&&this._putSectionShapePoints(e,i,r),this._owner.getDebugRenderEllipsoid()&&this._putVariancePoints(e,i,r);}const n=[];if(i.length>0){const s={vtype:[{name:"a_position",size:3}],ptype:"lines",vertices:e,indices:i};n.push(new r$h(this._owner.glenv,s));}if(r.length>0){const i={vtype:[{name:"a_position",size:3}],ptype:"triangles",vertices:e,indices:r};n.push(new r$h(this._owner.glenv,i));}this._debugMesh=n;}_putVariancePoints(e,t,i){const r=e.length/3,[n,o,_]=this.eigenVector,[h,a,d]=this.eigenVectorLength,u=s._variance_points_cache,c=u.G,l=u.N,g=(e,t,i)=>{const s=u.cos_ro[e],r=u.sin_ro[e],c=u.cos_th[t],l=u.sin_th[t];i.push(this.average[0]+r*(a*c*o[0]+d*l*_[0])+h*s*n[0],this.average[1]+r*(a*c*o[1]+d*l*_[1])+h*s*n[1],this.average[2]+r*(a*c*o[2]+d*l*_[2])+h*s*n[2]);};for(let t=0;t<=c;++t)for(let i=0;i<=l;++i)g(t,i,e);for(let e=0;e<c;++e)for(let s=0;s<l;++s){const n=r+e*(l+1)+s;t.push(n,n+1,n,n+l+1),i.push(n,n+1,n+l+1,n+l+1,n+1,n+l+2);}}_putSectionShapePoints(e,t,i){const s=e.length/3,r=this.average,n=this.eigenVector[0],o=this.size,_=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]),h=[n[0]/_,n[1]/_,n[2]/_],a=[],d=[];for(let e=0;e<2;++e)for(let t=0;t<2;++t)d.push({p:[e>0?o:-o,t>0?o:-o,0],v:[0,0,o]},{p:[t>0?o:-o,0,e>0?o:-o],v:[0,o,0]},{p:[0,e>0?o:-o,t>0?o:-o],v:[o,0,0]});let u=!0;const c=[0,0,0],l=[0,0,0];for(let e=0;e<d.length;e++){const t=d[e].p,i=d[e].v,s=((r[0]-t[0])*h[0]+(r[1]-t[1])*h[1]+(r[2]-t[2])*h[2])/(i[0]*h[0]+i[1]*h[1]+i[2]*h[2]);if(Math.abs(s)<=1){const e=[t[0]+s*i[0],t[1]+s*i[1],t[2]+s*i[2]],n=[e[0]-r[0],e[1]-r[1],e[2]-r[2]];let o;u?(o=0,l[0]=h[1]*n[2]-h[2]*n[1],l[1]=h[2]*n[0]-h[0]*n[2],l[2]=h[0]*n[1]-h[1]*n[0],c[0]=l[1]*h[2]-l[2]*h[1],c[1]=l[2]*h[0]-l[0]*h[2],c[2]=l[0]*h[1]-l[1]*h[0],u=!1):o=Math.atan2(l[0]*n[0]+l[1]*n[1]+l[2]*n[2],c[0]*n[0]+c[1]*n[1]+c[2]*n[2]),a.push([...e,o,n[0],n[1],n[2],c[0]*n[0]+c[1]*n[1]+c[2]*n[2],l[0]*n[0]+l[1]*n[1]+l[2]*n[2]]);}}a.sort(((e,t)=>e[3]-t[3]));for(let r=0;r<a.length;++r)e.push(a[r][0],a[r][1],a[r][2]),t.push(s+r),r==a.length-1?t.push(s):t.push(s+r+1),i&&(i.push(s,s+r),r==a.length-1?i.push(s):i.push(s+r+1));}get status(){return this._status}get is_loaded(){return this._status===o.Status.LOADED}get parent(){return this._parent}get vertex_length(){var e;return (null===(e=this._metaInfo)||void 0===e?void 0:e.indices[7])||0}getChildInfo(e){if(this._metaInfo)return this._metaInfo.children[e]}cellPointsAvailable(e){return this._metaInfo&&(0===e?this._metaInfo.indices[e]>0:this._metaInfo.indices[e]>this._metaInfo.indices[e-1])}indexOf(e){return this._children.indexOf(e)}isInvisible(e){if(0===this.level)return !1;const t=this.gocs_min[0],i=this.gocs_max[0],s=this.gocs_min[1],r=this.gocs_max[1],n=this.gocs_min[2],o=this.gocs_max[2];for(let _=0;_<e.length;++_){const h=e[_],a=h[0],d=h[1],u=h[2],c=h[3],l=a*t+d*s,g=a*i+d*s,p=a*t+d*r,f=a*i+d*r,b=-u*n-c,v=-u*o-c;if(l<b&&g<b&&p<b&&f<b&&l<v&&g<v&&p<v&&f<v)return !0}return !1}load(){return __awaiter(this,void 0,void 0,(function*(){if(this._status!==s.Status.NOT_LOADED)throw new Error("illegal status: "+this._status);if(!this._owner.provider.isReady())return;this._status=o.Status.LOADING;const e=this._owner.provider.load(this.level,this.x,this.y,this.z);return this._loadId=e.id,e.done.then((e=>{if(this._status===s.Status.DESTROYED)return;const t=[];{let i=e.header.childFlags;for(let e=7;e>=0;--e)1&i&&(t[e]={}),i>>=1;}this._metaInfo={children:t,indices:e.header.indices},this.average=e.header.average,this.eigenVector=e.header.eigenVector,this.eigenVectorLength=e.header.eigenVectorLength,this.debug1=e.header.debug1;const i=e.body,r=this._owner.glenv.context,n=r.createBuffer();if(!n)throw new Error("failed to create buffer");this._vertex_buffer=n,this._vertex_length=i.length/6,r.bindBuffer(r.ARRAY_BUFFER,this._vertex_buffer),r.bufferData(r.ARRAY_BUFFER,i,r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,null),this._vertex_attribs={a_position:{buffer:this._vertex_buffer,num_components:3,component_type:r.FLOAT,normalized:!1,byte_stride:24,byte_offset:0},a_color:{buffer:this._vertex_buffer,num_components:3,component_type:r.FLOAT,normalized:!1,byte_stride:24,byte_offset:12}},this._status=o.Status.LOADED,this._updateDebugMesh();})).catch((e=>{"cancel"===e.message||"not loading"===e.message||"The user aborted a request."===e.message||e.is_aborted||(console.log(e),this._status=o.Status.DESTROYED);}))}))}newChild(e,t){const[i,r,n]=s.CHILDREN_INDICES[e];return this.newChildAt(i,r,n,t)}newChildAt(e,t,i,s){const r=e|t<<1|i<<2,n=this._children[r];return n||(this.getChildInfo(r)?(s&&s.created_boxes++,this._children[r]=new o(this,this.level+1,this.x<<1|e,this.y<<1|t,this.z<<1|i)):void 0)}getChild(e){return this._children[e]}_drawDebugMesh(e){if(!this._debugMesh)return;const t=e.glenv.context,i=s.STATUS_COLOR_TABLE.get(this._status),r=this._owner.scene.viewer._render_cache;t.disable(t.CULL_FACE);for(let t of this._debugMesh){const s=1===t.gl_draw_mode?r.point_cloud_debug_wire_material:r.point_cloud_debug_face_material;s.bindProgram(),s.setDebugBoundsParameter(e,this.gocs_center,i),t.draw(s);}t.enable(t.CULL_FACE);}draw(e,t,i,r){if(this._debugMesh&&this._drawDebugMesh(e),this._status!==o.Status.LOADED)return;const n=e.glenv.context,_=this._owner.getPointShape(),h=this._owner.getPointSizeType(),a=this._owner.getPointSize(),d=this._owner.getPointSizeLimit(),u=this._owner.getDebugShader();if(this._status===o.Status.LOADED){const o=this._owner.getMaterial(_,e.getRenderTarget());o.bindProgram(),o.setDebugBoundsParameter(e,this.gocs_center),o.bindVertexAttribs(this._vertex_attribs);const c=this._owner.getRenderId();void 0!==c&&o.setRenderId(c);const l=3;if(t)for(let r=0;r<t.length;r++){const _=i[r];o.setPointSize(h===s.PointSizeType.PIXEL?a:h===s.PointSizeType.MILLIMETERS?-.001*a/e.pixel_step:Math.min(d,Math.max(1,l/_))),o.setDebug(u?.5/_:-1);const c=t[r],g=c>0?this._metaInfo.indices[c-1]:0,p=this._metaInfo.indices[c]-g;p>0&&n.drawArrays(n.POINTS,g,p);}else {const t=i[0];o.setPointSize(h===s.PointSizeType.PIXEL?a:h===s.PointSizeType.MILLIMETERS?-.001*a/e.pixel_step:Math.min(d,Math.max(1,l/t))),o.setDebug(u?.5/t:-1),n.drawArrays(n.POINTS,0,this._vertex_length);}if(n.bindBuffer(n.ARRAY_BUFFER,null),r)if(r.render_boxes++,t&&this._metaInfo.indices)for(let e of t){const t=e>0?this._metaInfo.indices[e-1]:0,i=this._metaInfo.indices[e]-t;r.render_point_count+=i;}else r.render_point_count+=this._vertex_length;}}disposeChildren(e){for(let t=0;t<this._children.length;t++){const i=this._children[t];i&&(i.dispose(e),this._children[t]=void 0);}}dispose(e){if(this._status===o.Status.LOADING&&(this._abort_controller&&this._abort_controller.abort(),void 0!==this._loadId&&this._owner.provider.cancel(this._loadId)),this.disposeChildren(e),this._vertex_buffer){this._owner.glenv.context.deleteBuffer(this._vertex_buffer);}this._debugMesh,e&&e.disposed_boxes++,this._status=o.Status.DESTROYED;}toString(){return `Box-${this.level}-${this.x}-${this.y}-${this.z}`}toTreeString(e=""){return this._children.reduce(((t,i)=>t+(i?"\n"+i.toTreeString(e+"  "):"")),e+this.toString())}static createRoot(e){const t=new o(void 0,0,0,0,0);return t._owner=e,t}static get Status(){return _}}let _;s.Box=o,s.CHILDREN_INDICES=[[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1],[1,0,1],[0,1,1],[1,1,1]],s._variance_points_cache=(()=>{const e=[],t=[],i=[],s=[];for(let i=0;i<=6;++i){const s=Math.PI*i/6;e[i]=Math.cos(s),t[i]=Math.sin(s);}for(let e=0;e<=12;++e){const t=2*Math.PI*e/12;i[e]=Math.cos(t),s[e]=Math.sin(t);}return {cos_ro:e,sin_ro:t,cos_th:i,sin_th:s,G:6,N:12}})(),function(e){e[e.NOT_LOADED=0]="NOT_LOADED",e[e.LOADING=1]="LOADING",e[e.LOADED=2]="LOADED",e[e.DESTROYED=3]="DESTROYED";}(_=s.Status||(s.Status={})),s.STATUS_COLOR_TABLE=new Map,s.STATUS_COLOR_TABLE.set(_.LOADED,[0,.8,1,.5]),s.STATUS_COLOR_TABLE.set(_.DESTROYED,[1,0,0]),s.STATUS_COLOR_TABLE.set(_.LOADING,[1,1,0]),s.STATUS_COLOR_TABLE.set(_.NOT_LOADED,[0,1,0]),s.MIN_INT=1<<31;}(_$5||(_$5={}));var h$4=_$5;

class t$i{constructor(t,i,e){this._box=t,this._distance=i,this._target_children=[],this._points_per_pixel=[],this._parent_points_per_pixel=e;}get box(){return this._box}get distance(){return this._distance}get parent_points_per_pixel(){return this._parent_points_per_pixel}pushRegion(t,i){if(this._target_children){const e=this._target_children.indexOf(t);-1===e?(this._target_children.push(t),this._points_per_pixel.push(i)):(this._target_children[e]=t,this._points_per_pixel[e]=i);}}setWholeRegion(t){this._target_children=void 0,this._points_per_pixel=[t];}draw(t,i){this._box.draw(t,this._target_children,this._points_per_pixel,i);}}

class i$e{constructor(e,t=10){this._setupViewVectors(e),this._setupClipPlanes(e),this._unloadInvisible="SCENE"===e.getRenderTarget(),this._point_cloud_collection=e._point_cloud_collection,this._render_boxes=[],this._render_boxes_map=new Map,this._load_boxes=[],this._load_limit=t;}_setupViewVectors(t){const s=t._view_to_gocs,i=t._pixel_step,_=e$z.createVector3(),o=e$z.createVector3();_[0]=s[12],_[1]=s[13],_[2]=s[14],o[0]=-s[8]*i,o[1]=-s[9]*i,o[2]=-s[10]*i,this._view_pos_Q=_,this._view_dir_wU=o;}_setupClipPlanes(t){const s=t._view_to_gocs,i=t._gocs_to_view,_=t.getVolumePlanes();this._volume_planes=_;const o=[],r=t.viewer.globe.root_flake,n=e$z.EARTH_RADIUS+r.height_min,a=e$z.EARTH_RADIUS+r.height_max,h=s[12],l=s[13],c=s[14],p=h*h+l*l+c*c,d=n*n,g=a*a,u=Math.sqrt((p-d)*(g-d))-d,x=e$z.createVector4(),v=1/Math.sqrt(p);x[0]=h*v,x[1]=l*v,x[2]=c*v,x[3]=u*v;const E=Math.sqrt(p+g+2*u);for(let t=0;t<6;++t){let s=_[t];const r=e$z.createVector4();1==t&&s[3]>E&&(s=e$z.createVector4(s),s[3]=E),e$z.transformPlane_A(i,s,r),o.push(r);}this._clip_planes=o;}traverse(e,t){return this._points_per_pixel=e.getPointsPerPixel(),this._dispersion=e.getDispersion(),this._statistics=t,this._updateBox(e.root,0),{visible_boxes:this._render_boxes,load_boxes:this._load_boxes}}_updateBox(e,s){if(this._statistics&&(this._statistics.total_boxes++,e.status===h$4.Box.Status.LOADING&&this._statistics.loading_boxes++,e.vertex_length&&(this._statistics.total_point_count+=e.vertex_length)),e.isInvisible(this._clip_planes))return void(this._unloadInvisible&&e.disposeChildren(this._statistics));let i,o;if(e.is_loaded?(i=this._calcPointsPerPixel(e),o=i<this._points_per_pixel?_$4.LOAD_NEXT_LEVEL:_$4.UNLOAD_NEXT_LEVEL):o=_$4.KEEP_STATUS,o!==_$4.LOAD_NEXT_LEVEL){if(o===_$4.UNLOAD_NEXT_LEVEL&&this._unloadInvisible&&e.disposeChildren(this._statistics),e.status!==h$4.Box.Status.DESTROYED&&(this._pushBox(e,void 0,i,s),e.status===h$4.Box.Status.LOADING||e.status===h$4.Box.Status.NOT_LOADED)){const t=e.parent;t&&this._pushBox(t,t.indexOf(e),s,s);}}else {this._collectNextLevel(e,i);for(let t=0;t<8;t++)e.cellPointsAvailable(t)&&!e.getChild(t)&&this._pushBox(e,t,i,s);}}_calcPointsPerPixel(t){let s;if(t.eigenVectorLength[0]<.8*t.size&&this._dispersion&&t.eigenVectorLength[0]>0){const i=e$z.normalize3(this._view_dir_wU,e$z.createVector3f()),[_,o,r]=t.eigenVector,[n,a,h]=t.eigenVectorLength,l=e$z.createVector3([e$z.dot3(o,i),e$z.dot3(_,i),e$z.dot3(r,i)]),c=l[0]*l[0]/(a*a)+l[2]*l[2]/(h*h),p=e$z.createVector3([c*h*n/a*l[0],c*a*h/n*l[1],c*n*a/h*l[2]]);e$z.normalize3(p,p);const d=(p[0]*l[0]+p[1]*l[1]+p[2]*l[2])*(Math.PI*n*a*h/Math.sqrt(p[0]*p[0]*a*a+p[1]*p[1]*n*n+p[2]*p[2]*h*h)),g=Math.min(Math.max(d,.05*t.proj_area),t.proj_area);s=Math.sqrt(t.vertex_length/g);}else s=64/t.size;const i=e$z.createVector3([t.gocs_center[0]+t.average[0]-this._view_pos_Q[0],t.gocs_center[1]+t.average[1]-this._view_pos_Q[1],t.gocs_center[2]+t.average[2]-this._view_pos_Q[2]]);return e$z.dot3(this._view_dir_wU,i)*s}_pushBox(i,_,o,r){let n=this._render_boxes_map.get(i);if(n)void 0===_?n.setWholeRegion(o):n.pushRegion(_,o);else {const a=e$z.createVector3(i.is_loaded?[i.gocs_center[0]+i.average[0]-this._view_pos_Q[0],i.gocs_center[1]+i.average[1]-this._view_pos_Q[1],i.gocs_center[2]+i.average[2]-this._view_pos_Q[2]]:[i.gocs_center[0]-this._view_pos_Q[0],i.gocs_center[1]-this._view_pos_Q[1],i.gocs_center[2]-this._view_pos_Q[2]]),h=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);n=new t$i(i,h,r),void 0===_?n.setWholeRegion(o):n.pushRegion(_,o),this._render_boxes.push(n),this._render_boxes_map.set(i,n),i.status===h$4.Box.Status.NOT_LOADED&&this._pushLoadBox(n);}}_pushLoadBox(e){const t=this._binarySearch(this._load_boxes,e,((e,t)=>e.parent_points_per_pixel<t.parent_points_per_pixel));-1===t?this._load_boxes.push(e):this._insert_with_limit(this._load_boxes,t,e,this._load_limit);}_insert_with_limit(e,t,s,i){if(void 0===i||i-e.length>0)e.splice(t,0,s);else {if(t===e.length)return;for(let s=e.length-1;s>t;s--)e[s]=e[s-1];e[t]=s;}}_binarySearch(e,t,s){return 0===e.length?-1:s(t,e[0])?0:s(e[e.length-1],t)||1===e.length?e.length:this._binarySearchInner(e,t,s,0,e.length-1)}_binarySearchInner(e,t,s,i,_){if(_-i==1)return _;const o=.5*(i+_)|0;return s(e[o],t)?i=o:_=o,this._binarySearchInner(e,t,s,i,_)}_collectNextLevel(e,t){let s;for(let i=0;i<8;i++)(s=e.newChild(i,this._statistics))&&this._updateBox(s,t);}}var _$4;!function(e){e[e.LOAD_NEXT_LEVEL=0]="LOAD_NEXT_LEVEL",e[e.KEEP_STATUS=1]="KEEP_STATUS",e[e.UNLOAD_NEXT_LEVEL=2]="UNLOAD_NEXT_LEVEL";}(_$4||(_$4={}));

class e$h{constructor(e,r,t,n){this._glenv=e,this._width=r,this._height=t,this._option=n;const{frame_buffer:E,color_containers:o,depth_container:_}=this._buildBuffers(n);this._frame_buffer=E,this._color_containers=o,this._depth_container=_;}_buildBuffers(e){const r=this._width,t=this._height,n=this._glenv.context,E=n.createFramebuffer();if(!E)throw new Error("couldn't create Framebuffer");n.bindFramebuffer(n.FRAMEBUFFER,E);const o=e.color_containers.map(((e,E)=>{const o=e.type||"@@_FrameBuffer.ContainerType.RENDER_BUFFER",_=e.option||{};if("@@_FrameBuffer.ContainerType.RENDER_BUFFER"===o){const e=n.createRenderbuffer();return n.bindRenderbuffer(n.RENDERBUFFER,e),n.renderbufferStorage(n.RENDERBUFFER,_.internal_format,r,t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+E,n.RENDERBUFFER,e),e}{const e=n.createTexture();return n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,_.internal_format,r,t,0,_.format,_.type,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+E,n.TEXTURE_2D,e,0),e}}));let _;if(e.depth_container){const E=e.depth_container.type||"@@_FrameBuffer.ContainerType.RENDER_BUFFER",o=e.depth_container.option||{};if("@@_FrameBuffer.ContainerType.RENDER_BUFFER"===E){const e=n.createRenderbuffer();if(!e)throw new Error("couldn't create render buffer");_=e,n.bindRenderbuffer(n.RENDERBUFFER,_),n.renderbufferStorage(n.RENDERBUFFER,o.internal_format,r,t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,_);}else {const E=n.createTexture();if(!E)throw new Error("couldn't create texture");_=E,n.bindTexture(n.TEXTURE_2D,_),n.texImage2D(n.TEXTURE_2D,0,o.internal_format,r,t,0,o.format,o.type,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,e.depth_container.attach_type,n.TEXTURE_2D,_,0);}}if(n.checkFramebufferStatus(n.FRAMEBUFFER)!==n.FRAMEBUFFER_COMPLETE)throw new Error("ERROR: "+n.checkFramebufferStatus(n.FRAMEBUFFER));return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),{frame_buffer:E,color_containers:o,depth_container:_}}dispose(){this._glenv.context.deleteFramebuffer(this._frame_buffer),this._frame_buffer=void 0,this._color_containers.forEach((e=>{this._delete_container(e);})),this._color_containers=[],this._delete_container(this._depth_container),this._depth_container=void 0;}_delete_container(e){const r=this._glenv.context;e instanceof WebGLTexture?r.deleteTexture(e):e instanceof WebGLRenderbuffer&&r.deleteRenderbuffer(e);}get frame_buffer(){return this._frame_buffer}get color_container(){return this._color_containers[0]}getColorContainer(e){return this._color_containers[e]}get color_container_length(){return this._color_containers.length}get depth_container(){return this._depth_container}bind(){if(r$d)throw new Error("Invalid status: already bound");const e=this._glenv.context;e.bindFramebuffer(e.FRAMEBUFFER,this._frame_buffer),r$d=this;}unbind(){if(r$d!==this)throw new Error("Invalid status");const e=this._glenv.context;e.bindFramebuffer(e.FRAMEBUFFER,null),r$d=void 0;}}let r$d;!function(e){var r;(r=e.ContainerType||(e.ContainerType={})).RENDER_BUFFER="@@_FrameBuffer.ContainerType.RENDER_BUFFER",r.TEXTURE="@@_FrameBuffer.ContainerType.TEXTURE";}(e$h||(e$h={}));var t$h=e$h;

var n$H="/**\n * 深度描画用シェーダ (頂点シェーダ)\n */\n\nattribute vec3 a_position;\n\n\nvoid\nmain( void ) {\n    gl_Position = vec4( a_position, 1.0 );\n}\n";

var n$G="// define PASS_BASE 0 or 1 JS側で指定される\n\n/**\n * 深度描画用シェーダ (フラグメントシェーダ)\n */\n\nuniform highp sampler2D u_sampler;\n\nvoid\nmain( void ) {\n    highp float fdepth = texture2D( u_sampler, vec2( 0.5, 0.5 ) ).r; // r:[0.0-1.0](24bit), g:0.0, b:0.0, a:1.0\n\n    /* 疑似コード PASS_BASEは0か4を想定\n    int n[8];  // 各 n[i] の値は範囲 [0, 7], ただし n[0] は [0, 8]\n    for ( int i = 0; i < 8; ++i ) {\n        n[i] = 0;\n        for ( int w = (i == 0 ? 3 : 2); w >= 0; --w ) {\n            if ( fdepth >= 1.0 ) {\n                n[i] += (1 << w);\n                fdepth = fract( fdepth );\n            }\n            fdepth *= 2.0;\n        }\n    }\n\n    gl_FragColor = vec4( n[PASS_BASE + 0],\n        n[PASS_BASE + 1],\n        n[PASS_BASE + 2],\n        n[PASS_BASE + 3]\n    ) / NMAX;\n    */\n\n#if PASS_BASE == 1\n    for ( int i=0; i<12; i++ ) {\n        fdepth = fract( fdepth * 2.0 );\n    }\n#endif // PASS_BASE\n\n    highp vec4 v;\n\n    int n = 0;\n    if ( fdepth >= 1.0 ) { n += 0x8; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x4; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x2; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x1; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    v[0] = float(n) / 15.0;\n\n    n = 0;\n    if ( fdepth >= 1.0 ) { n += 0x4; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x2; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x1; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    v[1] = float(n) / 15.0;\n\n    n = 0;\n    if ( fdepth >= 1.0 ) { n += 0x4; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x2; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x1; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    v[2] = float(n) / 15.0;\n\n    n = 0;\n    if ( fdepth >= 1.0 ) { n += 0x4; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x2; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x1; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    v[3] = float(n) / 15.0;\n\n    gl_FragColor = v;\n}\n";

class h$3{constructor(i,h={}){this._glenv=i;const a=this._glenv.context;this._width=h.width||11,this._height=h.height||11,this._camera=new i$m({width:this._width,height:this._height}),this._frame_buffer=new t$h(this._glenv,this._width,this._height,{color_containers:[this._createColorContainer()],depth_container:this._createDepthContainer()}),this._depth_to_color_frame_buffer=new t$h(this._glenv,this._width,this._height,{color_containers:[this._createColorContainer()]}),this._depth_to_color_materials=[new e$o(this._glenv,n$H,s$b+"\n\n"+n$G),new e$o(this._glenv,n$H,f$2+"\n\n"+n$G)];{const t=a.createBuffer();if(!t)throw new Error("couldn't create buffer");{const e=[-1,1,-1,-1,1,-1,1,1];a.bindBuffer(a.ARRAY_BUFFER,t),a.bufferData(a.ARRAY_BUFFER,new Float32Array(e),a.STATIC_DRAW),a.bindBuffer(a.ARRAY_BUFFER,null);}const e=a.createBuffer();if(!e)throw new Error("couldn't create buffer");{const t=[0,1,0,0,1,0,1,1];a.bindBuffer(a.ARRAY_BUFFER,e),a.bufferData(a.ARRAY_BUFFER,new Float32Array(t),a.STATIC_DRAW),a.bindBuffer(a.ARRAY_BUFFER,null);}{const t=[0,1,2,0,2,3];this._indices_length=t.length;const e=a.createBuffer();if(!e)throw new Error("couldn't create buffer");this._index_buf=e,a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this._index_buf),a.bufferData(a.ELEMENT_ARRAY_BUFFER,new Uint16Array(t),a.STATIC_DRAW),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,null);}this._vertex_attribs={a_position:{buffer:t,num_components:2,component_type:a.FLOAT,normalized:!1,byte_stride:0,byte_offset:0},a_texcoord:{buffer:e,num_components:2,component_type:a.FLOAT,normalized:!1,byte_stride:0,byte_offset:0}};}this._rid_value=new Uint8Array(4*this._width*this._height),this._depth_value=new Uint8Array(4*this._width*this._height);}_createColorContainer(){const t=this._glenv.context;return {type:"@@_FrameBuffer.ContainerType.RENDER_BUFFER",option:{internal_format:t.RGBA4,format:t.RGBA4,type:t.UNSIGNED_BYTE}}}_createDepthContainer(){const t=this._glenv,e=t.context,r=t.context2;if(r)return {type:"@@_FrameBuffer.ContainerType.TEXTURE",attach_type:r.DEPTH_ATTACHMENT,option:{internal_format:r.DEPTH_COMPONENT24,format:r.DEPTH_COMPONENT,type:r.UNSIGNED_INT}};if(!t.WEBGL_depth_texture)throw new Error("Depth Texture not supported");return {type:"@@_FrameBuffer.ContainerType.TEXTURE",attach_type:e.DEPTH_STENCIL_ATTACHMENT,option:{internal_format:e.DEPTH_STENCIL,format:e.DEPTH_STENCIL,type:t.WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL}}}pickCamera(t){const e=t.canvas_size.width,r=t.canvas_size.height;this._camera.copyViewParameters(t);const _=t.fov*e$z.DEGREE/2,n=this._camera.canvas_size.width,h=this._camera.canvas_size.height,a=Math.atan(Math.sqrt(n*n+h*h)*Math.tan(_)/Math.sqrt(e*e+r*r));return this._camera.fov=2*a/e$z.DEGREE,this._camera}beforeRender(){this._frame_buffer.bind();}afterRender(){this._frame_buffer.unbind();}renderCanceled(){this._frame_buffer.unbind();}readRid(){const t=this._glenv.context;this._frame_buffer.bind(),t.readPixels(0,0,this._width,this._height,t.RGBA,t.UNSIGNED_BYTE,this._rid_value);const e=4*Math.floor(this._width*this._height/2),r=Math.round(a$b[0]*Math.round(this._rid_value[e+0]/17)+a$b[1]*Math.round(this._rid_value[e+1]/17)+a$b[2]*Math.round(this._rid_value[e+2]/17)+a$b[3]*Math.round(this._rid_value[e+3]/17));return this._frame_buffer.unbind(),r}readDepth(t,e){const r=this._glenv.context;this._depth_to_color_frame_buffer.bind();let _=0;r.viewport(0,0,this._width,this._height);for(let t=0;t<2;t++){const e=this._frame_buffer.depth_container,i=this._depth_to_color_materials[t];i.bindProgram(),i.bindVertexAttribs(this._vertex_attribs),i.setInteger("u_sampler",0),i.bindTexture2D(0,e),r.depthFunc(r.ALWAYS),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,this._index_buf),r.drawElements(r.TRIANGLES,this._indices_length,r.UNSIGNED_SHORT,0),r.bindTexture(r.TEXTURE_2D,null),r.readPixels(0,0,this._width,this._height,r.RGBA,r.UNSIGNED_BYTE,this._depth_value);const n=o$e[t];for(let t=0;t<4;t++)_+=n[t]*this._depth_value[t];}this._depth_to_color_frame_buffer.unbind(),_=2*_-1;const n=t,h=[n[8]/n[0],n[9]/n[5],-1,(_+n[10])/n[14]],a=e,s=a[3]*h[0]+a[7]*h[1]+a[11]*h[2]+a[15]*h[3];return e$z.createVector3([(a[0]*h[0]+a[4]*h[1]+a[8]*h[2]+a[12]*h[3])/s,(a[1]*h[0]+a[5]*h[1]+a[9]*h[2]+a[13]*h[3])/s,(a[2]*h[0]+a[6]*h[1]+a[10]*h[2]+a[14]*h[3])/s])}}const a$b=[];for(let t=0;t<4;t++)a$b[t]=Math.pow(16,3-t);const o$e=[[],[]];for(let t=0;t<4;t++)o$e[0][t]=Math.pow(2,-3*(t+1))/17,o$e[1][t]=Math.pow(2,-3*(t+5))/17;const s$b="#define PASS_BASE 0",f$2="#define PASS_BASE 1";

class n$F{constructor(e,t,i){if(this._viewer=e,this._glenv=e.glenv,this._width=t.canvas_size.width,this._height=t.canvas_size.height,this._scene=e.scene,this._globe=e.globe,this._tile_texture_cache=e.tile_texture_cache,this._point_cloud_collection=e.point_cloud_collection,this._translucent_mode=!1,this._debug_stats=e.debug_stats,this._flake_list=[],0===this._width||0===this._height)return this._rendering_cancel=!0,this._view_to_gocs=n$F.IDENTITY,this._gocs_to_view=n$F.IDENTITY,this._view_to_clip=n$F.IDENTITY,this._gocs_to_clip=n$F.IDENTITY,this._pixel_step=0,void(this._volume_planes=[]);this._rendering_cancel=!1;const{view_to_gocs:r,gocs_to_view:a,view_to_clip:o,gocs_to_clip:l}=n$F._createBasicMatrices(i,t);this._view_to_gocs=r,this._gocs_to_view=a,this._view_to_clip=o,this._gocs_to_clip=l,this._volume_planes=i.volume_planes,this._pixel_step=i.pixel_step;const c=e._render_cache||(e._render_cache={});c.surface_material||(c.surface_material=new _$6(e),c.wireframe_material=new t$j(e)),c.surface_pick_material||(c.surface_pick_material=new _$6(e,{ridMaterial:!0})),c.surface_ground_space_material||(c.surface_ground_space_material=new _$6(e,{atmosphereFromSpaceMaterial:!0}),c.surface_ground_atmosphere_material=new _$6(e,{atmosphereMaterial:!0}));}get viewer(){return this._viewer}get glenv(){return this._glenv}get pixel_step(){return this._pixel_step}get gocs_to_clip(){return this._gocs_to_clip}get view_to_gocs(){return this._view_to_gocs}get gocs_to_view(){return this._gocs_to_view}getVolumePlanes(){return this._volume_planes}getTranslucentMode(){return this._translucent_mode}setTranslucentMode(e){this._translucent_mode=e;}static _createBasicMatrices(t,i){const _=i.view_to_gocs,s=e$z.createMatrix();e$z.inverse_A(_,s);const r=t.view_to_clip,a=e$z.createMatrix();return e$z.mul_PzA(r,s,a),{view_to_gocs:_,gocs_to_view:s,view_to_clip:r,gocs_to_clip:a}}onPushPrimitive(e,t){}_render(){var e;const t=this._glenv.context;if(t.viewport(0,0,this._width,this._height),"SCENE"===this.getRenderTarget()?t.clearColor(0,0,0,1):t.clearColor(0,0,0,0),t.depthMask(!0),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),this._rendering_cancel)return;if("@@_READY"!==this._globe.status)return void(this._rendering_cancel=!0);this._draw_extras(),t.enable(t.CULL_FACE),t.enable(t.DEPTH_TEST),t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ZERO,t.ONE),t.depthFunc(t.LEQUAL);const _=new _$9(this);this._flake_list=_.traverse();let s=this._viewer.getVisibility("@@_Viewer.Category.GROUND"),r=this._viewer.getVisibility("@@_Viewer.Category.ENTITY");this._prepare_draw_flake();for(let e of this._flake_list){let t=e.getRenderObject();s&&this._draw_flake_base_rid_check()&&this._draw_flake_base(e,t.getBaseMesh()),r&&this._draw_entities_on_flake_rid_check()&&this._draw_entities_on_flake(t);}this._viewer.getVisibility("@@_Viewer.Category.B3D_SCENE")&&this._draw_b3d(),this._viewer.getVisibility("@@_Viewer.Category.POINT_CLOUD")&&this._draw_point_cloud(),this._viewer.getVisibility("@@_Viewer.Category.VECTILE")&&(null===(e=this._viewer.vectile_manager)||void 0===e||e.draw(this,this._globe)),r&&this._draw_entity(),this._draw_sky_layer();}_prepare_draw_flake(){let e=this._scene.getFlakePrimitiveProducers();this._globe.putNextEntityProducers(e);}_draw_flake_base(e,t){const i=this._glenv.context,_=this._flake_material;_.bindProgram();const s=_.numDrawings();if(_.setFlakeParameter(this,e,t,0)&&(i.disable(i.BLEND),i.depthMask(!0),t.draw(_)),"SCENE"===this.getRenderTarget()){let r=_,a=!1;for(let _=1;_<s;++_){const s=this._viewer.layers.getDrawingLayer(_-1).getMateral();r!==s&&(r=s,r.bindProgram()),r.setFlakeParameter(this,e,t,_)&&(a||(i.enable(i.BLEND),i.depthMask(!1),a=!0),t.draw(r));}a&&i.depthMask(!0);}var r=this._debug_stats;r&&(r.num_drawing_flake_vertices+=t.num_vertices);}_draw_entities_on_flake(e){let t=e.num_entities;if(0==t)return;let i,_=this._glenv.context;_.enable(_.POLYGON_OFFSET_FILL),_.depthMask(!1),_.polygonOffset(-8,-8),"SCENE"===this.getRenderTarget()?i=e=>{e?_.enable(_.BLEND):_.disable(_.BLEND);}:(_.disable(_.BLEND),i=()=>{});for(let _=0;_<t;++_){let{primitive:t,entity:s}=e.getEntityPrimitive(_,this);i(t.isTranslucent(this)),this.onPushPrimitive(t,s),t.draw(this);}_.depthMask(!0),_.disable(_.POLYGON_OFFSET_FILL);}_draw_flake_base_rid_check(){return !0}_draw_entities_on_flake_rid_check(){return !0}_draw_entity(){}_draw_point_cloud(){}_draw_b3d(){}_draw_extras(){const e=this._glenv.context;e.depthMask(!1),e.blendFuncSeparate(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA,e.ZERO,e.ONE),e.enable(e.CULL_FACE),e.enable(e.BLEND),this._viewer.starVisualizer&&this._viewer.starVisualizer.visibility&&this._viewer.starVisualizer.draw(this,this._width,this._height,this._gocs_to_view),this._viewer.atmosphere&&this._viewer.atmosphere.visibility.sky&&this._viewer.atmosphere.starMask&&this._viewer.atmosphere.drawMask(this,this._gocs_to_clip,this._view_to_gocs),this._viewer.sunVisualizer&&this._viewer.sunVisualizer.visibility&&(e.blendFuncSeparate(e.ONE_MINUS_DST_COLOR,e.ONE,e.ZERO,e.ONE),this._viewer.sunVisualizer.draw(this,this._gocs_to_clip,this._view_to_gocs),e.blendFuncSeparate(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA,e.ZERO,e.ONE)),this._viewer.moonVisualizer&&this._viewer.moonVisualizer.visibility&&this._viewer.moonVisualizer.drawMask(this,this._gocs_to_clip,this._view_to_gocs),this._viewer.atmosphere&&this._viewer.atmosphere.visibility.sky&&(e.blendFuncSeparate(e.SRC_ALPHA,e.ONE,e.ZERO,e.ONE),this._viewer.atmosphere.draw(this,this._gocs_to_clip,this._view_to_gocs)),this._viewer.moonVisualizer&&this._viewer.moonVisualizer.visibility&&(e.blendFuncSeparate(e.ONE_MINUS_DST_COLOR,e.ONE,e.ZERO,e.ONE),this._viewer.moonVisualizer.draw(this,this._gocs_to_clip,this._view_to_gocs)),e.disable(e.BLEND),e.frontFace(e.CCW),e.depthMask(!0);}_draw_sky_layer(){const e=this._glenv.context;this._viewer.cloudVisualizer&&this._viewer.cloudVisualizer.visibility&&(e.enable(e.BLEND),e.disable(e.CULL_FACE),this._viewer.cloudVisualizer.draw(this,this._gocs_to_clip,this._view_to_gocs),e.enable(e.CULL_FACE),e.disable(e.BLEND));}}n$F.IDENTITY=e$z.setIdentity(e$z.createMatrix()),function(i){i.SceneRenderStage=class extends i{constructor(e){super(e,e.camera,e.camera.createRenderInfo()),this._flake_material="@@_Viewer.RenderMode.WIREFRAME"===e.render_mode?e._render_cache.wireframe_material:e.atmosphere&&e.atmosphere.visibility.ground?e.atmosphere.selectGroundShader(this._view_to_gocs):e._render_cache.surface_material;}getRenderTarget(){return "SCENE"}render(){if(this._render(),!this._rendering_cancel){var e=this._debug_stats;e&&(e.num_drawing_flakes=this._flake_list.length),this._globe.endFrame(),this._viewer.b3d_collection.endFrame(),this._tile_texture_cache.endFrame(),this._viewer.layers.endFrame();}}_draw_entity(){this._scene.draw(this);}_draw_point_cloud(){const e=h$4.getTraverseDataRequestQueue(),t=0===e.length?null:[],i=h$4.getStatistics();null==i||i.statistics_obj.clear();for(let e=0;e<this._point_cloud_collection.length;++e){const _=this._point_cloud_collection.get(e);if(!_.getVisibility())continue;null==i||i.statistics_obj.start();const s=Math.max(0,30-_.provider.getNumberOfRequests()),a=new i$e(this,s).traverse(_,null==i?void 0:i.statistics_obj);if(null==i||i.statistics_obj.doneTraverse(),_.provider.isReady())for(const e of a.load_boxes)e.box.load();for(const e of a.visible_boxes)e.draw(this,null==i?void 0:i.statistics_obj);_.provider.flushQueue(),t&&t.push({point_cloud:_,pcb_collection:a.visible_boxes}),null==i||i.statistics_obj.done();}if(t)for(let i=0;i<e.length;i++)e[i](t);null==i||i.statistics_handler(i.statistics_obj);}_draw_b3d(){this._viewer.b3d_collection.draw(this);}};var _;i.PickRenderStage=class extends i{constructor(e,t,i){const _=e.pick_tool_cache||(e.pick_tool_cache=new h$3(e.glenv)),s=_.pickCamera(e.camera),r=s.createRenderInfo(+t[0]-e.camera.canvas_size.width/2,-t[1]+e.camera.canvas_size.height/2);super(e,s,r),this._camera=s,this._flake_material=e._render_cache.surface_pick_material,this._pick_tool=_,this._rid_map=[null,null,null],this._pick_result=void 0,this._pickOption=i;}onPushPrimitive(e,t){t.isPickable()&&(e.rid=this._rid_map.length,this._rid_map.push(t));}_pushPointCloudToRidMap(e){const t=this._rid_map.length;e.setRenderId(t),this._rid_map.push(e);}getRenderTarget(){return "RID"}render(){var i;const _=this._pick_tool;_.beforeRender();const s=this._glenv.context;if(s.disable(s.DITHER),this._render(),s.enable(s.DITHER),this._rendering_cancel)return void _.renderCanceled();_.afterRender();const r=_.readDepth(this._view_to_clip,this._view_to_gocs);if(!r)return;const o=this._camera.view_to_gocs,n=e$z.length3([r[0]-o[12],r[1]-o[13],r[2]-o[14]]);if(n>(null!==(i=this._pickOption.limit)&&void 0!==i?i:Number.MAX_VALUE))return;const l=_.readRid();if(0!==l)if(1===l)this._pick_result={position:r,distance:n,category:"@@_Viewer.Category.GROUND"};else if(2===l)this._pick_result={position:r,distance:n,category:"@@_Viewer.Category.B3D_SCENE"};else {const e=this._rid_map[l];if(e instanceof s$m)this._pick_result={position:r,distance:n,category:"@@_Viewer.Category.ENTITY",entity:e};else {if(!(e instanceof h$4))return void console.log("unknown target");this._pick_result={position:r,distance:n,category:"@@_Viewer.Category.POINT_CLOUD",point_cloud:e};}}}_draw_flake_base_rid_check(){var e,t;return -1===(null!==(t=null===(e=this._pickOption.exclude_category)||void 0===e?void 0:e.indexOf("@@_Viewer.Category.GROUND"))&&void 0!==t?t:-1)}_draw_entities_on_flake_rid_check(){var e,t;return -1===(null!==(t=null===(e=this._pickOption.exclude_category)||void 0===e?void 0:e.indexOf("@@_Viewer.Category.ENTITY"))&&void 0!==t?t:-1)}_draw_entity(){var e,t;-1===(null!==(t=null===(e=this._pickOption.exclude_category)||void 0===e?void 0:e.indexOf("@@_Viewer.Category.ENTITY"))&&void 0!==t?t:-1)&&this._scene.draw(this);}_draw_point_cloud(){if(!(this._pickOption.exclude_category&&-1!==this._pickOption.exclude_category.indexOf("@@_Viewer.Category.POINT_CLOUD")))for(let e=0;e<this._point_cloud_collection.length;++e){const t=this._point_cloud_collection.get(e);if(!t.getVisibility())continue;const i=new i$e(this,0).traverse(t);i.visible_boxes.length>0&&this._pushPointCloudToRidMap(t);for(const e of i.visible_boxes)e.draw(this);t.provider.flushQueue();}}_draw_b3d(){var e,t;-1===(null!==(t=null===(e=this._pickOption.exclude_category)||void 0===e?void 0:e.indexOf("@@_Viewer.Category.B3D_SCENE"))&&void 0!==t?t:-1)&&this._viewer.b3d_collection.draw(this);}_draw_extras(){}_draw_sky_layer(){}get pick_result(){return this._pick_result}},(_=i.RenderTarget||(i.RenderTarget={})).SCENE="SCENE",_.RID="RID",i.ListOfRenderTarget=["SCENE","RID"];}(n$F||(n$F={}));var l$5=n$F;

class e$g extends a$g{constructor(r,o,s,t,i,n){super(),this._prefix=r,this._suffix=o,this._size=s,this._min_level=t,this._max_level=i;let _=null;n&&n.coord_order&&(n.coord_order===e$g.CoordOrder.ZYX?_=function(r,e,o){return r+"/"+o+"/"+e}:n.coord_order===e$g.CoordOrder.XYZ&&(_=function(r,e,o){return e+"/"+o+"/"+r}));const c=_||function(r,e,o){return r+"/"+e+"/"+o};let d=null;n&&n.coord_system&&n.coord_system===e$g.CoordSystem.LOWER_LEFT&&(d=function(r,e,o){var s=Math.round(Math.pow(2,r));return c(r,e,s-o-1)}),d||(d=c),this._coords_part=d,this._crossOrigin="anonymous",n&&n.credentials&&("omit"===n.credentials?this._crossOrigin=null:"include"===n.credentials&&(this._crossOrigin="use-credentials"));}requestTile(r,e,o,s){var t=new Image;return t.onload=function(){s(t);},t.onerror=function(){s(null);},null!==this._crossOrigin&&(t.crossOrigin=this._crossOrigin),t.src=this._makeURL(r,e,o),t}cancelRequest(r){}getImageSize(){return this._size}getZoomLevelRange(){return new a$g.Range(this._min_level,this._max_level)}_makeURL(r,e,o){return this._prefix+this._coords_part(r,e,o)+this._suffix}}!function(r){var e,o;(e=r.CoordOrder||(r.CoordOrder={}))[e.ZXY=0]="ZXY",e[e.ZYX=1]="ZYX",e[e.XYZ=2]="XYZ",(o=r.CoordSystem||(r.CoordSystem={}))[o.UPPER_LEFT=0]="UPPER_LEFT",o[o.LOWER_LEFT=1]="LOWER_LEFT";}(e$g||(e$g={}));var o$d=e$g;

class t$g extends e$n{constructor(e,t,s={}){super(),this._prefix=e,this._suffix=t,this._credentials=s.credentials||"omit",this._headers=Object.assign({},s.headers);}requestTile(e,t,s,r){const i=new AbortController;return fetch(this._makeURL(e,t,s),{credentials:this._credentials,headers:this._headers,signal:i.signal}).then((e=>e.ok?e.arrayBuffer():Promise.reject(Error(e.statusText)))).then((e=>{r(e);})).catch((()=>{r(null);})),i}cancelRequest(e){e.abort();}_makeURL(e,t,s){return this._prefix+e+"/"+t+"/"+s+this._suffix}}

class r$c{constructor(e,r){if(this._viewer=e,this._glenv=e.glenv,this._layers=[],r)for(let e=0;e<r.length;++e)this.add(r[e]);}get viewer(){return this._viewer}get glenv(){return this._glenv}get num_layers(){return this._layers.length}getLayer(e){return this._layers[e]}clear(){for(;this.num_layers>0;)this.remove(0);}add(e){this.insert(this.num_layers,e);}insert(r,t){this._layers.splice(r,0,new _$7(this,t)),this.dirtyDrawingLayers();}remove(e){this._layers.splice(e,1),this.dirtyDrawingLayers();}get num_drawing_layers(){return this._draw_layers||(this._draw_layers=this._updateDrawingLayers()),this._draw_layers.length}getDrawingLayer(e){return this._draw_layers||(this._draw_layers=this._updateDrawingLayers()),this._draw_layers[e]}endFrame(){const e=this._layers;for(let r=0;r<e.length;++r)e[r].tile_cache.endFrame();}cancel(){const e=this._layers;for(let r=0;r<e.length;++r)e[r].tile_cache.cancel();}dirtyDrawingLayers(){this._draw_layers=void 0;}_updateDrawingLayers(){const e=this.num_layers,r=[];for(let t=0;t<e;++t){const e=this._layers[t];"@@_ImageProvider.Status.READY"===e.image_provider.status()&&!0===e.visibility&&r.push(e);}return r}}

class e$f{constructor(t){this._scene=t,this._items=[];}get length(){return this._items.length}get(t){return this._items[t]}add(t){return this.insert(this.length,t)}insert(e,s){const i=new h$4(this._scene,s);return this._items.splice(e,0,i),i.init(),i}removeByIndex(t){const e=this._items.splice(t,1)[0];return e.destroy(),e}remove(t){const e=this._items.indexOf(t);if(-1===e)throw new Error("Couldn't find item: "+t);this.removeByIndex(e);}}

class t$f{constructor(t,i){this._viewer=t,this._glenv=i,this._enode_list=[],this._loaders=[];const n=new i$u;n.addDescendantUnbinder((()=>{this._unbindDescendantAnimations();})),this._animation=n;}get glenv(){return this._glenv}get viewer(){return this._viewer}get animation(){return this._animation}get num_entities(){return this._enode_list.length}clearEntities(){this._enode_list=[];}addEntity(e){if(e.scene!==this)throw new Error("invalid entity");this._enode_list.push(new t$f.ENode(e));}removeEntity(e){for(var t=this._enode_list,i=0;i<t.length;++i)if(t[i].entity===e){t.splice(i,1);break}}getEntity(e){return this._enode_list[e].entity}draw(e){this._prepare_entities();var t=[],i=[],n=[];for(let{entity:r}of this._enode_list)r.visibility&&("RID"!==e.getRenderTarget()||r.isPickable())&&this._add_primitives(e,r,t,i,n);this._draw_opaque_primitives(e,t),this._draw_translucent_primitives(e,i),this._draw_anchor_primitives(e,n);}_prepare_entities(){var e=this._viewer.globe.dem_area_updated;for(let i of this._enode_list){let n=i.entity.getPrimitiveProducer();if(n&&n.needsElevation())if(n.checkToCreateRegions()||!i.regions)i.regions=n.createRegions(),i.regions.length>0&&(i.regions.forEach((e=>{e.compile();})),n.onChangeElevation(i.regions));else {if(e.isEmpty())continue;var t=[];i.regions.forEach((i=>{i.intersectsWith(e)&&t.push(i);})),t.length>0&&n.onChangeElevation(t);}}}_add_primitives(e,t,i,n,r){let s=t.getPrimitiveProducer();if(s)for(let o of s.getPrimitives(e))if(o.isVisible(e)){let s=t.anchor_mode?r:o.isTranslucent(e)?n:i;e.onPushPrimitive(o,t),s.push(o);}}_draw_opaque_primitives(e,t){t.sort((function(e,t){return t.sort_z-e.sort_z}));var i=this._glenv.context;i.disable(i.BLEND),i.depthMask(!0);for(var n=0;n<t.length;++n)t[n].draw(e);}_draw_translucent_primitives(e,t){t.sort((function(e,t){return e.sort_z-t.sort_z}));var i=this._glenv.context;"SCENE"===e.getRenderTarget()?i.enable(i.BLEND):i.disable(i.BLEND),i.depthMask(!1);for(var n=0;n<t.length;++n)t[n].draw(e);i.disable(i.BLEND),i.depthMask(!0);}_draw_anchor_primitives(e,t){t.sort((function(e,t){return t.sort_z-e.sort_z}));var i=this._glenv.context;i.disable(i.DEPTH_TEST),i.depthMask(!1),"SCENE"===e.getRenderTarget()?(e.setTranslucentMode(!0),i.enable(i.BLEND)):i.disable(i.BLEND);for(var n=t.length-1;n>=0;--n)t[n].draw(e);i.depthMask(!0),i.enable(i.DEPTH_TEST),e.setTranslucentMode(!1);for(n=0;n<t.length;++n)t[n].draw(e);i.disable(i.BLEND);}cancelLoaders(){for(var e=this._loaders.concat(),t=0;t<e.length;++t)e[t].cancel();}addLoader(e){this._loaders.push(e);}removeLoader(e){var t=this._loaders.indexOf(e);t>=0&&this._loaders.splice(t,1);}getFlakePrimitiveProducers(){let e=[];for(let{entity:t}of this._enode_list){if(!t.visibility)continue;let i=t.getFlakePrimitiveProducer();i&&e.push(i);}return e}_unbindDescendantAnimations(){for(let{entity:e}of this._enode_list)e.animation.unbindAllRecursively();}}!function(e){e.ENode=class{constructor(e){this.entity=e,this.regions=void 0;}};}(t$f||(t$f={}));var i$d=t$f;

class t$e{constructor(t){this._emod=t,this._src_binary=null,this._clip_result=null,this._ray_result=null;const i=t.addFunction((t=>{this._emod.HEAPU8.set(this._src_binary,t),this._src_binary=null;}),"vi"),e=t.addFunction(((t,i,e)=>{this._clip_result.call(null,t,i,this._emod.HEAPU8.buffer,e),this._clip_result=null;}),"viii"),s=t.addFunction(((t,i,e)=>{this._ray_result.call(null,t,i,e),this._ray_result=null;}),"vddd");t._initialize(i,e,s);}addBinary(t){return this._src_binary=t,this._emod._tile_create(t.byteLength)}removeBinary(t){return this._emod._tile_destroy(t)}getDescendantDepth(t,i,e){const s=i[0],_=i[1],n=i[2];return this._emod._tile_get_descendant_depth(t,s,_,n,e)}clip(t,i,e,s){const _=i[0],n=i[1],l=i[2];this._clip_result=s,this._emod._tile_clip(t,_,n,l,e);}findRayDistance(t,i,e,s,_,n){this._ray_result=n,this._emod._tile_find_ray_distance(t,i.position[0],i.position[1],i.position[2],i.direction[0],i.direction[1],i.direction[2],e,s[0],s[1],s[2],_);}}

class e$e{constructor(e,t,r){this._glenv=e,this._handle=this._createTexture(t,null!=r?r:{});}get handle(){return this._handle}dispose(){this._glenv.context.deleteTexture(this._handle),this._handle=null;}_createTexture(t,r){var _;const a=this._glenv.context,E=a.TEXTURE_2D,i=a.createTexture();if(null===i)throw new Error("Failed to create texture");const s=e$e._getParameters(a,r);a.bindTexture(E,i);const n=null===(_=r.flip_y)||void 0===_||_;return a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,n),"@@_Usage.COLOR"===r.usage?a.texImage2D(E,0,s.format,1,1,0,s.format,s.type,e$e._getColorArray(r)):a.texImage2D(E,0,s.format,s.format,s.type,t),n&&a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,!1),e$e._generateMipmapQ(a,s)&&a.generateMipmap(E),a.texParameteri(E,a.TEXTURE_MAG_FILTER,s.mag_filter),a.texParameteri(E,a.TEXTURE_MIN_FILTER,s.min_filter),a.texParameteri(E,a.TEXTURE_WRAP_S,s.wrap_s),a.texParameteri(E,a.TEXTURE_WRAP_T,s.wrap_t),a.bindTexture(E,null),i}static _getParameters(e,t){const r={format:e.RGBA,type:e.UNSIGNED_BYTE,mag_filter:e.LINEAR,min_filter:e.LINEAR_MIPMAP_LINEAR,wrap_s:e.REPEAT,wrap_t:e.REPEAT};return "@@_Usage.SIMPLETEXT"===t.usage?(r.format=e.ALPHA,r.min_filter=e.LINEAR,r.wrap_s=e.CLAMP_TO_EDGE,r.wrap_t=e.CLAMP_TO_EDGE):"@@_Usage.TEXT"===t.usage?(r.min_filter=e.LINEAR,r.wrap_s=e.CLAMP_TO_EDGE,r.wrap_t=e.CLAMP_TO_EDGE):"@@_Usage.COLOR"===t.usage?(r.mag_filter=e.NEAREST,r.min_filter=e.NEAREST):"@@_Usage.ICON"===t.usage&&(r.min_filter=e.LINEAR,r.wrap_s=e.CLAMP_TO_EDGE,r.wrap_t=e.CLAMP_TO_EDGE),void 0!==t.mag_filter&&(r.mag_filter=t.mag_filter),void 0!==t.min_filter&&(r.min_filter=t.min_filter),void 0!==t.wrap_s&&(r.wrap_s=t.wrap_s),void 0!==t.wrap_t&&(r.wrap_t=t.wrap_t),r}static _getColorArray(e){var t;const r=(null!==(t=e.color)&&void 0!==t?t:[1,1,1,1]).map((e=>Math.round(255*e)));return new Uint8Array(r)}static _generateMipmapQ(e,t){const r=t.min_filter;return r==e.NEAREST_MIPMAP_NEAREST||r==e.LINEAR_MIPMAP_NEAREST||r==e.NEAREST_MIPMAP_LINEAR||r==e.LINEAR_MIPMAP_LINEAR}}!function(e){var t;(t=e.Usage||(e.Usage={})).GENERAL="@@_Usage.GENERAL",t.COLOR="@@_Usage.COLOR",t.TEXT="@@_Usage.TEXT",t.SIMPLETEXT="@@_Usage.SIMPLETEXT",t.ICON="@@_Usage.ICON";}(e$e||(e$e={}));var t$d=e$e;

class i$c{constructor(t,e,r,_){this._glenv=t,this._native=e,this._handle=e.addBinary(r);const s=new DataView(r.buffer,r.byteOffset,r.byteLength),a=s.getUint16(i$c.OFFSET_DESCENDANTS+0,!0),o=s.getUint16(i$c.OFFSET_DESCENDANTS+2,!0);this._void_areas=0,this._is_leaf=!0;for(let t=0;t<8;++t){const e=2*t,n=(o&3<<e)>>e;0==n?this._void_areas+=1<<t:this._is_leaf&&n>=2&&(this._is_leaf=!1);}if(this._contents=s.getUint32(i$c.OFFSET_DESCENDANTS+4*a,!0),this._texture=null,null!==_){const e=t.context;this._texture=new t$d(t,_,{mag_filter:e.LINEAR,min_filter:e.LINEAR,wrap_s:e.CLAMP_TO_EDGE,wrap_t:e.CLAMP_TO_EDGE});}}static async create(t,e,n){const r=new DataView(n);let _=i$c.OFFSET_VECDATA_PART;const s=r.getUint32(i$c.OFFSET_VECDATA_SIZE,!0),a=new Uint8Array(n,_,s);_+=s;let o=null;const l=r.getUint32(i$c.OFFSET_TEXIMAGE_SIZE,!0);if(l>0){const t=new Uint8Array(n,_,l);_+=l,o=await i$c._create_teximage(t);}return new i$c(t,e,a,o)}static async _create_teximage(t){const e=new DataView(t.buffer,t.byteOffset,t.byteLength),n=e.getUint32(i$c.OFFSET_MIME_TYPE_SIZE,!0);let _=i$c.OFFSET_MIME_TYPE;const s=(new TextDecoder).decode(new Uint8Array(t.buffer,t.byteOffset+_,n));_+=r$b(n),e.getUint16(_,!0),_+=2,e.getUint16(_,!0),_+=2;const a=e.getUint32(_,!0);_+=4;const o=new Uint8Array(t.buffer,t.byteOffset+_,a),l=new Blob([o],{type:s});return i$c._create_image(l)}static _create_image(t){return new Promise(((e,n)=>{const i=URL.createObjectURL(t),r=new Image;r.onload=function(){e(r),URL.revokeObjectURL(i);},r.onerror=function(t){n(t),URL.revokeObjectURL(i);},r.src=i;}))}isVoidArea(t){return 0!=(this._void_areas&1<<t)}isLeaf(){return this._is_leaf}getDescendantDepth(t,e){return this._native.getDescendantDepth(this._handle,t,e)}getTexture(){return this._texture}clip(n,_){let s=null;return this._native.clip(this._handle,n,_,((n,_,a,o)=>{if(0==_)return;const l=n>65536?Uint32Array:Uint16Array;let E=o;const T=new Uint16Array(a,E,3*n);E+=r$b(T.byteLength);const c=new l(a,E,3*_);E+=r$b(c.byteLength);let h=null;0!=(this._contents&i$c.CONTENTS_MASK_N_ARRAY)&&(h=new Int8Array(a,E,3*n),E+=r$b(h.byteLength));let A=null;0!=(this._contents&i$c.CONTENTS_MASK_TC_ARRAY)&&(A=new Uint16Array(a,E,2*n),E+=r$b(A.byteLength));const u=new r$h.Initializer(r$h.DrawMode.TRIANGLES,n),S=n>65536?r$h.ComponentType.UNSIGNED_INT:r$h.ComponentType.UNSIGNED_SHORT;u.addIndex(new t$o(this._glenv,c,{target:t$o.Target.INDEX}),c.length,S),u.addAttribute("a_position",new t$o(this._glenv,T),3,r$h.ComponentType.UNSIGNED_SHORT,{normalized:!0}),null!==h&&u.addAttribute("a_normal",new t$o(this._glenv,h),3,r$h.ComponentType.BYTE,{normalized:!0}),null!==A&&u.addAttribute("a_texcoord",new t$o(this._glenv,A),2,r$h.ComponentType.UNSIGNED_SHORT,{normalized:!0}),s=new r$h(this._glenv,u);})),s}getRayIntersection(t,e,n,i){let r=null;return this._native.findRayDistance(this._handle,t,e,n,i,((t,n,i)=>{t!=e&&(r={distance:t,feature_id:[n,i]});})),r}dispose(){this._native.removeBinary(this._handle),this._handle=0,null!==this._texture&&(this._texture.dispose(),this._texture=null);}}function r$b(t){return 4*Math.ceil(t/4)}i$c.OFFSET_VECDATA_SIZE=0,i$c.OFFSET_TEXIMAGE_SIZE=4,i$c.OFFSET_VECDATA_PART=8,i$c.OFFSET_DESCENDANTS=0,i$c.CONTENTS_MASK_N_ARRAY=1,i$c.CONTENTS_MASK_TC_ARRAY=2,i$c.OFFSET_MIME_TYPE_SIZE=0,i$c.OFFSET_MIME_TYPE=4;

var n$E="attribute vec4 a_position;  // 位置 (ALCS)\nattribute vec3 a_normal;    // 法線 (ALCS)\nattribute vec2 a_texcoord;  // テクスチャ座標\n\nuniform mat4 u_obj_to_clip;  // ALCS からクリップ座標系への変換\nuniform mat4 u_obj_to_view;  // ALCS から視点座標系への変換\n\nvarying vec3 v_normal;    // 法線 (視点座標系)\nvarying vec2 v_texcoord;  // テクスチャ座標\n\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n\n    v_normal = normalize( vec3( u_obj_to_view * vec4( a_normal, 0.0 ) ) );  // 法線 (視点座標系)\n\n    v_texcoord = a_texcoord;\n}\n";

var n$D="precision highp float;\n\nvarying vec3 v_normal;    // 法線 (視点座標系)\nvarying vec2 v_texcoord;  // テクスチャ座標\n\nuniform vec3      u_light_dir;   // ライト逆方向 (視点座標系) と強さ\nuniform float     u_ambient;     // 環境光\nuniform sampler2D u_teximage;    // タイル TEXIMAGE_PART 画像\nuniform vec3      u_clip_color;  // テスト用\n\n\nvoid\nmain()\n{\n    vec3 normal = normalize( v_normal );  // 法線 (視点座標系)\n\n    float dlit = dot( normal, u_light_dir );  // 拡散光の強さ\n    dlit += u_ambient;\n\n    vec3 txi_color = texture2D( u_teximage, v_texcoord ).rgb;\n\n    gl_FragColor = vec4( vec3( dlit ) * txi_color, 1.0 );\n\n#ifdef CLIP_COLORING\n    // クリップされたタイルを着色\n    gl_FragColor += vec4( u_clip_color, 0 );\n#endif\n}\n";

class o$c extends e$o{constructor(t,i){const s=o$c._getPreamble(i);super(t,s+n$E,s+(i.ridMaterial?n$T:n$D)),this.bindProgram(),this.setInteger("u_teximage",o$c.TEXUNIT_TEXIMAGE),i.ridMaterial&&this._setRenderId(2),this._clip_coloring=i.clip_coloring;}setParameters(t,e,r){let _=o$c._obj_to_clip;e$z.mul_GA(t._a0cs_to_clip,e,_),this.setMatrix("u_obj_to_clip",_);let s=o$c._obj_to_view;e$z.mul_AA(t._a0cs_to_view,e,s),this.setMatrix("u_obj_to_view",s),this.setVector3("u_light_dir",[0,0,.5]),this.setFloat("u_ambient",.5),this.bindTexture2D(o$c.TEXUNIT_TEXIMAGE,r.handle),this._clip_coloring&&this.setVector3("u_clip_color",t._clip_flag?[0,0,.2]:[0,0,0]);}static _getPreamble(t){const i=[];return t.clip_coloring&&i.push("#define CLIP_COLORING"),i.join("\n")+"\n\n"}}o$c.TEXUNIT_TEXIMAGE=0,o$c._obj_to_clip=e$z.createMatrixf(),o$c._obj_to_view=e$z.createMatrixf();

var n$C="attribute vec4 a_position;    // 位置 (ALCS)\n\nuniform mat4 u_obj_to_clip;   // ALCS からクリップ座標系への変換\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n}\n";

var n$B="uniform lowp vec3 u_color;\n\n\nvoid\nmain()\n{\n    gl_FragColor = vec4( u_color, 1.0 );\n}\n";

class s$a extends e$o{constructor(t){super(t,n$C,n$B);}setParameters(t,o,e){let _=s$a._obj_to_clip;e$z.mul_GA(t._a0cs_to_clip,o,_),this.setMatrix("u_obj_to_clip",_),this.setVector3("u_color",e);}}s$a._obj_to_clip=e$z.createMatrixf();

var t$c,n$A=(t$c="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(n){var e,r;(n=void 0!==(n=n||{})?n:{}).ready=new Promise((function(t,n){e=t,r=n;}));var i,a={};for(i in n)n.hasOwnProperty(i)&&(a[i]=n[i]);var o="";"undefined"!=typeof document&&document.currentScript&&(o=document.currentScript.src),t$c&&(o=t$c),o=0!==o.indexOf("blob:")?o.substr(0,o.lastIndexOf("/")+1):"",n.print||console.log.bind(console);var u=n.printErr||console.warn.bind(console);for(i in a)a.hasOwnProperty(i)&&(n[i]=a[i]);a=null,n.arguments&&n.arguments,n.thisProgram&&n.thisProgram,n.quit&&n.quit;var s,c,l,f=[];function p(t,n){if(!s){s=new WeakMap;for(var e=0;e<h.length;e++){var r=h.get(e);r&&s.set(r,e);}}if(s.has(t))return s.get(t);var i=function(){if(f.length)return f.pop();try{h.grow(1);}catch(t){if(!(t instanceof RangeError))throw t;throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH."}return h.length-1}();try{h.set(i,t);}catch(e){if(!(e instanceof TypeError))throw e;var a=function(t,n){if("function"==typeof WebAssembly.Function){for(var e={i:"i32",j:"i64",f:"f32",d:"f64"},r={parameters:[],results:"v"==n[0]?[]:[e[n[0]]]},i=1;i<n.length;++i)r.parameters.push(e[n[i]]);return new WebAssembly.Function(r,t)}var a=[1,0,1,96],o=n.slice(0,1),u=n.slice(1),s={i:127,j:126,f:125,d:124};for(a.push(u.length),i=0;i<u.length;++i)a.push(s[u[i]]);"v"==o?a.push(0):a=a.concat([1,s[o]]),a[1]=a.length-2;var c=new Uint8Array([0,97,115,109,1,0,0,0].concat(a,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),l=new WebAssembly.Module(c);return new WebAssembly.Instance(l,{e:{f:t}}).exports.f}(t,n);h.set(i,a);}return s.set(t,i),i}n.wasmBinary&&(c=n.wasmBinary),n.noExitRuntime&&n.noExitRuntime,"object"!=typeof WebAssembly&&I("no native wasm support detected");var m,d,y=!1;function _(t){m=t,n.HEAP8=new Int8Array(t),n.HEAP16=new Int16Array(t),n.HEAP32=new Int32Array(t),n.HEAPU8=d=new Uint8Array(t),n.HEAPU16=new Uint16Array(t),n.HEAPU32=new Uint32Array(t),n.HEAPF32=new Float32Array(t),n.HEAPF64=new Float64Array(t);}"undefined"!=typeof TextDecoder&&new TextDecoder("utf8"),"undefined"!=typeof TextDecoder&&new TextDecoder("utf-16le");var h,w=n.INITIAL_MEMORY||262144;(l=n.wasmMemory?n.wasmMemory:new WebAssembly.Memory({initial:w/65536,maximum:32768}))&&(m=l.buffer),w=m.byteLength,_(m);var b=[],g=[],v=[],A=[],R=0,W=null;function I(t){n.onAbort&&n.onAbort(t),u(t+=""),y=!0,t="abort("+t+"). Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(t);throw r(e),e}function E(t){return n=t,e="data:application/octet-stream;base64,",String.prototype.startsWith?n.startsWith(e):0===n.indexOf(e);var n,e;}n.preloadedImages={},n.preloadedAudios={};var S,x="b3dtile.wasm";function P(){try{if(c)return new Uint8Array(c);throw "both async and sync fetching of the wasm failed"}catch(t){I(t);}}function k(t){for(;t.length>0;){var e=t.shift();if("function"!=typeof e){var r=e.func;"number"==typeof r?void 0===e.arg?h.get(r)():h.get(r)(e.arg):r(void 0===e.arg?null:e.arg);}else e(n);}}function T(t){try{return l.grow(t-m.byteLength+65535>>>16),_(l.buffer),1}catch(t){}}E(x)||(S=x,x=n.locateFile?n.locateFile(S,o):o+S),g.push({func:function(){H();}});var M={abort:function(){I();},emscripten_memcpy_big:function(t,n,e){d.copyWithin(t,n,n+e);},emscripten_resize_heap:function(t){t>>>=0;var n,e,r=d.length,i=2147483648;if(t>i)return !1;for(var a=1;a<=4;a*=2){var o=r*(1+.5/a);if(T(Math.min(i,((n=Math.max(t,o))%(e=65536)>0&&(n+=e-n%e),n))))return !0}return !1},memory:l};!function(){var t={env:M,wasi_snapshot_preview1:M};function e(t,e){var r=t.exports;n.asm=r,h=n.asm.__indirect_function_table,function(t){if(R--,n.monitorRunDependencies&&n.monitorRunDependencies(R),0==R&&W){var e=W;W=null,e();}}();}function i(t){e(t.instance);}function a(n){return (c||"function"!=typeof fetch?Promise.resolve().then(P):fetch(x,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw "failed to load wasm binary file at '"+x+"'";return t.arrayBuffer()})).catch((function(){return P()}))).then((function(n){return WebAssembly.instantiate(n,t)})).then(n,(function(t){u("failed to asynchronously prepare wasm: "+t),I(t);}))}if(R++,n.monitorRunDependencies&&n.monitorRunDependencies(R),n.instantiateWasm)try{return n.instantiateWasm(t,e)}catch(t){return u("Module.instantiateWasm callback failed with error: "+t),!1}(c||"function"!=typeof WebAssembly.instantiateStreaming||E(x)||"function"!=typeof fetch?a(i):fetch(x,{credentials:"same-origin"}).then((function(n){return WebAssembly.instantiateStreaming(n,t).then(i,(function(t){return u("wasm streaming compile failed: "+t),u("falling back to ArrayBuffer instantiation"),a(i)}))}))).catch(r);}();var F,H=n.___wasm_call_ctors=function(){return (H=n.___wasm_call_ctors=n.asm.__wasm_call_ctors).apply(null,arguments)};function O(t){function r(){F||(F=!0,n.calledRun=!0,y||(k(g),k(v),e(n),n.onRuntimeInitialized&&n.onRuntimeInitialized(),function(){if(n.postRun)for("function"==typeof n.postRun&&(n.postRun=[n.postRun]);n.postRun.length;)t=n.postRun.shift(),A.unshift(t);var t;k(A);}()));}R>0||(function(){if(n.preRun)for("function"==typeof n.preRun&&(n.preRun=[n.preRun]);n.preRun.length;)t=n.preRun.shift(),b.unshift(t);var t;k(b);}(),R>0||(n.setStatus?(n.setStatus("Running..."),setTimeout((function(){setTimeout((function(){n.setStatus("");}),1),r();}),1)):r()));}if(n._initialize=function(){return (n._initialize=n.asm.initialize).apply(null,arguments)},n._tile_create=function(){return (n._tile_create=n.asm.tile_create).apply(null,arguments)},n._tile_destroy=function(){return (n._tile_destroy=n.asm.tile_destroy).apply(null,arguments)},n._tile_get_descendant_depth=function(){return (n._tile_get_descendant_depth=n.asm.tile_get_descendant_depth).apply(null,arguments)},n._tile_clip=function(){return (n._tile_clip=n.asm.tile_clip).apply(null,arguments)},n._tile_find_ray_distance=function(){return (n._tile_find_ray_distance=n.asm.tile_find_ray_distance).apply(null,arguments)},n.___errno_location=function(){return (n.___errno_location=n.asm.__errno_location).apply(null,arguments)},n.stackSave=function(){return (n.stackSave=n.asm.stackSave).apply(null,arguments)},n.stackRestore=function(){return (n.stackRestore=n.asm.stackRestore).apply(null,arguments)},n.stackAlloc=function(){return (n.stackAlloc=n.asm.stackAlloc).apply(null,arguments)},n.addFunction=function(t,n){return p(t,n)},W=function t(){F||O(),F||(W=t);},n.run=O,n.preInit)for("function"==typeof n.preInit&&(n.preInit=[n.preInit]);n.preInit.length>0;)n.preInit.pop()();return O(),n.ready});

class d$3{constructor(e,t){this._owner=e,this._provider=t,this._glenv=e.viewer.glenv,this._status=g$5.NOT_READY,this._native=null,this._root_cube=null,this._visibility=!0,this._rho=void 0,this._a0cs_to_gocs=void 0,this._gocs_to_a0cs=void 0,this._lod_factor=d$3.DEFAULT_LOD_FACTOR,this._frame_counter=0,this._num_tree_cubes=0,this._num_touch_cubes=0,this._hist_stats=new m$7,this._num_tree_meshes=0,this._num_touch_meshes=0,this._num_tile_requesteds=0,this._b3d_req_id=void 0,e.getWasmModule()&&this._startInitialization(e.getWasmModule());}get provider(){return this._provider}get visibility(){return this._visibility}get lod_factor(){return this._lod_factor}setVisibility(e){this._visibility=e;}setLodFactor(e){this._lod_factor=e;}onLoadWasmModule(){this._status!==g$5.FAILED&&this._startInitialization(this._owner.getWasmModule());}cancel(){if(this._status===g$5.NOT_READY)this._b3d_req_id&&(this._provider.cancelRequest(this._b3d_req_id),this._b3d_req_id=void 0);else if(this._status===g$5.READY)for(let e of this._root_cube.getCubesFlattened())e.cancelTileRequest();this._status=g$5.FAILED;}draw(e){this._status===g$5.READY&&this._visibility&&this._owner.viewer.getVisibility(x.Category.B3D_SCENE)&&new u$4(this,e).render();}endFrame(){0!=this._num_touch_cubes&&(this._reduceCubesIfNecessary(),this._reduceMeshesIfNecessary(),this._num_touch_cubes=0,this._num_touch_meshes=0,++this._frame_counter);}getRayIntersection(e,s){if(this._status!==g$5.READY)return null;if(!this._visibility)return null;const i=o$o.transform_A(this._gocs_to_a0cs,e,new o$o);return this._root_cube.isAreaCross(i,s)?this._root_cube.getRayIntersectionOnTree(i,s):null}async _startInitialization(e){try{const t=await this._getMetaData();this._setupMetadata(t);const[s,i]=await Promise.all([this._getRootTileArray(),t$x.createEmObjectByModule(e,n$A)]);this._native=new t$e(i);const a=await i$c.create(this._glenv,this._native,s);this._root_cube=new c$4(null,-1),this._root_cube.$$setupRootNode(this,a),this._status=g$5.READY;}catch(e){console.error("b3dtile error: "+e.message),this._status=g$5.FAILED;}this._b3d_req_id=void 0;}_getMetaData(){return new Promise(((e,t)=>{this._b3d_req_id=this._provider.requestMeta((s=>{null!==s?e(s):t(new Error("failed to get metadata for b3dtile"));}));}))}_getRootTileArray(){return new Promise(((e,t)=>{this._b3d_req_id=this._provider.requestTile(0,[0,0,0],(s=>{null!==s?e(s):t(new Error("failed to get a tile data for b3dtile"));}));}))}_setupMetadata(t){let s=1;if(void 0===t.format||t.format>2)throw Error("unrecognized b3dtile metadata format");if(void 0!==t.tile_format&&(s=t.tile_format),s<=1)throw Error("tile_format "+s+" is no longer supported");if(s>2)throw Error("tile_format "+s+" is unrecognized");this._rho=t.rho,this._a0cs_to_gocs=e$z.createMatrix(t.transform),this._gocs_to_a0cs=e$z.inverse_A(this._a0cs_to_gocs,e$z.createMatrix());}_reduceCubesIfNecessary(){const e=this._hist_stats.getMaxValue(this._num_touch_cubes);if(this._num_tree_cubes<=d$3.CUBE_REDUCE_THRESH*e)return;const t=this._root_cube.getCubesFlattened();t.sort(((e,t)=>e.compareForReduce(t)));const s=Math.floor(d$3.CUBE_REDUCE_FACTOR*e);for(let e of t.slice(s))e.dispose();}_reduceMeshesIfNecessary(){if(this._num_tree_meshes<=d$3.MESH_REDUCE_LOWER)return;if(this._num_tree_meshes<=d$3.MESH_REDUCE_THRESH*this._num_touch_meshes)return;const e=this._root_cube.getMeshesFlattened();e.sort(((e,t)=>e.compareForReduce(t)));const t=Math.floor(d$3.MESH_REDUCE_FACTOR*this._num_touch_meshes);for(let s of e.slice(t))s.dispose();}}class u$4{constructor(t,s){this._provider=t._provider,this._glenv=s._glenv,this._native=t._native,this._debug=t._owner.$debug,this._shader_cache=t._owner.shader_cache,this._render_target=s.getRenderTarget(),this._a0cs_to_view=e$z.mul_AA(s._gocs_to_view,t._a0cs_to_gocs,e$z.createMatrix()),this._a0cs_to_clip=e$z.mul_PzA(s._view_to_clip,this._a0cs_to_view,e$z.createMatrix()),this._volume_planes=[];for(let t of s._volume_planes){let s=e$z.transformPlane_A(this._a0cs_to_view,t,e$z.createVector4());this._volume_planes.push(s);}this._depth_plane=e$z.transformPlane_A(this._a0cs_to_view,[0,0,-1,0],e$z.createVector4()),e$z.normalizePlane(this._depth_plane,this._depth_plane);const i=Math.max(t.lod_factor,d$3.MIN_LOD_FACTOR);this._lod_offset=-Math.log2(i*s._pixel_step)-t._rho,this._root_cube=t._root_cube,this._mesh_node_list=null;}render(){this._traverse(),this._draw_meshes();}_traverse(){this._mesh_node_list=[],this._traverse_recur(this._root_cube);}_traverse_recur(e){if(e.touch(),this._isInvisible(e))return;const t=this._get_tile_target_level(e);if(t<0){const t=e.getTileData();for(let s=0;s<8;++s)null!==t&&t.isVoidArea(s)||this._traverse_recur(e.newChild(s));}else {const s=e.getMeshNode(t);s.hasGeometry()&&this._mesh_node_list.push(s);}}_isInvisible(e){const t=e.area_size,s=e.area_origin;for(let e of this._volume_planes){let i=!0;for(let _=0;_<8;++_){const r=s[0]+t*(1&_),a=s[1]+t*(_>>1&1),n=s[2]+t*(_>>2&1);if(r*e[0]+a*e[1]+n*e[2]+e[3]>=0){i=!1;break}}if(i)return !0}return !1}_get_tile_target_level(t){const s=t.area_size/2,i=t.area_origin,_=i[0]+s,r=i[1]+s,a=i[2]+s,n=this._depth_plane,h=_*n[0]+r*n[1]+a*n[2]+n[3],o=s*d$3.RADIUS_FACTOR,l=h-o;if(l<=0)return -1;const u=this._lod_offset-e$z.maprayLog2(h+o),c=this._lod_offset-e$z.maprayLog2(l);if(c-u>=d$3.LEVEL_INTERVAL)return -1;const f=Math.max(Math.round((u+c)/2),0);return f<=t.level?f:-1}_draw_meshes(){let e=this._getMaterial(this._render_target);e.bindProgram();for(let t of this._mesh_node_list){this._clip_flag=t.isClipped(),e.setParameters(this,t.getTransform(),t.getTileTexture()),t.getTileMesh().draw(e);}if(1==this._debug.render_mode&&this._render_target==l$5.RenderTarget.SCENE){let e=this._getCubeMaterial();e.bindProgram();let t=[1,0,0];for(let s of this._mesh_node_list){e.setParameters(this,s.getTransform(),t),s.getAreaMesh(this._glenv).draw(e);}}}_getMaterial(e){let t=this._shader_cache;if(e===l$5.RenderTarget.SCENE)return void 0===t._B3dMaterial&&(t._B3dMaterial=new o$c(this._glenv,this._debug)),t._B3dMaterial;if(e===l$5.RenderTarget.RID)return void 0===t._B3dPickMaterial&&(this._debug.ridMaterial=!0,t._B3dPickMaterial=new o$c(this._glenv,this._debug)),t._B3dPickMaterial;throw new Error("unknown render target: "+e)}_getCubeMaterial(){let e=this._shader_cache;return void 0===e._B3dCubeMaterial&&(e._B3dCubeMaterial=new s$a(this._glenv)),e._B3dCubeMaterial}}class c$4{constructor(e,t){if(this._owner=void 0,this._parent=e,this._children=null,this._b3d_state=E$2.NONE,this._b3d_data=null,this._mesh_nodes=null,this._has_tile_in_descendants=!1,this._aframe=-1,this.area_origin=void 0,this.area_size=void 0,this.level=void 0,null===e)this.area_size=1,this.area_origin=[0,0,0],this.level=0;else {this._owner=e._owner,this.area_size=e.area_size/2,this.area_origin=new Array(3);for(let s=0;s<3;++s){const i=t>>s&1;this.area_origin[s]=e.area_origin[s]+i*this.area_size;}this.level=e.level+1,++this._owner._num_tree_cubes;}}newChild(e){null===this._children&&(this._children=new Array(8),this._children.fill(null));let t=this._children[e];return null===t&&(t=new c$4(this,e),this._children[e]=t),t}getTileData(){return this._b3d_state===E$2.LOADED?this._b3d_data:null}getMeshNode(e){const t=this._find_target_node(e);let s=null,i=null;for(let e=t;null!==e;e=e._parent){if(e._b3d_state===E$2.LOADED){s=e;break}e._b3d_state===E$2.FAILED&&null===i&&(i=e);}null===this._mesh_nodes&&(this._mesh_nodes=new Map);let _=this._mesh_nodes.get(s.level);return void 0===_&&(_=new f$1(this,s),this._mesh_nodes.set(s.level,_)),t._tryRequestTile(s,i),_.touch(),_}_find_target_node(e){let t=this;for(let s=0;s<this.level-e;++s)t=t._parent;return t}_tryRequestTile(e,t){if(this._owner._num_tile_requesteds>=d$3.MAX_TILE_REQUESTEDS)return;if(this===e)return;if(e._b3d_data.isLeaf())return;const s=this._create_node_routes(e);let i=c$4._find_request_candidate_node(e,s);if(null!==i){if(null!==t){if(s[0]===t)return;for(let e=1;e<s[e];++e){const _=s[e];if(_===t){i=s[e-1];break}if(_===i)break}}i._b3d_state!==E$2.REQUESTED&&i._requestTile();}}_create_node_routes(e){const t=new Array(this.level-e.level);let s=this;for(let e=t.length-1;e>=0;--e)t[e]=s,s=s._parent;return t}static _find_request_candidate_node(e,t){const s=t[t.length-1],i=new Array(3);for(let t=0;t<3;++t)i[t]=(s.area_origin[t]-e.area_origin[t])/e.area_size;const _=e._b3d_data.getDescendantDepth(i,t.length);if(_>0){return t[_-1]}return null}_requestTile(){const e=this._owner,t=new Array(3);for(let e=0;e<3;++e)t[e]=this.area_origin[e]/this.area_size;this._b3d_data=e._provider.requestTile(this.level,t,(async t=>{if(this._b3d_state===E$2.REQUESTED){if(null!==t){const s=await i$c.create(e._glenv,e._native,t);if(this._b3d_state!==E$2.REQUESTED)return;this._b3d_state=E$2.LOADED,this._b3d_data=s,this._update_tile_in_descendants_for_load();}else this._b3d_state=E$2.FAILED,this._b3d_data=null;--e._num_tile_requesteds;}})),++e._num_tile_requesteds,this._b3d_state=E$2.REQUESTED;}cancelTileRequest(){if(this._b3d_state===E$2.REQUESTED){const e=this._owner;e._provider.cancelRequest(this._b3d_data),this._b3d_state=E$2.NONE,this._b3d_data=null,--e._num_tile_requesteds;}}touch(){const e=this._owner;this._aframe!==e._frame_counter&&(this._aframe=e._frame_counter,++e._num_touch_cubes);}isAreaCross(e,t){return p(this.area_origin,this.area_size,e,t)!=t}getRayIntersectionOnTree(e,t){if(this._has_tile_in_descendants){for(let s of this._children_in_crossing_order(e,t)){let i;if(i=s instanceof c$4?s.getRayIntersectionOnTree(e,t):this._getRayIntersectionByPath(e,t,s),null!==i)return i}return null}return this._getRayIntersectionByPath(e,t,this)}_getRayIntersectionByPath(s,i,_){let r;for(r=this;null===r.getTileData();r=r._parent);const a=new o$o;for(let e=0;e<3;++e)a.position[e]=(s.position[e]-r.area_origin[e])/r.area_size,a.direction[e]=s.direction[e]/r.area_size;const n=e$z.createVector3(),h=_.area_size/r.area_size;for(let e=0;e<3;++e)n[e]=(_.area_origin[e]-r.area_origin[e])/r.area_size;return r.getTileData().getRayIntersection(a,i,n,h)}_children_in_crossing_order(t,s){const i=e$z.createVector3(),_=this.area_size/2,r=[];for(let a=0;a<8;++a){for(let e=0;e<3;++e)i[e]=this.area_origin[e]+_*(a>>e&1);const n=p(i,_,t,s);if(n!=s){let t=null!==this._children?this._children[a]:null;null===t&&(t={area_origin:e$z.createVector3(i),area_size:_}),r.push({distance:n,cinfo:t});}}r.sort(((e,t)=>e.distance-t.distance));const a=new Array(r.length);for(let e=0;e<r.length;++e)a[e]=r[e].cinfo;return a}dispose(){if(null===this._parent)return;if(this._b3d_state===E$2.REQUESTED?this.cancelTileRequest():this._b3d_state===E$2.LOADED&&this._b3d_data.dispose(),this._b3d_state=E$2.NONE,this._b3d_data=null,null!==this._mesh_nodes)for(let e of Array.from(this._mesh_nodes.values()))e.dispose();if(null!==this._children){for(let e of this._children)null!==e&&e.dispose();this._children=null;}this._has_tile_in_descendants=!1,null!==this._parent&&this._parent._update_tile_in_descendants_for_kill();const e=this._parent._children.indexOf(this);this._parent._children[e]=null,this._parent=null,--this._owner._num_tree_cubes;}_update_tile_in_descendants_for_load(){for(let e=this._parent;null!==e&&!e._has_tile_in_descendants;e=e._parent)e._has_tile_in_descendants=!0;}_update_tile_in_descendants_for_kill(){if(this._has_tile_in_descendants)for(let e=this;null!==e;e=e._parent){for(let t of e._children)if(null!==t&&t._has_tile_in_tree())return;e._has_tile_in_descendants=!1;}}_has_tile_in_tree(){return null!==this.getTileData()||this._has_tile_in_descendants}getCubesFlattened(){const e=[];return this.flattenCubesRecur(e),e}getMeshesFlattened(){const e=[];return this.flattenMeshesRecur(e),e}compareForReduce(e){let t=e,s=t._aframe-this._aframe;return 0!==s?s:this.level-t.level}flattenCubesRecur(e){if(e.push(this),null!==this._children)for(let t of this._children)null!==t&&t.flattenCubesRecur(e);}flattenMeshesRecur(e){if(null!==this._mesh_nodes)for(let t of this._mesh_nodes.values())e.push(t);if(null!==this._children)for(let t of this._children)null!==t&&t.flattenMeshesRecur(e);}$$setupRootNode(e,t){this._owner=e,this._b3d_state=E$2.LOADED,this._b3d_data=t,++e._num_tree_cubes;}}class f$1{constructor(t,s){this._cube=t,this._key=s.level,this._mesh_to_a0cs=f$1._get_area_to_a0cs(s),this._clip_size=t.area_size/s.area_size,this._clip_origin=e$z.createVector3();for(let e=0;e<3;++e)this._clip_origin[e]=(t.area_origin[e]-s.area_origin[e])/s.area_size;this._aframe=-1;++t._owner._num_tree_meshes,this._tile_mesh=s._b3d_data.clip(this._clip_origin,this._clip_size)||f$1.EMPTY_TILE_MESH,this._tile_texture=s._b3d_data.getTexture(),this._area_mesh=null;}isClipped(){return 1!=this._clip_size}hasGeometry(){return this._tile_mesh!==f$1.EMPTY_TILE_MESH}getTileMesh(){return this._tile_mesh}getTileTexture(){return this._tile_texture}getTransform(){return this._mesh_to_a0cs}getAreaMesh(e){if(null===this._area_mesh){const t={vtype:[{name:"a_position",size:3}],ptype:"lines",vertices:this._createCubeVertices(this._clip_origin,this._clip_size),indices:this._createCubeIndices()};this._area_mesh=new r$h(e,t);}return this._area_mesh}compareForReduce(e){return e._aframe-this._aframe}touch(){const e=this._cube._owner;this._aframe!==e._frame_counter&&(this._aframe=e._frame_counter,++e._num_touch_meshes);}dispose(){null!==this._tile_mesh&&this._tile_mesh!==f$1.EMPTY_TILE_MESH&&(this._tile_mesh.dispose(),this._tile_mesh=null),this._tile_texture=null,null!==this._area_mesh&&(this._area_mesh.dispose(),this._area_mesh=null);const e=this._cube;e._mesh_nodes.delete(this._key),0==e._mesh_nodes.size&&(e._mesh_nodes=null);--e._owner._num_tree_meshes;}_createCubeVertices(e,t){let s=new Float32Array(24);for(let i=0;i<8;++i)s[3*i]=e[0]+t*(1&i),s[3*i+1]=e[1]+t*(i>>1&1),s[3*i+2]=e[2]+t*(i>>2&1);return s}_createCubeIndices(){let e=new Uint16Array(24);return e[0]=0,e[1]=1,e[2]=2,e[3]=3,e[4]=4,e[5]=5,e[6]=6,e[7]=7,e[8]=0,e[9]=2,e[10]=1,e[11]=3,e[12]=4,e[13]=6,e[14]=5,e[15]=7,e[16]=0,e[17]=4,e[18]=1,e[19]=5,e[20]=2,e[21]=6,e[22]=3,e[23]=7,e}static _get_area_to_a0cs(t){const s=e$z.setIdentity(e$z.createMatrix());s[0]=t.area_size,s[5]=t.area_size,s[10]=t.area_size;for(let e=0;e<3;++e)s[12+e]=t.area_origin[e];return s}}class m$7{constructor(e=200){this._max_value=-Number.MAX_VALUE,this._history=new Float64Array(e),this._history.fill(this._max_value),this._bindex=0,this._eindex=0,this._length=e;}getMaxValue(e){const t=this._max_value;return e>=t?(this._max_value=e,this._pop_front()):this._get_front()<t?this._pop_front():(this._pop_front(),this._max_value=this._find_max()),this._push_back(e),this._max_value}_get_front(){return this._history[this._bindex]}_push_back(e){this._history[this._eindex]=e,++this._eindex==this._history.length&&(this._eindex=0),++this._length;}_pop_front(){++this._bindex==this._history.length&&(this._bindex=0),--this._length;}_find_max(){const e=this._history;let t=this._bindex,s=e[t];for(let i=1;i<this._length;++i)++t==e.length&&(t=0),e[t]>s&&(s=e[t]);return s}}var g$5={NOT_READY:{id:"NOT_READY"},READY:{id:"READY"},FAILED:{id:"FAILED"}},E$2={NONE:{id:"NONE"},LOADED:{id:"LOADED"},REQUESTED:{id:"REQUESTED"},FAILED:{id:"FAILED"}};function p(e,t,s,i){let _=0,r=i;for(let a=0;a<3;++a){const n=s.direction[a];if(0!=n){const h=(e[a]-s.position[a])/n,o=(e[a]+t-s.position[a])/n,l=n>0?h:o,d=n>0?o:h;if(_=Math.max(l,_),r=Math.min(d,r),_>=r)return i}else if(s.position[a]-e[a]<0||s.position[a]-e[a]-t>=0)return i}return _}d$3.DEFAULT_LOD_FACTOR=2,d$3.MIN_LOD_FACTOR=.5,d$3.RADIUS_FACTOR=Math.sqrt(3),d$3.LEVEL_INTERVAL=.5,d$3.CUBE_REDUCE_THRESH=1.5,d$3.CUBE_REDUCE_FACTOR=1.2,d$3.MESH_REDUCE_LOWER=300,d$3.MESH_REDUCE_THRESH=1.5,d$3.MESH_REDUCE_FACTOR=1.2,d$3.MAX_TILE_REQUESTEDS=15,f$1.EMPTY_TILE_MESH={id:"EMPTY_TILE_MESH"};

var A="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AXMNBCAAIAJBCGoiBCkDADcDACAFIAIpAwA3AwAgBCAGKQMANwMAIAIgAykDADcDACAGIAApAwA3AwAgAyAFKQMANwMADAQLIABB7wNMBEAgAkEQaiEAIAJBIGohAyACKwMgIQwCQCACKwMQIg0gAisDACIOY0UEQCAMIA1jQQFzDQEgBUEIaiIEIABBCGoiBikDADcDACAFIAApAwA3AwAgBiADQQhqIggpAwA3AwAgACADKQMANwMAIAggBCkDADcDACADIAUpAwA3AwAgACsDACAOY0EBcw0BIAQgAkEIaiIIKQMANwMAIAUgAikDADcDACAIIAYpAwA3AwAgAiAAKQMANwMAIAYgBCkDADcDACAAIAUpAwA3AwAMAQsgDCANY0EBc0UEQCAFQQhqIgAgAkEIaiIEKQMANwMAIAUgAikDADcDACAEIANBCGoiBikDADcDACACIAMpAwA3AwAgBiAAKQMANwMAIAMgBSkDADcDAAwBCyAFQQhqIgQgAkEIaiIIKQMANwMAIAUgAikDADcDACAIIABBCGoiBikDADcDACACIAApAwA3AwAgBiAEKQMANwMAIAAgBSkDADcDACAMIAIrAxBjQQFzDQAgBCAGKQMANwMAIAUgACkDADcDACAGIANBCGoiCCkDADcDACAAIAMpAwA3AwAgCCAEKQMANwMAIAMgBSkDADcDAAsgAkEwaiIAIAFGDQQDQCAAIgYrAwAiDCADKwMAY0EBc0UEQCAGKQMIIQsgBiEEA0ACQCAEIAMiACkDADcDACAEIAApAwg3AwggACACRgRAIAIhAAwBCyAAIQQgDCAAQRBrIgMrAwBjDQELCyAAIAs3AwggACAMOQMACyAGIgNBEGoiACABRw0ACwwECyACIARBAm1BBHRqIQYCQCAAQfH8AE4EQCACIAIgBEEEbUEEdCIAaiIEIAYgACAGaiIAEB8hCCAHKwMAIAArAwBjQQFzDQEgBUEIaiIDIABBCGoiCSkDADcDACAFIAApAwA3AwAgCSAHQQhqIgopAwA3AwAgACAHKQMANwMAIAogAykDADcDACAHIAUpAwA3AwAgACsDACAGKwMAY0EBcwRAIAhBAWohCAwCCyADIAZBCGoiCikDADcDACAFIAYpAwA3AwAgCiAJKQMANwMAIAYgACkDADcDACAJIAMpAwA3AwAgACAF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AwA3AwAgCCAFKQMANwMAIAIgBCkDADcDAAwCCyAEQQhqIgUgAEEIaiIIKQMANwMAIAQgACkDADcDACAIIAFBCGoiBykDADcDACAAIAEpAwA3AwAgByAFKQMANwMAIAEgBCkDADcDACACKwMAIAErAwBjQQFzDQEgBSAHKQMANwMAIAQgASkDADcDACAHIAJBCGoiBikDADcDACABIAIpAwA3AwAgBiAFKQMANwMAIAIgBCkDADcDAAtBAiEGCyADKwMAIAIrAwBjQQFzBH8gBgUgBEEIaiIFIAJBCGoiBykDADcDACAEIAIpAwA3AwAgByADQQhqIggpAwA3AwAgAiADKQMANwMAIAggBSkDADcDACADIAQpAwA3AwAgAisDACABKwMAY0EBcwRAIAZBAWoPCyAFIAFBCGoiAykDADcDACAEIAEpAwA3AwAgAyAHKQMANwMAIAEgAikDADcDACAHIAUpAwA3AwAgAiAEKQMANwMAIAErAwAgACsDAGNBAXMEQCAGQQJqDwsgBEEIaiICIABBCGoiAykDADcDACAEIAApAwA3AwAgAyABQQhqIgUpAwA3AwAgACABKQMANwMAIAUgAikDADcDACABIAQpAwA3AwAgBkEDagsLgQ0DB38BfgN8IwBBEGsiBSQAQQEhAwJAAkACQAJAAkACQCABIABrQQR1DgYFBQABAgMECyABQRBrIgIrAwAgACsDAGNBAXMNBCAFQQhqIgQgAEEIaiIGKQMANwMAIAUgACkDADcDACAGIAJBCGoiASkDADcDACAAIAIpAwA3AwAgASAEKQMANwMAIAIgBSkDADcDAAwECyAAQRBqIQQgAUEQayICKwMAIQogACsDECILIAArAwBjRQRAIAogC2NBAXMNBCAFQQhqIgYgBEEIaiIBKQMANwMAIAUgBCkDADcDACABIAJBCGoiAykDADcDACAEIAIpAwA3AwAgAyAGKQMANwMAIAIgBSkDADcDAEEBIQMgACsDECAAKwMAY0EBcw0EIAYgAEEIaiICKQMANwMAIAUgACkDADcDACACIAEpAwA3AwAgACAEKQMANwMAIAEgBikDADcDACAEIAUpAwA3AwAMBAsgCiALY0EBc0UEQCAFQQhqIgQgAEEIaiIGKQMANwMAIAUgACkDADcDACAGIAJBCGoiASkDADcDACAAIAIpAwA3AwAgASAEKQMANwMAIAIgBSkDADcDAAwECyAFQQhqIgYgAEEIaiIHKQMANwMAIAUgACkDADcDACAHIARBCGoiASkDADcDACAAIAQpAwA3AwAgASAGKQMANwMAIAQgBSkDADcDACACKwMAIAArAxBjQQFzDQMgBiABKQMANwMAIAUgBCkDADcDACABIAJBCGoiACkDADcDACAEIAIpAwA3AwAgACAGKQMANwMAIAIgBSkDADcDAAwDCyAAIABBEGogAEEgaiABQRBrEB8aDAILIAAgAEEQaiIHIABBIGoiBCAAQTBqIgIQHxogAUEQayIGKwMAIAArAzBjQQFzDQEgBUEIaiIBIAJBCGoiCCkDADcDACAFIAIpAwA3AwAgCCAGQQhqIgMpAwA3AwAgAiAGKQMANwMAIAMgASkDADcDACAGIAUpAwA3AwBBASEDIAIrAwAgBCsDAGNBAXMNASABIARBCGoiAykDADcDACAFIAQpAwA3AwAgAyAIKQMANwMAIAQgAikDADcDACAIIAEpAwA3AwAgAiAFKQMANwMAQQEhAyAEKwMAIAcrAwBjQQFzDQEgBUEIaiICIAdBCGoiBikDADcDACAFIAcpAwA3AwAgBiAEQQhqIgMpAwA3AwAgByAEKQMANwMAIAMgAikDADcDACAEIAUpAwA3AwBBASEDIAArAxAgACsDAGNBAXMNASACIABBCGoiBCkDADcDACAFIAApAwA3AwAgBCAGKQMANwMAIAAgBykDADcDACAGIAIpAwA3AwAgByAFKQMANwMADAELIABBEGohAyAAQSBqIQQgACsDICEKAkAgACsDECILIAArAwAiDGNFBEAgCiALY0EBcw0BIAVBCGoiAiADQQhqIgYpAwA3AwAgBSADKQMANwMAIAYgBEEIaiIHKQMANwMAIAMgBCkDADcDACAHIAIpAwA3AwAgBCAFKQMANwMAIAMrAwAgDGNBAXMNASACIABBCGoiBykDADcDACAFIAApAwA3AwAgByAGKQMANwMAIAAgAykDADcDACAGIAIpAwA3AwAgAyAFKQMANwMADAELIAogC2NBAXNFBEAgBUEIaiIDIABBCGoiAikDADcDACAFIAApAwA3AwAgAiAEQQhqIgYpAwA3AwAgACAEKQMANwMAIAYgAykDADcDACAEIAUpAwA3AwAMAQsgBUEIaiIC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";

class n$z{constructor(e){this._viewer=e,this._b3d_scenes=new Set,this.$debug={render_mode:0,clip_coloring:!1},this._wa_module=null,this._shader_cache={},this._loadWasmModule();}get viewer(){return this._viewer}get num_scenes(){return this._b3d_scenes.size}get shader_cache(){return this._shader_cache}getWasmModule(){return this._wa_module}_loadWasmModule(){t$x.createModuleByBese64(A).then((e=>{this._wa_module=e;for(let e of this._b3d_scenes)e.onLoadWasmModule();})).catch((e=>{}));}createScene(t){const s=new d$3(this,t);return this._b3d_scenes.add(s),s}removeScene(e){e.cancel(),this._b3d_scenes.delete(e);}clearScenes(){for(let e of Array.from(this._b3d_scenes))this.removeScene(e);}getIterator(){const e=this._b3d_scenes.values(),t={next:function(){let t=e.next();this.value=t.done?null:t.value;},value:null};return t.next(),t}draw(e){for(let t of this._b3d_scenes)t.draw(e);}endFrame(){for(let e of this._b3d_scenes)e.endFrame();}getRayIntersection(e,t){let s=t,n=null;for(let t of this._b3d_scenes){const r=t.getRayIntersection(e,s);null!==r&&(s=r.distance,n={b3d_scene:t,distance:s,feature_id:r.feature_id});}return n}}

class o$b extends e$o{constructor(t,e,o){super(t,e,o);}isTranslucent(t,e){return !1}setParameters(t,e){"RID"===t.getRenderTarget()&&this._setRenderId(e.rid);}setObjToClip(t,r){const s=r.transform,_=o$b._obj_to_clip;e$z.mul_GA(t.gocs_to_clip,s,_),this.setMatrix("u_obj_to_clip",_);}setObjToView(t,r){const s=r.transform,_=o$b._obj_to_view;e$z.mul_AA(t.gocs_to_view,s,_),this.setMatrix("u_obj_to_view",_);}}o$b._obj_to_clip=e$z.createMatrixf(),o$b._obj_to_view=e$z.createMatrixf();

var n$y="/**\n * SymbolLayer のシンボル (頂点シェーダ)\n */\n\nattribute vec3 a_offset;      // 頂点変位 (X,Y: スクリーン座標系, Z: 深度係数)\nattribute vec2 a_texcoord;    // テクスチャ座標\n\nuniform vec3 u_position;      // 頂点位置 (モデル座標系)\nuniform mat4 u_obj_to_view;   // モデル座標系からビュー座標系への変換\nuniform mat4 u_view_to_clip;  // ビュー座標系からクリップ座標系への変換\nuniform vec3 u_sparam;        // 画面パラメータ: {2/w, 2/h, pixel_step}\n\nvarying vec2 v_texcoord;      // シンボルのテクスチャ座標\n\nvoid\nmain()\n{\n    // ビュー座標変換と深度変位\n    vec4 view_pos = u_obj_to_view * vec4( u_position, 1 );\n    view_pos.xyz *= 1.0 - a_offset.z * u_sparam.z;\n\n    // クリップ座標変換と XY 変位\n    vec4 clip_pos = u_view_to_clip * view_pos;\n    clip_pos.xy += a_offset.xy * u_sparam.xy * clip_pos.w;\n\n    gl_Position = clip_pos;\n    v_texcoord = a_texcoord;\n}\n";

var n$x="/**\n * SymbolLayer のテキストまたは SDF アイコン (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\nvarying vec2 v_texcoord;     // シンボル画像上での位置\n\nuniform sampler2D u_image;   // シンボル画像 (x: 最小距離 - DIST_LOWER)\nuniform vec2  u_img_psize;   // テクスチャ空間での画面画素の寸法\n\nuniform vec4  u_color;       // シンボル本体の RGBA 色 (α前乗算)\nuniform float u_opacity;     // シンボル全体の不透明度\n\nuniform vec4  u_halo_color;   // シンボル縁取りの RGBA 色 (α前乗算)\nuniform float u_halo_width;   // シンボル縁取りの太さ - DIST_LOWER\n\n\n/**\n * sdfield.ts の DIST_FACTOR と同じ値\n */\nconst float DIST_FACTOR = _DIST_FACTOR_;\n\n\n/**\n * sdfield.ts の DIST_LOWER と同じ値\n */\nconst float DIST_LOWER = _DIST_LOWER_;\n\n\n/**\n * 被覆率を計算するための画素の分割数\n *\n * 現在の実装は等間隔に分割するが、別の分割方法でも実装可能である。\n */\nconst ivec2 DIVS_Zeta = ivec2( 2, 2 );\n\n\n/** 引数の値を交換 */\nvoid\nswap( inout float a, inout float b )\n{\n    float temp = a;\n    a = b;\n    b = temp;\n}\n\n\n/** 三角形内の図形の被覆率を計算\n *\n *  詳細は `vector-tile-style.org` の「シンボルの縁取り表示」を参照の\n *  こと。\n */\nfloat\ncoverage( float dist_a, float dist_b, float dist_c, float w )\n{\n    float d[3];\n    d[0] = dist_a;\n    d[1] = dist_b;\n    d[2] = dist_c;\n\n    // 昇順ソート\n    if ( d[0] > d[1] ) swap( d[0], d[1] );\n    if ( d[0] > d[2] ) swap( d[0], d[2] );\n    if ( d[1] > d[2] ) swap( d[1], d[2] );\n\n    // 画素に対する三角形の数\n    const int num_triangles = 2 * DIVS_Zeta[0] * DIVS_Zeta[1];\n\n    // 画素に対する三角形の面積\n    const float area = 1.0 / float( num_triangles );\n\n    if ( d[0] >  w ) {\n        // 図形と三角形は重ならない\n        return 0.0 * area;\n    }\n\n    if ( d[2] <= w ) {\n        // 図形は三角形を覆っている\n        return 1.0 * area;\n    }\n\n    if ( d[1] > w ) {\n        // 1 つ頂点が図形内 (r1)\n        float n = (w    - d[0]) * (w    - d[0]);\n        float m = (d[1] - d[0]) * (d[2] - d[0]);\n        return n / m * area;\n    }\n    else {\n        // 2 つ頂点が図形内 (r2)\n        float n = (w    - d[2]) * (w    - d[2]);\n        float m = (d[1] - d[2]) * (d[0] - d[2]);\n        return (1.0 - n / m) * area;\n    }\n}\n\n\n/** sdistance 用のインデックス */\nint\nindex( int k0, int k1 )\n{\n    return k0 + k1 * (DIVS_Zeta[0] + 1);\n}\n\n\nvoid main()\n{\n    // 画素の左下角に対応するテクスチャ座標\n    vec2 tc_base = v_texcoord - 0.5 * u_img_psize;\n\n     // 距離のサンプリング\n    float sdistance[(DIVS_Zeta[0] + 1) * (DIVS_Zeta[1] + 1)];\n\n    for ( int k1 = 0; k1 < DIVS_Zeta[1] + 1; ++k1 ) {\n        for ( int k0 = 0; k0 < DIVS_Zeta[0] + 1; ++k0 ) {\n            // 標本点のテクスチャ座標 (特殊単位)\n            vec2 tc = tc_base + vec2( k0, k1 ) / vec2( DIVS_Zeta ) * u_img_psize;\n            sdistance[index( k0, k1 )] = texture2D( u_image, tc ).x;\n        }\n    }\n\n   // ζ_b: シンボル本体の被覆率\n    float zeta_b = 0.0;\n\n    // ζ_u: シンボル本体と縁取りの合併の被覆率\n    float zeta_u = 0.0;\n\n    // 最小距離がこれ以下のとき、シンボル本体内\n    const float body_edge_dist = (0.0 - DIST_LOWER) * DIST_FACTOR;\n\n    // 被覆率 ζ_b, ζ_u を計算\n    for ( int k1 = 0; k1 < DIVS_Zeta[1]; ++k1 ) {\n        for ( int k0 = 0; k0 < DIVS_Zeta[0]; ++k0 ) {\n            // 四角形の角のサンプリング値\n            float d00 = sdistance[index( k0 + 0, k1 + 0 )];\n            float d10 = sdistance[index( k0 + 1, k1 + 0 )];\n            float d01 = sdistance[index( k0 + 0, k1 + 1 )];\n            float d11 = sdistance[index( k0 + 1, k1 + 1 )];\n\n            // 下三角形\n            zeta_b += coverage( d00, d10, d01, body_edge_dist );\n            zeta_u += coverage( d00, d10, d01,   u_halo_width );\n\n            // 上三角形\n            zeta_b += coverage( d01, d10, d11, body_edge_dist );\n            zeta_u += coverage( d01, d10, d11,   u_halo_width );\n        }\n    }\n\n    // ζ_h: シンボル縁取りの被覆率\n    float zeta_h = zeta_u - zeta_b;\n\n    // 混合は C = Cs + (1 - As) Cd を前提\n    gl_FragColor = vec4( zeta_b * u_color.rgb + zeta_h * u_halo_color.rgb,\n                         zeta_b * u_color.a   + zeta_h * u_halo_color.a ) * u_opacity;\n}\n";

var n$w="/**\n * SymbolLayer の通常アイコン (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\nvarying vec2 v_texcoord;     // アイコン画像上での位置\n\nuniform sampler2D u_image;   // アイコン画像\n\nuniform float u_opacity;     // アイコン全体の不透明度\n\n\nvoid main()\n{\n    vec4 color = texture2D( u_image, v_texcoord );\n\n    // 混合は C = Cs + (1 - As) Cd を前提\n    gl_FragColor = vec4( color.rgb * color.a, color.a ) * u_opacity;\n}\n";

class m$6 extends a$i{constructor(t,e){super(t,e,m$6.prop_specs),this.prop_text_field=this.__getProperty("text-field"),this.prop_text_size=this.__getProperty("text-size"),this.prop_text_color=this.__getProperty("text-color"),this.prop_text_opacity=this.__getProperty("text-opacity"),this.prop_text_font=this.__getProperty("text-font"),this.prop_text_anchor=this.__getProperty("text-anchor"),this.prop_text_offset=this.__getProperty("text-offset"),this.prop_text_halo_color=this.__getProperty("text-halo-color"),this.prop_text_halo_width=this.__getProperty("text-halo-width"),this.prop_icon_image=this.__getProperty("icon-image"),this.prop_icon_size=this.__getProperty("icon-size"),this.prop_icon_color=this.__getProperty("icon-color"),this.prop_icon_opacity=this.__getProperty("icon-opacity"),this.prop_icon_anchor=this.__getProperty("icon-anchor"),this.prop_icon_offset=this.__getProperty("icon-offset"),this.prop_icon_halo_color=this.__getProperty("icon-halo-color"),this.prop_icon_halo_width=this.__getProperty("icon-halo-width"),this.__text_image_cache=this._ensure_text_image_cache(),this.__image_manager=t.__image_manager;}_ensure_text_image_cache(){const t=this.style_manager.viewer,e=t.glenv,i=m$6._shared_text_image_caches.get(e);let _;return i?_=i:(_=new h$8(t.glenv),m$6._shared_text_image_caches.set(e,_)),_}__createLayerFlake(t,e){return new d$2(this,t,e)}__isSupported(t){return 1===t}getMaterial(t,e){let i=m$6._material_cache.get(t);void 0===i&&(i=new Map,m$6._material_cache.set(t,i));const _=`stype: ${e}`;let o=i.get(_);return void 0===o&&(o=new E$1(t,e),i.set(_,o)),o}}m$6.prop_specs=[{name:"text-field",category:"layout",value_type:"string",default_value:""},{name:"text-size",category:"layout",value_type:"number",default_value:16},{name:"text-color",category:"paint",value_type:"color",default_value:"#000000"},{name:"text-opacity",category:"paint",value_type:"number",default_value:1},{name:"text-font",category:"layout",value_type:"array",element_type:"string",default_value:["Open Sans Regular","Arial Unicode MS Regular"]},{name:"text-anchor",category:"layout",value_type:"string",default_value:"center"},{name:"text-offset",category:"layout",value_type:"array",element_type:"number",default_value:[0,0]},{name:"text-halo-color",category:"paint",value_type:"color",default_value:"rgba(0, 0, 0, 0)"},{name:"text-halo-width",category:"paint",value_type:"number",default_value:0},{name:"icon-image",category:"layout",value_type:"resolvedImage"},{name:"icon-size",category:"layout",value_type:"number",default_value:1},{name:"icon-color",category:"paint",value_type:"color",default_value:"#000000"},{name:"icon-opacity",category:"paint",value_type:"number",default_value:1},{name:"icon-anchor",category:"layout",value_type:"string",default_value:"center"},{name:"icon-offset",category:"layout",value_type:"array",element_type:"number",default_value:[0,0]},{name:"icon-halo-color",category:"paint",value_type:"color",default_value:"rgba(0, 0, 0, 0)"},{name:"icon-halo-width",category:"paint",value_type:"number",default_value:0}],m$6._material_cache=new WeakMap,m$6._shared_text_image_caches=new WeakMap;class d$2 extends r$q{constructor(t,e,i){super(t,e,i),this.origin_position=a$e.getCenter(i,e$z.createVector3());}createLayerFeature(t,e){if(!(t instanceof n$R))throw new Error("Unexcepted GeomType");return new x$1(t,this,e)}completeInitialization(t){}startEvaluation(t){return e=>{if(0!==e.evaluated_properties.size)for(const e of this._layer_features.values())e.updatePrimitive(t);}}getPrimitives(t){const e=[];for(const i of this._layer_features.values()){const _=i.createPrimitives(t);Array.prototype.push.apply(e,_);}return e}}class x$1 extends s$n{constructor(t,e,i){super(t,e,i),({text_field:this._text_field,text_size:this._text_size,text_font:this._text_font,text_anchor:this._text_anchor,text_offset:this._text_offset,icon_name:this._icon_name,icon_size:this._icon_size,icon_offset:this._icon_offset,icon_anchor:this._icon_anchor}=this._getEvaluatedLayoutValues()),this._gres_text=this._buildTextGraphicsResource(i),this._gres_icon=this._buildIconGraphicsResource(i),this._position=e$z.createVector3f(this._get_local_position(i));}dispose(){this._gres_text&&this._gres_text.image_handle.dispose(),this._gres_icon&&"sdf-icon"===this._gres_icon.tag&&this._gres_icon.image_handle.dispose();}updatePrimitive(t){const{text_field:e,text_size:i,text_font:_,text_anchor:o,text_offset:a,icon_name:s,icon_size:r,icon_anchor:n,icon_offset:c}=this._getEvaluatedLayoutValues();(e!==this._text_field||i!==this._text_size||!I$1(_,this._text_font)||o!==this._text_anchor||!I$1(a,this._text_offset))&&(this._text_field=e,this._text_size=i,this._text_font=_,this._text_anchor=o,this._text_offset=a,this._gres_text&&(this._gres_text.image_handle.dispose(),this._gres_text=null),this._gres_text=this._buildTextGraphicsResource(t));(s!==this._icon_name||r!==this._icon_size||n!==this._icon_anchor||c!==this._icon_offset)&&(this._icon_name=s,this._icon_size=r,this._icon_anchor=n,this._icon_offset=c,this._gres_icon&&"sdf-icon"===this._gres_icon.tag&&(this._gres_icon.image_handle.dispose(),this._gres_icon=null),this._gres_icon=this._buildIconGraphicsResource(t));}createPrimitives(t){const e=t.stage.glenv,i=this.layer_flake.style_layer,_=[],o=this._createTransform();if(this._gres_text){const t=this.getEvaluatedColor(i.prop_text_color,e$z.createVector4f()),a=this.getEvaluatedValue(i.prop_text_opacity),s=this.getEvaluatedColor(i.prop_text_halo_color,e$z.createVector4f()),r=this.getEvaluatedValue(i.prop_text_halo_width);w(r,s);const c=this._gres_text;if(c.image_handle.checkRebuild(r)){const t=c.image_handle.getImageInfo(),i={anchor:this._text_anchor,offset:[this._text_offset[0]*this._text_size,this._text_offset[1]*this._text_size],scale:1,depth_factor:this._calculateTextDepthFactor()};c.mesh=y$2(e,t,i),c.img_psize[0]=1/t.texture_width,c.img_psize[1]=1/t.texture_height;}const l={u_position:this._position,u_image:c.image_handle.getTexture(),u_img_psize:c.img_psize,u_color:t,u_opacity:a,u_halo_color:s,u_halo_width:z(r)},p=new s$h(e,c.mesh,i.getMaterial(e,"sdf"),o);p.properties=l,_.push(p);}if(this._gres_icon){const t=this.getEvaluatedColor(i.prop_icon_color,e$z.createVector4f()),a=this.getEvaluatedValue(i.prop_icon_opacity),s=this.getEvaluatedColor(i.prop_icon_halo_color,e$z.createVector4f()),r=this.getEvaluatedValue(i.prop_icon_halo_width)/this._icon_size;w(r,s);const c=this._gres_icon;if("sdf-icon"===c.tag){if(c.image_handle.checkRebuild(r)){const t=c.image_handle.getImageInfo(),i={anchor:this._icon_anchor,offset:this._icon_offset,scale:this._icon_size,depth_factor:this._calculateIconDepthFactor(c.src_image.image.height)};c.mesh=y$2(e,t,i),c.img_psize[0]=1/t.texture_width/this._icon_size,c.img_psize[1]=1/t.texture_height/this._icon_size;}const h={u_position:this._position,u_image:c.image_handle.getTexture(),u_img_psize:c.img_psize,u_color:t,u_opacity:a,u_halo_color:s,u_halo_width:z(r)},l=new s$h(e,c.mesh,i.getMaterial(e,"sdf"),o);l.properties=h,_.push(l);}else {const h={u_position:this._position,u_image:c.texture,u_img_psize:c.img_psize,u_color:t,u_opacity:a,u_halo_color:s,u_halo_width:z(r)},l=new s$h(e,c.mesh,i.getMaterial(e,"color"),o);l.properties=h,_.push(l);}}return _}_createTransform(){const t=e$z.setIdentity(e$z.createMatrix()),e=this.layer_flake.origin_position;for(let i=0;i<3;++i)t[12+i]=e[i];return t}_getEvaluatedLayoutValues(){const t=this.layer_flake.style_layer,e=this.getEvaluatedValue(t.prop_icon_image),i=null!==e&&e.available?e.name:null;return {text_field:this.getEvaluatedValue(t.prop_text_field),text_size:this.getEvaluatedValue(t.prop_text_size),text_font:this.getEvaluatedValue(t.prop_text_font),text_anchor:this.getEvaluatedValue(t.prop_text_anchor),text_offset:this.getEvaluatedValue(t.prop_text_offset),icon_name:i,icon_size:this.getEvaluatedValue(t.prop_icon_size),icon_anchor:this.getEvaluatedValue(t.prop_icon_anchor),icon_offset:this.getEvaluatedValue(t.prop_icon_offset)}}_buildTextGraphicsResource(t){if(0===this._text_field.length||this._text_size<=0)return null;const e=this.layer_flake.style_layer,i=e.__text_image_cache,_=this.getEvaluatedValue(e.prop_text_halo_width),o=i.getHandle(this._text_field,this._getTextFontString(),this._text_size,_),a=o.getImageInfo(),s={anchor:this._text_anchor,offset:[this._text_offset[0]*this._text_size,this._text_offset[1]*this._text_size],scale:1,depth_factor:this._calculateTextDepthFactor()};return {mesh:y$2(t.stage.glenv,a,s),image_handle:o,img_psize:e$z.createVector2f([1/a.texture_width,1/a.texture_height])}}_buildIconGraphicsResource(t){if(null===this._icon_name||this._icon_size<=0)return null;const e={anchor:this._icon_anchor,offset:this._icon_offset,scale:this._icon_size,depth_factor:0},i=this.layer_flake.style_layer.__image_manager,_=i.findImage(this._icon_name);if(_ instanceof m$c){const o=this.layer_flake.style_layer,a=i.sdf_image_cache,s=this.getEvaluatedValue(o.prop_icon_halo_width)/this._icon_size,r=a.getHandle(this._icon_name,s),n=r.getImageInfo();return e.depth_factor=this._calculateIconDepthFactor(_.image.height),{tag:"sdf-icon",src_image:_,mesh:y$2(t.stage.glenv,n,e),image_handle:r,img_psize:e$z.createVector2f([1/n.texture_width/this._icon_size,1/n.texture_height/this._icon_size])}}{const i=_.image_upper[1]-_.image_lower[1];return e.depth_factor=this._calculateIconDepthFactor(i),{tag:"color-icon",mesh:y$2(t.stage.glenv,{texture_width:_.texture_size[0],texture_height:_.texture_size[1],display_lower_x:_.image_lower[0],display_lower_y:_.image_lower[1],display_upper_x:_.image_upper[0],display_upper_y:_.image_upper[1],anchor_lower_x:_.image_lower[0],anchor_lower_y:_.image_lower[1],anchor_upper_x:_.image_upper[0],anchor_upper_y:_.image_upper[1]},e),texture:_.texture,img_psize:e$z.createVector2f([1/_.texture_size[0]/this._icon_size,1/_.texture_size[1]/this._icon_size])}}}_get_local_position(t){const e=Math.PI,i=Math.pow(2,1-t.z),_=this.feature.points.vertices,o=_[0],a=_[1],s=-e+i*(t.x+o)*e,r=e-i*(t.y+a)*e,n=Math.exp(r),c=1/n,l=Math.sin(s),p=Math.cos(s),u=(n-c)/(n+c),g=2/(n+c),f=t.dem_sampler.sample(s,r),m=e$z.EARTH_RADIUS+f,d=m*(g*p),x=m*(g*l),y=m*u,v=this.layer_flake.origin_position;return [d-v[0],x-v[1],y-v[2]]}_calculateTextDepthFactor(){return 1.75*this._text_size}_calculateIconDepthFactor(t){return 1.75*t*this._icon_size}_getTextFontString(){const t=this._text_font.map((t=>'"'+t+'"')).join(", ");return `normal normal normal ${this._text_size}px ${t}`}}function y$2(t,e,i){const _={vtype:[{name:"a_offset",size:3},{name:"a_texcoord",size:2}],vertices:v$1(e,i),indices:[0,1,2,2,1,3]};return new r$h(t,_)}function v$1(t,e){let i=(t.anchor_lower_x+t.anchor_upper_x)/2,_=(t.anchor_lower_y+t.anchor_upper_y)/2;const o=V$1[e.anchor];void 0!==o&&(i+=o[0]*(t.anchor_upper_x-t.anchor_lower_x)/2,_+=o[1]*(t.anchor_upper_y-t.anchor_lower_y)/2),i-=e.offset[0],_+=e.offset[1];const a=(t.display_lower_x-i)*e.scale,s=(t.display_upper_x-i)*e.scale,r=(t.display_lower_y-_)*e.scale,n=(t.display_upper_y-_)*e.scale,c=e.depth_factor,h=t.display_lower_x/t.texture_width,l=t.display_upper_x/t.texture_width,p=t.display_lower_y/t.texture_height,u=t.display_upper_y/t.texture_height,g=[];return g.push(a,r,c),g.push(h,p),g.push(s,r,c),g.push(l,p),g.push(a,n,c),g.push(h,u),g.push(s,n,c),g.push(l,u),g}function z(t){return (t-a$h)*r$p}function w(t,e){if(t<1){const i=Math.max(0,t);for(let t=0;t<4;++t)e[t]*=i;}}class E$1 extends o$b{constructor(t,e,i={}){const _=E$1._getPreamble(i);super(t,_+n$y,_+("sdf"===e?n$x:n$w)),this.bindProgram(),this.setInteger("u_image",E$1.TEXUNIT_IMAGE);}isTranslucent(t,e){return !0}setParameters(t,e){super.setParameters(t,e);const i=e.properties;this.setObjToView(t,e);const _=E$1._view_to_clip;e$z.copyMatrix(t._view_to_clip,_),this.setMatrix("u_view_to_clip",_);const o=E$1._sparam;if(o[0]=2/t._width,o[1]=2/t._height,o[2]=t.pixel_step,this.setVector3("u_sparam",o),"SCENE"===t.getRenderTarget()){const t=i.u_image;this.bindTexture2D(E$1.TEXUNIT_IMAGE,t),this.setVector3("u_position",i.u_position),this.setVector2("u_img_psize",i.u_img_psize),this.setVector4("u_color",i.u_color),this.setFloat("u_opacity",i.u_opacity),this.setVector4("u_halo_color",i.u_halo_color),this.setFloat("u_halo_width",e$z.clamp(i.u_halo_width,0,E$1.MAX_HALO_WIDTH));}}static _getPreamble(t){const e=[];return e.push(`#define _DIST_FACTOR_ (float(${r$p}))`),e.push(`#define _DIST_LOWER_ (float(${a$h}))`),e.join("\n")+"\n\n"}}E$1.TEXUNIT_IMAGE=0,E$1.MAX_HALO_WIDTH=.999,E$1._sparam=e$z.createVector3f(),E$1._view_to_clip=e$z.createMatrixf();const V$1={left:[-1,0],right:[1,0],top:[0,1],bottom:[0,-1],"top-left":[-1,1],"top-right":[1,1],"bottom-left":[-1,-1],"bottom-right":[1,-1]};function I$1(t,e){if(t.length!==e.length)return !1;for(let i=0;i<t.length;++i)if(t[i]!==e[i])return !1;return !0}

const e$d=[{layer_type:"symbol",creator:(o,e)=>new m$6(o,e)}];function s$9(){for(const{layer_type:r,creator:s,readiness:t}of e$d)h$7(r,s,null!=t?t:Promise.resolve());}

var n$v;!function(n){n.maprayRequestAnimationFrame=function(n){return o.call(window,n)};const o=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame;n.maprayCancelAnimationFrame=function(n){return a.call(window,n)};const a=window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame,i=window.performance,e=i&&(i.now||i.mozNow||i.msNow||i.oNow||i.webkitNow);n.maprayNow=e?()=>e.call(i):()=>Date.now();}(n$v||(n$v={}));var o$a=n$v;

class e$c{constructor(){this._sun_direction=e$z.createVector3([0,0,1]);}get sun_direction(){return this._sun_direction}setSunDirection(e){e$z.copyVector3(e,this._sun_direction);}getSunDirection(e){return e$z.copyVector3(this._sun_direction,e)}}

class t$b{constructor(){this._moon_direction=e$z.createVector3([0,0,1]);}get moon_direction(){return this._moon_direction}setMoonDirection(t){e$z.copyVector3(t,this._moon_direction);}getMoonDirection(t){return e$z.copyVector3(this._moon_direction,t)}}

class i$b{constructor(t,e){var n;this._visibility=void 0===e.visibility||e.visibility,this._position=e.position||i$b.ContainerPosition.TOP_LEFT,n="string"==typeof t?document.getElementById(t):t,this._viewer_container=n,this._is_compact=!1;var s=this;window.addEventListener("resize",(function(){s._sizeChanged();}),!1);}setVisibility(i){this._visibility=i,this._setContainerVisibility();}setPosition(i){this._position=i,this._deleteContainer(),this.createContainer();}_setContainerVisibility(){this._container&&(this._visibility?this._container.style.visibility="visible":this._container.style.visibility="collapse");}_destroy(){var i=this;window.removeEventListener("resize",(function(){i._sizeChanged();}),!1),this._deleteContainer();}_deleteContainer(){if(this._container){var i=this._container.parentElement;i&&i.removeChild(this._container),this._container=void 0;}}_sizeChanged(){}createContainer(){}}!function(i){var t;(t=i.ContainerPosition||(i.ContainerPosition={})).TOP_LEFT="top-left",t.TOP_RIGHT="top-right",t.BOTTOM_LEFT="bottom-left",t.BOTTOM_RIGHT="bottom-right",i._compact_size=500;}(i$b||(i$b={}));var t$a=i$b;

var n$u='<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   id="svg1481"\n   version="1.1"\n   width="160"\n   height="28"\n   viewBox="0 0 119.56 21.24">\n  <metadata\n     id="metadata1485">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs1315">\n    <style\n       id="style1313">.cls-1{fill:#b5b5b6;}.cls-2,.cls-4{fill:#fff;}.cls-3{fill:#0086d1;}.cls-4{stroke:#999;}</style>\n  </defs>\n  <g\n     data-name="レイヤー2"\n     id="レイヤー2">\n    <g\n       id="layer1">\n      <polygon\n         id="polygon1319"\n         points="11.24 10.4 10.47 8.48 10.47 8.48 8.57 7.71 8.57 7.71 8.56 7.71 8.56 7.71 8.56 7.71 6.62 8.44 6.62 8.44 5.89 10.4 5.89 10.4 5.89 10.4 5.89 10.4 5.89 10.4 6.62 12.36 6.62 12.36 8.56 13.09 8.56 13.09 8.56 13.09 8.57 13.09 8.57 13.09 10.46 12.31 10.46 12.31 11.24 10.4 11.24 10.4 11.24 10.4 11.24 10.4 11.24 10.4"\n         class="cls-1" />\n      <polygon\n         id="polygon1321"\n         points="4.28 5.38 4.28 5.38 4.28 0 2.45 4.26 4.28 5.38"\n         class="cls-2" />\n      <polygon\n         id="polygon1323"\n         points="2.45 4.26 0.82 6.1 4.28 5.38 2.45 4.26"\n         class="cls-1" />\n      <polygon\n         id="polygon1325"\n         points="4.28 5.38 4.28 5.38 4.28 5.38 4.28 5.38"\n         class="cls-3" />\n      <polygon\n         id="polygon1327"\n         points="4.28 5.38 4.28 5.38 0.82 6.1 0 10.4 4.28 5.38 4.28 5.38"\n         class="cls-2" />\n      <polygon\n         id="polygon1329"\n         points="0 10.4 4.28 10.4 4.28 5.38 0 10.4"\n         class="cls-1" />\n      <rect\n         id="rect1331"\n         transform="translate(-2.55 4.62) rotate(-45.1)"\n         y="5.38"\n         x="4.28"\n         class="cls-3" />\n      <polygon\n         id="polygon1333"\n         points="4.28 5.38 4.28 10.4 5.52 7.35 4.28 5.38 4.28 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1335"\n         points="4.28 5.38 5.52 7.35 8.56 6.1 4.28 5.38 4.28 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1337"\n         points="4.28 5.38 8.56 1.8 4.28 0 4.28 5.38 4.28 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1339"\n         points="8.56 6.1 8.56 1.8 4.28 5.38 8.56 6.1"\n         class="cls-1" />\n      <polygon\n         id="polygon1341"\n         points="13.66 5.66 13.66 5.66 13.49 2.87 8.56 1.8 13.66 5.66"\n         class="cls-2" />\n      <polygon\n         id="polygon1343"\n         points="8.56 1.8 8.56 6.1 13.66 5.66 8.56 1.8"\n         class="cls-1" />\n      <polygon\n         id="polygon1345"\n         points="13.66 5.66 13.66 5.66 13.66 5.66 13.66 5.66"\n         class="cls-3" />\n      <polygon\n         id="polygon1347"\n         points="13.66 5.66 13.66 5.66 8.56 6.1 11.69 7.26 13.66 5.66 13.66 5.66"\n         class="cls-1" />\n      <polygon\n         id="polygon1349"\n         points="11.69 7.26 12.85 10.4 13.66 5.66 11.69 7.26"\n         class="cls-1" />\n      <rect\n         id="rect1351"\n         transform="translate(0.01 11.34) rotate(-45.1)"\n         y="5.66"\n         x="13.66"\n         class="cls-3" />\n      <polygon\n         id="polygon1353"\n         points="13.66 5.66 12.85 10.4 17.13 10.12 13.66 5.66 13.66 5.66"\n         class="cls-1" />\n      <polygon\n         id="polygon1355"\n         points="13.66 5.66 17.13 4.66 13.49 2.87 13.66 5.66 13.66 5.66"\n         class="cls-2" />\n      <polyline\n         id="polyline1357"\n         points="13.66 5.66 13.66 5.66 17.13 10.12 17.13 4.66 13.66 5.66"\n         class="cls-2" />\n      <polygon\n         id="polygon1359"\n         points="4.28 15.41 4.28 15.41 4.28 10.4 0 10.4 4.28 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1361"\n         points="0 10.4 0.82 14.7 4.28 15.41 0 10.4"\n         class="cls-2" />\n      <polygon\n         id="polygon1363"\n         points="4.28 15.41 4.28 15.41 4.28 15.41 4.28 15.41"\n         class="cls-3" />\n      <polygon\n         id="polygon1365"\n         points="4.28 15.41 4.28 15.41 0.82 14.7 2.48 16.5 4.28 15.41 4.28 15.41"\n         class="cls-2" />\n      <polygon\n         id="polygon1367"\n         points="2.48 16.5 4.28 17.91 4.28 15.41 2.48 16.5"\n         class="cls-2" />\n      <rect\n         id="rect1369"\n         transform="translate(-9.66 7.57) rotate(-45.1)"\n         y="15.41"\n         x="4.28"\n         class="cls-3" />\n      <polygon\n         id="polygon1371"\n         points="4.28 15.41 4.28 17.91 8.56 18.99 4.28 15.41 4.28 15.41"\n         class="cls-2" />\n      <polygon\n         id="polygon1373"\n         points="4.28 15.41 8.56 18.99 8.56 14.7 4.28 15.41 4.28 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1375"\n         points="4.28 15.41 5.54 13.44 4.28 10.4 4.28 15.41 4.28 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1377"\n         points="8.56 14.7 5.54 13.44 4.28 15.41 8.56 14.7"\n         class="cls-1" />\n      <polygon\n         id="polygon1379"\n         points="13.48 17.2 13.48 17.2 12.85 10.4 11.56 13.4 13.48 17.2"\n         class="cls-1" />\n      <polygon\n         id="polygon1381"\n         points="11.56 13.4 8.56 14.7 13.48 17.2 11.56 13.4"\n         class="cls-1" />\n      <polygon\n         id="polygon1383"\n         points="13.48 17.2 13.48 17.2 13.48 17.2 13.48 17.2"\n         class="cls-3" />\n      <polygon\n         id="polygon1385"\n         points="13.48 17.2 13.48 17.2 8.56 14.7 8.56 18.99 13.48 17.2 13.48 17.2"\n         class="cls-1" />\n      <rect\n         id="rect1387"\n         transform="translate(-8.22 14.6) rotate(-45.1)"\n         y="17.2"\n         x="13.48"\n         class="cls-3" />\n      <polygon\n         id="polygon1389"\n         points="13.48 17.2 17.13 10.12 12.85 10.4 13.48 17.2 13.48 17.2"\n         class="cls-1" />\n      <polygon\n         id="polygon1391"\n         points="17.13 21.24 17.13 10.12 13.48 17.2 17.13 21.24"\n         class="cls-2" />\n      <polygon\n         id="polygon1393"\n         points="23.02 10.4 23.78 8.48 23.78 8.48 25.69 7.71 25.69 7.71 25.69 7.71 25.7 7.71 25.7 7.71 27.64 8.44 27.64 8.44 28.37 10.4 28.37 10.4 28.37 10.4 28.37 10.4 28.37 10.4 27.64 12.36 27.64 12.36 25.7 13.09 25.7 13.09 25.69 13.09 25.69 13.09 25.69 13.09 23.79 12.31 23.79 12.31 23.02 10.4 23.02 10.4 23.02 10.4 23.02 10.4 23.02 10.4"\n         class="cls-1" />\n      <polygon\n         id="polygon1395"\n         points="29.98 5.38 29.98 5.38 29.98 0 31.81 4.26 29.98 5.38"\n         class="cls-2" />\n      <polygon\n         id="polygon1397"\n         points="31.81 4.26 33.44 6.1 29.98 5.38 31.81 4.26"\n         class="cls-1" />\n      <polygon\n         id="polygon1399"\n         points="29.98 5.38 29.98 5.38 29.98 5.38 29.98 5.38"\n         class="cls-3" />\n      <polygon\n         id="polygon1401"\n         points="29.98 5.38 29.98 5.38 33.44 6.1 34.26 10.4 29.98 5.38 29.98 5.38"\n         class="cls-2" />\n      <polygon\n         id="polygon1403"\n         points="34.26 10.4 29.98 10.4 29.98 5.38 34.26 10.4"\n         class="cls-1" />\n      <rect\n         id="rect1405"\n         transform="translate(4.94 22.73) rotate(-44.9)"\n         y="5.38"\n         x="29.98"\n         class="cls-3" />\n      <polygon\n         id="polygon1407"\n         points="29.98 5.38 29.98 10.4 28.73 7.35 29.98 5.38 29.98 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1409"\n         points="29.98 5.38 28.73 7.35 25.69 6.1 29.98 5.38 29.98 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1411"\n         points="29.98 5.38 25.69 1.8 29.98 0 29.98 5.38 29.98 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1413"\n         points="25.69 6.1 25.69 1.8 29.98 5.38 25.69 6.1"\n         class="cls-1" />\n      <polygon\n         id="polygon1415"\n         points="20.6 5.66 20.6 5.66 20.76 2.87 25.69 1.8 20.6 5.66"\n         class="cls-2" />\n      <polygon\n         id="polygon1417"\n         points="25.69 1.8 25.69 6.1 20.6 5.66 25.69 1.8"\n         class="cls-1" />\n      <polygon\n         id="polygon1419"\n         points="20.6 5.66 20.6 5.66 20.6 5.66 20.6 5.66"\n         class="cls-3" />\n      <polygon\n         id="polygon1421"\n         points="20.6 5.66 20.6 5.66 25.69 6.1 22.57 7.26 20.6 5.66 20.6 5.66"\n         class="cls-1" />\n      <polygon\n         id="polygon1423"\n         points="22.57 7.26 21.41 10.4 20.6 5.66 22.57 7.26"\n         class="cls-1" />\n      <rect\n         id="rect1425"\n         transform="translate(2.01 16.19) rotate(-44.9)"\n         y="5.66"\n         x="20.6"\n         class="cls-3" />\n      <polygon\n         id="polygon1427"\n         points="20.6 5.66 21.41 10.4 17.13 10.12 20.6 5.66 20.6 5.66"\n         class="cls-1" />\n      <polygon\n         id="polygon1429"\n         points="20.6 5.66 17.13 4.66 20.76 2.87 20.6 5.66 20.6 5.66"\n         class="cls-2" />\n      <polyline\n         id="polyline1431"\n         points="20.6 5.66 20.6 5.66 17.13 10.12 17.13 4.66 20.6 5.66"\n         class="cls-2" />\n      <polygon\n         id="polygon1433"\n         points="29.98 15.41 29.98 15.41 29.98 10.4 34.26 10.4 29.98 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1435"\n         points="34.26 10.4 33.44 14.7 29.98 15.41 34.26 10.4"\n         class="cls-2" />\n      <polygon\n         id="polygon1437"\n         points="29.98 15.41 29.98 15.41 29.98 15.41 29.98 15.41"\n         class="cls-3" />\n      <polygon\n         id="polygon1439"\n         points="29.98 15.41 29.98 15.41 33.44 14.7 31.78 16.5 29.98 15.41 29.98 15.41"\n         class="cls-2" />\n      <polygon\n         id="polygon1441"\n         points="31.78 16.5 29.98 17.91 29.98 15.41 31.78 16.5"\n         class="cls-2" />\n      <rect\n         id="rect1443"\n         transform="translate(-2.14 25.66) rotate(-44.9)"\n         y="15.41"\n         x="29.98"\n         class="cls-3" />\n      <polygon\n         id="polygon1445"\n         points="29.98 15.41 29.98 17.91 25.69 18.99 29.98 15.41 29.98 15.41"\n         class="cls-2" />\n      <polygon\n         id="polygon1447"\n         points="29.98 15.41 25.69 18.99 25.69 14.7 29.98 15.41 29.98 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1449"\n         points="29.98 15.41 28.72 13.44 29.98 10.4 29.98 15.41 29.98 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1451"\n         points="25.69 14.7 28.72 13.44 29.98 15.41 25.69 14.7"\n         class="cls-1" />\n      <polygon\n         id="polygon1453"\n         points="20.72 17.2 20.72 17.2 21.41 10.4 22.7 13.4 20.72 17.2"\n         class="cls-1" />\n      <polygon\n         id="polygon1455"\n         points="22.7 13.4 25.69 14.7 20.72 17.2 22.7 13.4"\n         class="cls-1" />\n      <polygon\n         id="polygon1457"\n         points="20.72 17.2 20.72 17.2 20.72 17.2 20.72 17.2"\n         class="cls-3" />\n      <polygon\n         id="polygon1459"\n         points="20.72 17.2 20.72 17.2 25.69 14.7 25.69 18.99 20.72 17.2 20.72 17.2"\n         class="cls-1" />\n      <rect\n         id="rect1461"\n         transform="translate(-6.1 19.64) rotate(-44.9)"\n         y="17.2"\n         x="20.72"\n         class="cls-3" />\n      <polygon\n         id="polygon1463"\n         points="20.72 17.2 17.13 10.12 21.41 10.4 20.72 17.2 20.72 17.2"\n         class="cls-1" />\n      <polygon\n         id="polygon1465"\n         points="17.13 21.24 17.13 10.12 20.72 17.2 17.13 21.24"\n         class="cls-2" />\n      <path\n         id="path1467"\n         d="M65.89,5.37,63.45,6l-1,.76-.92,1L61,10.25l.47,2.44.94,1,1,.8,2.44.61,2.43-.64,2.43.64V5.37L68.32,6ZM67.59,12l-1.7.73L64.17,12l-.72-1.72.71-1.73,1.73-.71,1.77.66.66,1.78Z"\n         class="cls-4" />\n      <path\n         id="path1469"\n         d="M83.54,7.81l-.92-1L81.57,6l-2.43-.63h0L76.71,6l-2.43-.6V15.56h0v4.88h2.43V18h0V15.56h0V14.49l2.43.64h0l2.43-.61,1-.8.94-1L84,10.25ZM80.86,12l-1.72.72h0L77.44,12l-.73-1.71.66-1.78,1.77-.66h0l1.73.71.7,1.73Z"\n         class="cls-4" />\n      <polygon\n         id="polygon1471"\n         points="41.5 15.13 43.93 15.13 43.93 12.69 43.93 12.69 43.93 12.69 43.93 10.25 44.59 8.47 46.36 7.81 48.09 8.52 48.79 10.25 48.79 10.25 48.79 12.69 48.79 15.13 51.23 15.13 51.23 12.69 51.23 12.69 51.23 10.25 51.23 10.25 51.23 10.25 51.96 8.52 53.69 7.81 55.46 8.47 56.12 10.25 56.12 10.25 56.12 12.69 56.12 12.69 56.12 12.69 56.12 12.69 56.12 12.69 56.12 15.13 58.55 15.13 58.55 12.69 58.55 12.69 58.55 10.25 58.55 7.81 57.35 6.76 56.12 6 56.12 5.97 53.69 5.37 51.25 6 50.02 6.29 48.79 6 46.36 5.37 43.93 5.97 41.5 5.37 41.5 15.13"\n         class="cls-4" />\n      <path\n         id="path1473"\n         d="M103.52,6l-2.43-.6h0L98.66,6l-1,.76-.92,1-.47,2.44.47,2.44.94,1,1,.8,2.43.61h0l2.43-.64,2.44.64V5.37Zm-.73,6-1.7.73h0L99.37,12l-.71-1.72.7-1.73,1.73-.71h0l1.78.66.65,1.78Z"\n         class="cls-4" />\n      <polygon\n         id="polygon1475"\n         points="91.46 5.37 89.03 5.97 86.6 5.37 86.6 7.81 86.6 10.25 86.6 12.69 86.6 15.13 89.03 15.13 89.03 12.69 89.03 10.25 89.69 8.47 91.46 7.81 93.19 8.52 94.06 7.64 94.06 7.64 94.94 6.76 93.89 6 91.46 5.37"\n         class="cls-4" />\n      <polygon\n         id="polygon1477"\n         points="116.62 5.97 116.62 7.81 116.62 7.81 116.62 7.81 116.62 10.25 115.89 11.96 114.19 12.69 114.19 12.69 114.19 12.69 112.47 11.97 111.76 10.25 111.76 10.25 111.76 7.81 111.76 7.81 111.76 7.81 111.76 5.97 109.32 5.37 109.32 7.81 109.32 10.25 109.79 12.69 110.73 13.72 111.76 14.52 114.19 15.13 114.19 15.13 114.19 15.13 116.62 14.49 116.62 15.56 115.95 17.34 114.17 18 114.17 18 114.17 18 112.44 17.29 111.64 18.1 111.64 18.1 110.7 19.05 111.74 19.81 114.17 20.44 114.17 20.44 114.17 20.44 114.17 20.44 114.17 20.44 114.17 20.44 116.6 19.81 117.65 19.05 118.57 18 119.06 15.56 119.06 15.56 119.06 15.13 119.06 12.69 119.06 10.25 119.06 7.81 119.06 5.37 116.62 5.97"\n         class="cls-4" />\n    </g>\n  </g>\n</svg>\n';

var n$t='<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   id="svg1133"\n   version="1.1"\n   width="45",\n   height="28",\n   viewBox="0 0 34.26 21.24">\n  <metadata\n     id="metadata1137">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs979">\n    <style\n       id="style977">.cls-1{fill:#b5b5b6;}.cls-2{fill:#fff;}.cls-3{fill:#0086d1;}</style>\n  </defs>\n  <g\n     data-name="レイヤー2"\n     id="レイヤー2">\n    <g\n       id="layer1">\n      <polygon\n         id="polygon983"\n         points="11.24 10.4 10.47 8.48 10.47 8.48 8.57 7.71 8.57 7.71 8.56 7.71 8.56 7.71 8.56 7.71 6.62 8.44 6.62 8.44 5.89 10.4 5.89 10.4 5.89 10.4 5.89 10.4 5.89 10.4 6.62 12.36 6.62 12.36 8.56 13.09 8.56 13.09 8.56 13.09 8.57 13.09 8.57 13.09 10.46 12.31 10.46 12.31 11.24 10.4 11.24 10.4 11.24 10.4 11.24 10.4 11.24 10.4"\n         class="cls-1" />\n      <polygon\n         id="polygon985"\n         points="4.28 5.38 4.28 5.38 4.28 0 2.45 4.26 4.28 5.38"\n         class="cls-2" />\n      <polygon\n         id="polygon987"\n         points="2.45 4.26 0.82 6.1 4.28 5.38 2.45 4.26"\n         class="cls-1" />\n      <polygon\n         id="polygon989"\n         points="4.28 5.38 4.28 5.38 4.28 5.38 4.28 5.38"\n         class="cls-3" />\n      <polygon\n         id="polygon991"\n         points="4.28 5.38 4.28 5.38 0.82 6.1 0 10.4 4.28 5.38 4.28 5.38"\n         class="cls-2" />\n      <polygon\n         id="polygon993"\n         points="0 10.4 4.28 10.4 4.28 5.38 0 10.4"\n         class="cls-1" />\n      <rect\n         id="rect995"\n         transform="translate(-2.55 4.62) rotate(-45.1)"\n         y="5.38"\n         x="4.28"\n         class="cls-3" />\n      <polygon\n         id="polygon997"\n         points="4.28 5.38 4.28 10.4 5.52 7.35 4.28 5.38 4.28 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon999"\n         points="4.28 5.38 5.52 7.35 8.56 6.1 4.28 5.38 4.28 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1001"\n         points="4.28 5.38 8.56 1.8 4.28 0 4.28 5.38 4.28 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1003"\n         points="8.56 6.1 8.56 1.8 4.28 5.38 8.56 6.1"\n         class="cls-1" />\n      <polygon\n         id="polygon1005"\n         points="13.66 5.66 13.66 5.66 13.49 2.87 8.56 1.8 13.66 5.66"\n         class="cls-2" />\n      <polygon\n         id="polygon1007"\n         points="8.56 1.8 8.56 6.1 13.66 5.66 8.56 1.8"\n         class="cls-1" />\n      <polygon\n         id="polygon1009"\n         points="13.66 5.66 13.66 5.66 13.66 5.66 13.66 5.66"\n         class="cls-3" />\n      <polygon\n         id="polygon1011"\n         points="13.66 5.66 13.66 5.66 8.56 6.1 11.69 7.26 13.66 5.66 13.66 5.66"\n         class="cls-1" />\n      <polygon\n         id="polygon1013"\n         points="11.69 7.26 12.85 10.4 13.66 5.66 11.69 7.26"\n         class="cls-1" />\n      <rect\n         id="rect1015"\n         transform="translate(0.01 11.34) rotate(-45.1)"\n         y="5.66"\n         x="13.66"\n         class="cls-3" />\n      <polygon\n         id="polygon1017"\n         points="13.66 5.66 12.85 10.4 17.13 10.12 13.66 5.66 13.66 5.66"\n         class="cls-1" />\n      <polygon\n         id="polygon1019"\n         points="13.66 5.66 17.13 4.66 13.49 2.87 13.66 5.66 13.66 5.66"\n         class="cls-2" />\n      <polyline\n         id="polyline1021"\n         points="13.66 5.66 13.66 5.66 17.13 10.12 17.13 4.66 13.66 5.66"\n         class="cls-2" />\n      <polygon\n         id="polygon1023"\n         points="4.28 15.41 4.28 15.41 4.28 10.4 0 10.4 4.28 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1025"\n         points="0 10.4 0.82 14.7 4.28 15.41 0 10.4"\n         class="cls-2" />\n      <polygon\n         id="polygon1027"\n         points="4.28 15.41 4.28 15.41 4.28 15.41 4.28 15.41"\n         class="cls-3" />\n      <polygon\n         id="polygon1029"\n         points="4.28 15.41 4.28 15.41 0.82 14.7 2.48 16.5 4.28 15.41 4.28 15.41"\n         class="cls-2" />\n      <polygon\n         id="polygon1031"\n         points="2.48 16.5 4.28 17.91 4.28 15.41 2.48 16.5"\n         class="cls-2" />\n      <rect\n         id="rect1033"\n         transform="translate(-9.66 7.57) rotate(-45.1)"\n         y="15.41"\n         x="4.28"\n         class="cls-3" />\n      <polygon\n         id="polygon1035"\n         points="4.28 15.41 4.28 17.91 8.56 18.99 4.28 15.41 4.28 15.41"\n         class="cls-2" />\n      <polygon\n         id="polygon1037"\n         points="4.28 15.41 8.56 18.99 8.56 14.7 4.28 15.41 4.28 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1039"\n         points="4.28 15.41 5.54 13.44 4.28 10.4 4.28 15.41 4.28 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1041"\n         points="8.56 14.7 5.54 13.44 4.28 15.41 8.56 14.7"\n         class="cls-1" />\n      <polygon\n         id="polygon1043"\n         points="13.48 17.2 13.48 17.2 12.85 10.4 11.56 13.4 13.48 17.2"\n         class="cls-1" />\n      <polygon\n         id="polygon1045"\n         points="11.56 13.4 8.56 14.7 13.48 17.2 11.56 13.4"\n         class="cls-1" />\n      <polygon\n         id="polygon1047"\n         points="13.48 17.2 13.48 17.2 13.48 17.2 13.48 17.2"\n         class="cls-3" />\n      <polygon\n         id="polygon1049"\n         points="13.48 17.2 13.48 17.2 8.56 14.7 8.56 18.99 13.48 17.2 13.48 17.2"\n         class="cls-1" />\n      <rect\n         id="rect1051"\n         transform="translate(-8.22 14.6) rotate(-45.1)"\n         y="17.2"\n         x="13.48"\n         class="cls-3" />\n      <polygon\n         id="polygon1053"\n         points="13.48 17.2 17.13 10.12 12.85 10.4 13.48 17.2 13.48 17.2"\n         class="cls-1" />\n      <polygon\n         id="polygon1055"\n         points="17.13 21.24 17.13 10.12 13.48 17.2 17.13 21.24"\n         class="cls-2" />\n      <polygon\n         id="polygon1057"\n         points="23.02 10.4 23.78 8.48 23.78 8.48 25.69 7.71 25.69 7.71 25.69 7.71 25.7 7.71 25.7 7.71 27.64 8.44 27.64 8.44 28.37 10.4 28.37 10.4 28.37 10.4 28.37 10.4 28.37 10.4 27.64 12.36 27.64 12.36 25.7 13.09 25.7 13.09 25.69 13.09 25.69 13.09 25.69 13.09 23.79 12.31 23.79 12.31 23.02 10.4 23.02 10.4 23.02 10.4 23.02 10.4 23.02 10.4"\n         class="cls-1" />\n      <polygon\n         id="polygon1059"\n         points="29.98 5.38 29.98 5.38 29.98 0 31.81 4.26 29.98 5.38"\n         class="cls-2" />\n      <polygon\n         id="polygon1061"\n         points="31.81 4.26 33.44 6.1 29.98 5.38 31.81 4.26"\n         class="cls-1" />\n      <polygon\n         id="polygon1063"\n         points="29.98 5.38 29.98 5.38 29.98 5.38 29.98 5.38"\n         class="cls-3" />\n      <polygon\n         id="polygon1065"\n         points="29.98 5.38 29.98 5.38 33.44 6.1 34.26 10.4 29.98 5.38 29.98 5.38"\n         class="cls-2" />\n      <polygon\n         id="polygon1067"\n         points="34.26 10.4 29.98 10.4 29.98 5.38 34.26 10.4"\n         class="cls-1" />\n      <rect\n         id="rect1069"\n         transform="translate(4.94 22.73) rotate(-44.9)"\n         y="5.38"\n         x="29.98"\n         class="cls-3" />\n      <polygon\n         id="polygon1071"\n         points="29.98 5.38 29.98 10.4 28.73 7.35 29.98 5.38 29.98 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1073"\n         points="29.98 5.38 28.73 7.35 25.69 6.1 29.98 5.38 29.98 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1075"\n         points="29.98 5.38 25.69 1.8 29.98 0 29.98 5.38 29.98 5.38"\n         class="cls-1" />\n      <polygon\n         id="polygon1077"\n         points="25.69 6.1 25.69 1.8 29.98 5.38 25.69 6.1"\n         class="cls-1" />\n      <polygon\n         id="polygon1079"\n         points="20.6 5.66 20.6 5.66 20.76 2.87 25.69 1.8 20.6 5.66"\n         class="cls-2" />\n      <polygon\n         id="polygon1081"\n         points="25.69 1.8 25.69 6.1 20.6 5.66 25.69 1.8"\n         class="cls-1" />\n      <polygon\n         id="polygon1083"\n         points="20.6 5.66 20.6 5.66 20.6 5.66 20.6 5.66"\n         class="cls-3" />\n      <polygon\n         id="polygon1085"\n         points="20.6 5.66 20.6 5.66 25.69 6.1 22.57 7.26 20.6 5.66 20.6 5.66"\n         class="cls-1" />\n      <polygon\n         id="polygon1087"\n         points="22.57 7.26 21.41 10.4 20.6 5.66 22.57 7.26"\n         class="cls-1" />\n      <rect\n         id="rect1089"\n         transform="translate(2.01 16.19) rotate(-44.9)"\n         y="5.66"\n         x="20.6"\n         class="cls-3" />\n      <polygon\n         id="polygon1091"\n         points="20.6 5.66 21.41 10.4 17.13 10.12 20.6 5.66 20.6 5.66"\n         class="cls-1" />\n      <polygon\n         id="polygon1093"\n         points="20.6 5.66 17.13 4.66 20.76 2.87 20.6 5.66 20.6 5.66"\n         class="cls-2" />\n      <polyline\n         id="polyline1095"\n         points="20.6 5.66 20.6 5.66 17.13 10.12 17.13 4.66 20.6 5.66"\n         class="cls-2" />\n      <polygon\n         id="polygon1097"\n         points="29.98 15.41 29.98 15.41 29.98 10.4 34.26 10.4 29.98 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1099"\n         points="34.26 10.4 33.44 14.7 29.98 15.41 34.26 10.4"\n         class="cls-2" />\n      <polygon\n         id="polygon1101"\n         points="29.98 15.41 29.98 15.41 29.98 15.41 29.98 15.41"\n         class="cls-3" />\n      <polygon\n         id="polygon1103"\n         points="29.98 15.41 29.98 15.41 33.44 14.7 31.78 16.5 29.98 15.41 29.98 15.41"\n         class="cls-2" />\n      <polygon\n         id="polygon1105"\n         points="31.78 16.5 29.98 17.91 29.98 15.41 31.78 16.5"\n         class="cls-2" />\n      <rect\n         id="rect1107"\n         transform="translate(-2.14 25.66) rotate(-44.9)"\n         y="15.41"\n         x="29.98"\n         class="cls-3" />\n      <polygon\n         id="polygon1109"\n         points="29.98 15.41 29.98 17.91 25.69 18.99 29.98 15.41 29.98 15.41"\n         class="cls-2" />\n      <polygon\n         id="polygon1111"\n         points="29.98 15.41 25.69 18.99 25.69 14.7 29.98 15.41 29.98 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1113"\n         points="29.98 15.41 28.72 13.44 29.98 10.4 29.98 15.41 29.98 15.41"\n         class="cls-1" />\n      <polygon\n         id="polygon1115"\n         points="25.69 14.7 28.72 13.44 29.98 15.41 25.69 14.7"\n         class="cls-1" />\n      <polygon\n         id="polygon1117"\n         points="20.72 17.2 20.72 17.2 21.41 10.4 22.7 13.4 20.72 17.2"\n         class="cls-1" />\n      <polygon\n         id="polygon1119"\n         points="22.7 13.4 25.69 14.7 20.72 17.2 22.7 13.4"\n         class="cls-1" />\n      <polygon\n         id="polygon1121"\n         points="20.72 17.2 20.72 17.2 20.72 17.2 20.72 17.2"\n         class="cls-3" />\n      <polygon\n         id="polygon1123"\n         points="20.72 17.2 20.72 17.2 25.69 14.7 25.69 18.99 20.72 17.2 20.72 17.2"\n         class="cls-1" />\n      <rect\n         id="rect1125"\n         transform="translate(-6.1 19.64) rotate(-44.9)"\n         y="17.2"\n         x="20.72"\n         class="cls-3" />\n      <polygon\n         id="polygon1127"\n         points="20.72 17.2 17.13 10.12 21.41 10.4 20.72 17.2 20.72 17.2"\n         class="cls-1" />\n      <polygon\n         id="polygon1129"\n         points="17.13 21.24 17.13 10.12 20.72 17.2 17.13 21.24"\n         class="cls-2" />\n    </g>\n  </g>\n</svg>\n';

class i$a extends t$a{constructor(t,o={}){super(t,o),this._position=o.position||t$a.ContainerPosition.BOTTOM_LEFT;}_sizeChanged(){if(this._container){var t=this._container.children[0];this._container.parentElement.parentElement.clientWidth<t$a._compact_size?t.classList.add("mapray-logo-compact"):t.classList.remove("mapray-logo-compact");}}createContainer(){var t="control-"+this._position,e=this._viewer_container.getElementsByClassName(t)[0],o=document.createElement("div");o.className="control";var a=document.createElement("a");a.className="mapray-logo",a.href="https://mapray.com",a.target="_blank",o.appendChild(a),this._container=o,e.appendChild(this._container),this._sizeChanged();}getLogoImage(e){return __awaiter(this,void 0,void 0,(function*(){return e.mini?(n$s||(n$s=yield r$t.loadImage(r$t.convertSVGToDataURL(n$t))),n$s):(s$8||(s$8=yield r$t.loadImage(r$t.convertSVGToDataURL(n$u))),s$8)}))}}let s$8,n$s;

class i$9 extends t$a{constructor(a,n={}){super(a,n),this._position=n.position||t$a.ContainerPosition.BOTTOM_RIGHT,this._attributions=[],n&&n.attributions?this._copyAttributions(n.attributions):this._copyAttributions(i$9._default_attribution);}addAttribution(t){this._attributions.push(t),this._deleteContainer(),this.createContainer();}clearAttribution(){this._attributions=[],this._deleteContainer(),this.createContainer();}_sizeChanged(){this._container&&(this._container.parentElement.parentElement.clientWidth<t$a._compact_size?this._container.classList.add("mapray-attribution-compact"):this._container.classList.remove("mapray-attribution-compact"));}createContainer(){var t="control-"+this._position,i=this._viewer_container.getElementsByClassName(t)[0],a=document.createElement("div");a.classList.add("control"),a.classList.add("mapray-attribution");var n=document.createElement("div");for(var e of(n.classList.add("mapray-attribution-container"),this._attributions))if(e.display){var s=document.createElement("a");e.link&&(s.href=e.link,s.target="_blank");var r=document.createTextNode(e.display);s.appendChild(r),n.appendChild(s);}a.appendChild(n),this._container=a,i.appendChild(this._container),this._sizeChanged();}_copyAttributions(t){this._attributions=t.map((t=>t));}}!function(t){t._default_attribution=[{display:"©Mapray",link:"https://mapray.com"},{display:"©JAXA",link:"http://www.jaxa.jp/"},{display:"測量法に基づく国土地理院長承認（複製）H30JHf626",link:"https://www.gsi.go.jp/kiban/index.html"}];}(i$9||(i$9={}));var a$a=i$9;

s$9();class V{constructor(e,r={}){var o,n,s,a,l,c;if(this._frame_req_id=0,this._is_destroyed=!1,this._postProcesses=[],"string"==typeof e){const t=document.getElementById(e);if(!t)throw new Error("element couldn't be found: "+e);c=t;}else {if(!(e instanceof HTMLElement))throw new Error("unsupported type: "+e);c=e;}var d=this._createCanvas(c);const m=new V.PoleInfo(r.pole);this._container_element=c,this._canvas_element=d,this._glenv=new t$v(d),this._camera=new i$m(d),this._animation=this._createAnimationBindingBlock(),this._dem_provider=this._createDemProvider(r),this._image_provider=this._createImageProvider(r),this.pole_info=m,this._tile_texture_cache=new o$k(this._glenv,this._image_provider,{pole_info:m}),this._layers=this._createLayerCollection(r),this._globe=new p$1(this._glenv,this._dem_provider,{pole_info:m}),this._b3d_collection=new n$z(this),this._vectile_manager=null,this._scene=new i$d(this,this._glenv),this._ground_visibility=null===(o=r.ground_visibility)||void 0===o||o,this._entity_visibility=null===(n=r.entity_visibility)||void 0===n||n,this._point_cloud_visibility=null===(s=r.point_cloud_visibility)||void 0===s||s,this._b3d_scene_visibility=null===(a=r.b3d_scene_visibility)||void 0===a||a,this._vectile_visibility=null===(l=r.vectile_visibility)||void 0===l||l,this._render_mode=r.render_mode||"@@_Viewer.RenderMode.SURFACE",this._debug_stats=r.debug_stats,this._point_cloud_collection=this._createPointCloudCollection(r),this._render_callback=this._createRenderCallback(r),this._sun=new e$c,this._moon=new t$b,this._load_status={dem_loading:0,img_loading:0,b3d_loading:0,pc_loading:0,total_loading:0};const v=r.atmosphere;v&&(this._atmosphere=v,v.init(this));const p=r.sun_visualizer;p&&(this._sunVisualizer=p,p.init(this));const b=r.moon_visualizer;b&&(this._moonVisualizer=b,b.init(this));const E=r.cloud_visualizer;E&&(this._cloudVisualizer=E,E.init(this));const R=r.star_visualizer;R&&(this._starVisualizer=R,R.init(this)),this._logo_controller=r&&r.logo_controller||new i$a(this._container_element),this._attribution_controller=r&&r.attribution_controller||new a$a(this._container_element),this._createLogoAttributionContainer(),this._logo_controller.createContainer(),this._attribution_controller.createContainer(),this._requestNextFrame(),this._updateCanvasSize();}destroy(){var e;this._is_destroyed||(0!=this._frame_req_id&&(o$a.maprayCancelAnimationFrame(this._frame_req_id),this._frame_req_id=0),this._render_callback.detach(),this._render_callback=this._createRenderCallback({}),this._container_element.removeChild(this._canvas_element),null===(e=this._vectile_manager)||void 0===e||e.__cancel(this._globe),this._globe.cancel(),this._tile_texture_cache.cancel(),this._layers.cancel(),this._b3d_collection.clearScenes(),this._scene.cancelLoaders(),this._logo_controller._destroy(),this._attribution_controller._destroy(),this._attribution_controller=null,this._deleteLogoAttributionContainer(),this._is_destroyed=!0);}_createCanvas(e){var t=document.createElement("canvas");return t.className="mapray-canvas",t.style.width="100%",t.style.height="100%",e.appendChild(t),t}_createDemProvider(e){return e.dem_provider?e.dem_provider:new t$g("/dem/",".bin")}_createAnimationBindingBlock(){let e=new i$u;return e.addDescendantUnbinder((()=>{this._unbindDescendantAnimations();})),e}_createImageProvider(e){return e.image_provider?e.image_provider:new o$d("http://cyberjapandata.gsi.go.jp/xyz/std/",".png",256,0,18)}_createLayerCollection(e){var t=e.layers?e.layers:void 0;return new r$c(this,t)}_createPointCloudCollection(e){return new e$f(this._scene)}_createRenderCallback(e){var t;return (t=e&&e.render_callback?e.render_callback:new r$n).attach(this),t}_createLogoAttributionContainer(){for(var e of V._positions){var t=document.createElement("div");t.className=e,this._container_element.appendChild(t);}}_deleteLogoAttributionContainer(){for(var e of V._positions){var t=document.getElementById(e);t&&this._container_element.removeChild(t);}}get container_element(){return this._container_element}get canvas_element(){return this._canvas_element}get animation(){return this._animation}get dem_provider(){return this._dem_provider}get image_provider(){return this._image_provider}get layers(){return this._layers}get point_cloud_collection(){return this._point_cloud_collection}get b3d_collection(){return this._b3d_collection}get render_callback(){return this._render_callback}get render_mode(){return this._render_mode}set render_mode(e){this._render_mode=e;}get debug_stats(){return this._debug_stats}get camera(){return this._camera}get vectile_manager(){return this._vectile_manager}get scene(){return this._scene}get glenv(){return this._glenv}get globe(){return this._globe}get tile_texture_cache(){return this._tile_texture_cache}get logo_controller(){return this._logo_controller}get attribution_controller(){return this._attribution_controller}get load_status(){return this._load_status}get sun(){return this._sun}get moon(){return this._moon}get atmosphere(){return this._atmosphere}get sunVisualizer(){return this._sunVisualizer}get moonVisualizer(){return this._moonVisualizer}get cloudVisualizer(){return this._cloudVisualizer}get starVisualizer(){return this._starVisualizer}setVisibility(e,t){switch(e){case"@@_Viewer.Category.GROUND":this._ground_visibility=t;break;case"@@_Viewer.Category.ENTITY":this._entity_visibility=t;break;case"@@_Viewer.Category.POINT_CLOUD":this._point_cloud_visibility=t;break;case"@@_Viewer.Category.B3D_SCENE":this._b3d_scene_visibility=t;break;case"@@_Viewer.Category.VECTILE":this._vectile_visibility=t;break;default:throw new Error("invalid target: "+e)}}getVisibility(e){switch(e){case"@@_Viewer.Category.GROUND":return this._ground_visibility;case"@@_Viewer.Category.ENTITY":return this._entity_visibility;case"@@_Viewer.Category.POINT_CLOUD":return this._point_cloud_visibility;case"@@_Viewer.Category.B3D_SCENE":return this._b3d_scene_visibility;case"@@_Viewer.Category.VECTILE":return this._vectile_visibility;default:throw new Error("invalid target: "+e)}}setVectileManager(e){var t;if(e!==this._vectile_manager){if(e&&e.viewer!==this)throw new Error("The given StyleManager instance was not created for this Viewer instance");null===(t=this._vectile_manager)||void 0===t||t.__cancel(this._globe),this._vectile_manager=e;}}getElevation(e,t){var i=t+180*Math.floor((90-e)/360+Math.floor((90+e)/360)),r=90-Math.abs(90-e+360*Math.floor((90+e)/360)),o=(i-360-360*Math.floor((i-180)/360))*e$z.DEGREE,n=e$z.invGudermannian(r*e$z.DEGREE),s=2*Math.PI,a=o/s+.5,_=.5-n/s,l=this._globe,c=l.findHighestAccuracy(a,_);if(null===c)return 0;var h=1<<l.dem_provider.getResolutionPower(),u=Math.pow(2,c.z),g=h*(u*a-c.x),m=h*(u*_-c.y),v=e$z.clamp(Math.floor(g),0,h-1),p=e$z.clamp(Math.floor(m),0,h-1),b=c.getHeights(v,p),y=g-v,f=m-p;return (b[0]*(1-y)+b[1]*y)*(1-f)+(b[2]*(1-y)+b[3]*y)*f}getExistingElevation(e){const t=[e.longitude,e.latitude,0];return this._globe.getExistingElevations(1,t,0,3,t,2,3),t[2]}getExistingElevations(e,t,i,r,o,n,s){return this._globe.getExistingElevations(e,t,i,r,o,n,s)}pickWithRay(e,t={}){var i,r,o,n;let s,a,_=void 0!==t.limit?t.limit:Number.MAX_VALUE;if(-1===(null!==(r=null===(i=t.exclude_category)||void 0===i?void 0:i.indexOf("@@_Viewer.Category.B3D_SCENE"))&&void 0!==r?r:-1)&&(a=this._b3d_collection.getRayIntersection(e,_),a&&(s="@@_Viewer.Category.B3D_SCENE",_=a.distance)),-1===(null!==(n=null===(o=t.exclude_category)||void 0===o?void 0:o.indexOf("@@_Viewer.Category.GROUND"))&&void 0!==n?n:-1)&&"@@_READY"===this._globe.status){const t=this._globe.findRayDistance(e,_);t!==_&&(s="@@_Viewer.Category.GROUND",_=t);}if(void 0===s)return;const l=e$z.createVector3(),c=e.position,h=e.direction;for(let e=0;e<3;++e)l[e]=c[e]+_*h[e];const u={category:s,distance:_,position:l};return "@@_Viewer.Category.B3D_SCENE"===s&&a&&(u.b3d_scene=a.b3d_scene,u.feature_id=a.feature_id),u}capture(t={type:"jpeg"}){return __awaiter(this,void 0,void 0,(function*(){if(!this._canvas_element)throw new Error("Canvas is null.");const e="png"===t.type?"image/png":"image/jpeg";let i;if(t.sync){let e=0;i=yield new Promise((t=>{this._postProcesses.push((()=>this.load_status.total_loading>0?(e=0,!0):e++<4||(R=r$t.copyTo2dCanvasContext(this._canvas_element,R),t(R),!1)));}));}else i=yield new Promise((e=>{this._postProcesses.push((()=>(R=r$t.copyTo2dCanvasContext(this._canvas_element,R),e(R),!1)));}));yield this._post_render_for_capture(i,t);const r=yield new Promise((t=>{i.canvas.toBlob(t,e);}));if(!r)throw new Error("failed to capture image");return r}))}_post_render_for_capture(t,i){return __awaiter(this,void 0,void 0,(function*(){const e=t.canvas.width,r=t.canvas.height;let o=0,n=0;if(i.attribution_text){t.font="12px Noto Sans JP,sans-serif",t.textBaseline="bottom",t.textAlign="left";const s=t.measureText(i.attribution_text);o=s.width,n=s.actualBoundingBoxDescent+s.actualBoundingBoxAscent,t.fillStyle="rgba(255,255,255,0.5)",t.fillRect(e-o-20,r-n-16,o+20,n+16),t.fillStyle="rgba(0,0,0,1)",t.fillText(i.attribution_text,e-o-10,r-8);}{const i=yield this.logo_controller.getLogoImage({mini:e-o-20<180});t.drawImage(i,6,r-i.height-4,i.width,i.height);}}))}_requestNextFrame(){this._frame_req_id=o$a.maprayRequestAnimationFrame((()=>this._updateFrame()));}_updateFrame(){var e=this._updateTime();this._requestNextFrame(),this._updateCanvasSize(),this._render_callback.onUpdateFrameInner(e),this._debug_stats&&this._debug_stats.clearStats(),new l$5.SceneRenderStage(this).render(),this._postProcess(),this._updateLoadStatus(),this._finishDebugStats();}_updateLoadStatus(){var e,t;const i=this._load_status;i.dem_loading=this._globe.getNumDemWaitingRequests(),i.img_loading=this._tile_texture_cache.getNumWaitingRequests(),i.b3d_loading=0;const r=this._b3d_collection.getIterator();for(;r.value;)i.b3d_loading+=Math.max(0,r.value._num_tile_requesteds),r.next();const o=h$4.getStatistics();i.pc_loading=null!==(t=null===(e=null==o?void 0:o.statistics_obj)||void 0===e?void 0:e.loading_boxes)&&void 0!==t?t:0,i.total_loading=i.dem_loading+i.img_loading+i.b3d_loading+i.pc_loading;}pick(e,t={}){const i=new l$5.PickRenderStage(this,e,t);i.render();const r=i.pick_result;if(r&&"@@_Viewer.Category.B3D_SCENE"===r.category){const i=this._camera.getCanvasRay(e),o=this.pickWithRay(i,t);r.b3d_scene=null==o?void 0:o.b3d_scene,r.feature_id=null==o?void 0:o.feature_id;}return r}_updateTime(){var e=o$a.maprayNow(),t=void 0!==this._previous_time?(e-this._previous_time)/1e3:0;return this._previous_time=e,t}_updateCanvasSize(){var e=this._canvas_element;e.width!=e.clientWidth&&(e.width=e.clientWidth),e.height!=e.clientHeight&&(e.height=e.clientHeight);}_postProcess(){if(0===this._postProcesses.length)return;const e=[];this._postProcesses.forEach((t=>{t()&&e.push(t);})),this._postProcesses=e;}_finishDebugStats(){var e=this._debug_stats;if(!e)return;const t=this._load_status;e.num_wait_reqs_dem=t.dem_loading,e.num_wait_reqs_img=t.img_loading,e.onUpdate();}_unbindDescendantAnimations(){this._scene.animation.unbindAllRecursively();}}let R;!function(e){var t,i;e.PoleInfo=class{constructor(e){var t,i,r,o;const n=[.8,.8,.8];e?(this.enabled=!0,this.north_height=null!==(t=e.north_height)&&void 0!==t?t:0,this.south_height=null!==(i=e.south_height)&&void 0!==i?i:0,this.north_color=e$z.createVector3(null!==(r=e.north_color)&&void 0!==r?r:n),this.south_color=e$z.createVector3(null!==(o=e.south_color)&&void 0!==o?o:n)):(this.enabled=!1,this.north_height=0,this.south_height=0,this.north_color=n,this.south_color=n);}},(t=e.Category||(e.Category={})).GROUND="@@_Viewer.Category.GROUND",t.ENTITY="@@_Viewer.Category.ENTITY",t.POINT_CLOUD="@@_Viewer.Category.POINT_CLOUD",t.B3D_SCENE="@@_Viewer.Category.B3D_SCENE",t.VECTILE="@@_Viewer.Category.VECTILE",(i=e.RenderMode||(e.RenderMode={})).SURFACE="@@_Viewer.RenderMode.SURFACE",i.WIREFRAME="@@_Viewer.RenderMode.WIREFRAME",e.ContainerPosition=t$a.ContainerPosition,e._positions=["control-top-left","control-top-right","control-bottom-left","control-bottom-right"];}(V||(V={}));var x=V;

class _$3{constructor(){this.num_wait_reqs_dem=0,this.num_wait_reqs_img=0,this.num_drawing_flakes=0,this.num_drawing_flake_vertices=0,this.num_procA_flakes=0,this.num_procB_flakes=0;}clearStats(){this.num_wait_reqs_dem=0,this.num_wait_reqs_img=0,this.num_drawing_flakes=0,this.num_drawing_flake_vertices=0,this.num_procA_flakes=0,this.num_procB_flakes=0;}onUpdate(){}}

class e$b{constructor(e){this._vertices=Float64Array.from(e),this._num_vertices=this._vertices.length/2;}get num_vertices(){return this._num_vertices}get vertices(){return this._vertices}static createByRectangle(t,s,i,r){return new e$b([t,s,i,s,i,r,t,r])}isValid(){if(this._num_vertices<3)return !1;for(let e=0;e<this._num_vertices;++e){let t=this._vertices[2*e],s=this._vertices[2*e+1];if(!Number.isFinite(t)||!Number.isFinite(s))return !1}for(let e=0;e<this._num_vertices;++e){let t=0!=e?e-1:this._num_vertices-1,s=this._vertices[2*t],i=this._vertices[2*t+1],r=this._vertices[2*e],_=this._vertices[2*e+1];if(s==r&&i==_)return !1}for(let e=0;e<this._num_vertices;++e){let t=this._vertices[2*e],s=this._vertices[2*e+1],i=e==this._num_vertices-1?0:e+1,r=this._vertices[2*i]-t,_=this._vertices[2*i+1]-s,c=0==e?this._num_vertices-1:e-1,h=this._vertices[2*c]-t,n=this._vertices[2*c+1]-s,l=r*n-h*_,u=r*h+_*n;if(l<0||0==l&&u>0)return !1}return !0}getIntersection(e){try{return this._clip_by_polygon(e)}catch(e){throw new Error("ConvexPolygon#getIntersection failed")}}hasIntersection(e){try{return null!==this._clip_by_polygon(e)}catch(e){throw new Error("ConvexPolygon#hasIntersection failed")}}includes(e){for(let t=0;t<this._num_vertices;++t){let s=0!=t?t-1:this._num_vertices-1,i=this._vertices[2*s],r=this._vertices[2*s+1],_=r-this._vertices[2*t+1],c=this._vertices[2*t]-i,h=i*_+r*c;for(let t=0;t<e._num_vertices;++t){if(e._vertices[2*t]*_+e._vertices[2*t+1]*c<h)return !1}}return !0}_clip_by_polygon(e){let t=e;for(let e=0;e<this._num_vertices;++e){let s=0!=e?e-1:this._num_vertices-1,i=this._vertices[2*s],r=this._vertices[2*s+1],_=r-this._vertices[2*e+1],c=this._vertices[2*e]-i,h=i*_+r*c;if(t=t._clip_by_halfspace(_,c,h),null===t)break}return t}_clip_by_halfspace(e,t,s){let i=Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let _=0;_<this._num_vertices;++_){let c=this._vertices[2*_]*e+this._vertices[2*_+1]*t-s;i=Math.min(i,c),r=Math.max(r,c);}return i>=0?this:r<=0?null:this._clip_by_crossed_halfspace(e,t,s)}_clip_by_crossed_halfspace(t,s,i){let[r,_]=this._get_cross_edges_by_crossed_halfspace_boundary(t,s,i),c=[];c.push(r.qx),c.push(r.qy);let h=r.ei,n=_.ei;for(let e=h;e!=n;e=(e+1)%this._num_vertices)c.push(this._vertices[2*e]),c.push(this._vertices[2*e+1]);return c.push(_.qx),c.push(_.qy),new e$b(c)}_get_cross_edges_by_crossed_halfspace_boundary(e,t,s){let i=new Array(2);for(let r=0,_=0;_<2;++r){if(r==this._num_vertices)throw new Error("cross edges could not be found");let c=(r+1)%this._num_vertices,h=this._vertices[2*r],n=this._vertices[2*r+1],l=this._vertices[2*c],u=this._vertices[2*c+1],v=h*e+n*t-s,o=l*e+u*t-s;if(v<=0&&0<o||o<=0&&0<v){let e=v/(v-o),t=h+(l-h)*e,s=n+(u-n)*e;i[v<o?0:1]={ei:c,qx:t,qy:s},++_;}}return i}}

class r$a extends e$n{constructor(e){super(),this._headers={"X-Api-Key":e};}requestTile(e,r,t,s){var a=new AbortController;return fetch(this._makeURL(e,r,t),{headers:this._headers,signal:a.signal}).then((e=>e.ok?e.arrayBuffer():Promise.reject(Error(e.statusText)))).then((e=>{s(e);})).catch((()=>{s(null);})),a}cancelRequest(e){e.abort();}_makeURL(e,r,t){return "https://tiles.mapray.com/dem/"+e+"/"+r+"/"+t+".bin"}}

var n$r="/**\n * 太さ付き線分の頂点シェーダ\n */\n\nattribute vec4 a_position;      // 頂点位置 (モデル座標系)\nattribute vec3 a_direction;     // 線分方向 (モデル座標系) = 終点位置 - 始点位置\nattribute vec2 a_where;         // 線分の4隅指定: 始点左: {-1, 1}, 始点右: {-1, -1}, 終点左: {1, 1}, 終点右: {1, -1}\nattribute float a_length;\n\nuniform mat4 u_obj_to_clip;     // モデル座標系からクリップ座標系への変換\nuniform vec3 u_sparam;          // 画面パラメータ: {2/w, 2/h, h/w}\nuniform vec2 u_thickness;       // 線の太さの半分: {u, v}\n\nvarying highp float  v_length;  // 始点からの距離 (PathEntityのみ利用)\n\nvec2\noffset( vec4 cpos )\n{\n    vec4 q0 = cpos;\n    q0.y *= u_sparam.z;  // q0 = A * q0\n    vec4 q1 = cpos + u_obj_to_clip * vec4( a_direction, 0 );\n    q1.y *= u_sparam.z;  // q1 = A * q1\n\n    vec2 ds = normalize( q1.xy / q1.w - q0.xy / q0.w );\n    vec2 wt = a_where * u_thickness;\n    return mat2( ds.x, ds.y, -ds.y, ds.x ) * wt;\n}\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    gl_Position.xy += offset( gl_Position ) * u_sparam.xy * gl_Position.w;\n    v_length = a_length;\n}\n";

var n$q="/**\n * 太さ付き線分のフラグメントシェーダ\n * RID描画に対応\n */\n\nprecision mediump float;\n\n\n\n#ifdef PATH\nuniform highp float u_lower_length; // 距離の下限値 (PathEntityのみ利用)\nuniform highp float u_upper_length; // 距離の上限値 (PathEntityのみ利用)\n\nvarying highp float  v_length;      // 始点からの距離 (PathEntityのみ利用)\n#endif // PATH\n\n#ifdef RID\nuniform highp vec4 u_rid;           // rid\n#else // RID\nuniform vec4 u_color;               // 線の基本色と不透明度\n#endif // RID\n\n\nvoid\nmain()\n{\n#ifdef PATH\n    if ( u_lower_length <= v_length && v_length <= u_upper_length ) {\n#endif // PATH\n\n#ifdef RID\n        gl_FragColor = u_rid;\n#else // RID\n        gl_FragColor = vec4( u_color.xyz * u_color.w, u_color.w );\n#endif // RID\n\n#ifdef PATH\n    }\n    else {\n        discard;  // フラグメントを破棄\n    }\n#endif // PATH\n}\n";

class a$9 extends o$b{constructor(e,t,s={}){const i=a$9._getPreamble(t,s);super(e,i+n$r,i+n$q),this._line_type=t;}isTranslucent(e,t){var r=t.properties;return (void 0!==r.opacity?r.opacity:a$9.DEFAULT_OPACITY)<1}setParameters(e,r){super.setParameters(e,r);var o=r.properties;this.setObjToClip(e,r);var _=a$9._sparam;_[0]=2/e._width,_[1]=2/e._height,_[2]=e._height/e._width,this.setVector3("u_sparam",_);var c=o.width||a$9.DEFAULT_WIDTH,n=a$9._thickness;if(n[0]=c/2,n[1]=c/2,this.setVector2("u_thickness",n),e.getRenderTarget()===l$5.RenderTarget.SCENE){var p=void 0!==o.color?o.color:a$9.DEFAULT_COLOR,h=void 0!==o.opacity?o.opacity:a$9.DEFAULT_OPACITY,l=a$9._color;e$z.copyVector3(p,l),l[3]=h,this.setVector4("u_color",l);}if(this._line_type==u$3.LineType.PATH){var T=o.lower_length;this.setFloat("u_lower_length",T);var m=o.upper_length;this.setFloat("u_upper_length",m);}}static _getPreamble(e,t){const r=[];return e==u$3.LineType.PATH&&r.push("#define PATH"),t.ridMaterial&&r.push("#define RID"),r.join("\n")+"\n\n"}}a$9.DEFAULT_WIDTH=1,a$9.DEFAULT_COLOR=e$z.createVector3f([1,1,1]),a$9.DEFAULT_OPACITY=1,a$9.DEFAULT_LOWER_LENGTH=0,a$9.DEFAULT_UPPER_LENGTH=0,a$9._sparam=e$z.createVector3f(),a$9._thickness=e$z.createVector2f(),a$9._color=e$z.createVector4f();

class r$9{constructor(){this._is_compiled=!1,this._point_array=new Float64Array(0),this._num_points=0,this._node_array=new Uint32Array(0),this._next_node=0;}addPoint(t){this._checkNotCompiled(),this._ensurePointArrayCapacity(2);var r=2*this._num_points;this._point_array[r]=t.longitude,this._point_array[r+1]=t.latitude,this._num_points+=1;}addPoints(t,r,i,e){this._checkNotCompiled(),this._ensurePointArrayCapacity(2*e);for(var a=r,o=2*this._num_points,_=this._point_array,n=0;n<e;++n)_[o]=t[a],_[o+1]=t[a+1],a+=i,o+=2;this._num_points+=e;}compile(){this._is_compiled||(this._buildCollisionQuadTree(),this._node_array.length>this._next_node&&(this._node_array=new Uint32Array(this._node_array.slice(0,this._next_node))),this._point_array=null,this._is_compiled=!0);}intersectsWith(t){if(0==this._node_array.length)return !1;for(var r=t.getFlatAreaList(),i=0;i<r.length;++i)if(this._intersectsWith(r[i]))return !0;return !1}_intersectsWith(t){for(var r=0,i=this._node_array,o=0;o<t.length;++o){if((r=i[r+t[o]])==a$8)return !0;if(r==e$a)return !1}return !0}_checkNotCompiled(){if(this._is_compiled)throw new Error("EitityRegion is already compiled.")}_ensurePointArrayCapacity(t){var r=2*this._num_points,i=r+t,e=this._point_array.length;if(i>e){var a=Math.max(i,Math.floor(1.5*e)),o=new Float64Array(a);o.set(this._point_array.slice(0,r)),this._point_array=o;}}_buildCollisionQuadTree(){for(var r=2*Math.PI,i=this._point_array,e=2*this._num_points,a=0;a<e;){var o=i[a++],_=i[a++],n=o+180*Math.floor((90-_)/360+Math.floor((90+_)/360)),s=n-360-360*Math.floor((n-180)/360),h=90-Math.abs(90-_+360*Math.floor((90+_)/360)),d=s*e$z.DEGREE/r+.5,l=.5-e$z.invGudermannian(h*e$z.DEGREE)/r;this._addCollisionQuadTreeNode(d,l);}this._next_node>0&&(this._setFullNodeRecur(0),this._reduceNodeRecur(0));}_addCollisionQuadTreeNode(r,e){if(!(e<0||e>1))for(var a=1<<i$8,o=e$z.clamp(Math.floor(r*a),0,a-1),_=Math.min(Math.floor(e*a),a-1),n=this._findRootNode(),s=a>>1;0!=s;s>>=1){var h=0==(o&s)?0:1,d=0==(_&s)?0:2;n=this._findChildNode(n,h+d);}}_findRootNode(){if(0==this._next_node){this._ensureNodeArrayCapacity();for(var t=0;t<4;++t)this._node_array[t]=e$a;this._next_node=4;}return 0}_findChildNode(t,r){var i=this._node_array[t+r];if(0==i){this._ensureNodeArrayCapacity(),i=this._next_node;for(var a=0;a<4;++a)this._node_array[i+a]=e$a;this._next_node+=4,this._node_array[t+r]=i;}return i}_setFullNodeRecur(t){for(var r=this._node_array,i=!0,o=0;o<4;++o){var _=r[t+o];_!=e$a&&(this._setFullNodeRecur(_),i=!1);}if(i)for(o=0;o<4;++o)r[t+o]=a$8;}_reduceNodeRecur(t){for(var r=this._node_array,i=0,o=0;o<4;++o){var _=r[t+o];_==a$8?++i:_!=e$a&&this._reduceNodeRecur(_)&&(r[t+o]=a$8,++i);}return 4==i}_ensureNodeArrayCapacity(){var t=this._next_node,r=t+4,i=this._node_array.length;if(r>i){var e=Math.max(r,Math.floor(1.5*i)),a=new Uint32Array(e);a.set(this._node_array.slice(0,t)),this._node_array=a;}}}var i$8=20,e$a=0,a$8=4294967295;

class e$9{constructor(){this._tree_root=null;}getAreaStatus(e){let r=this._get_area_node(e);return r===s$m.AreaStatus.EMPTY||r===s$m.AreaStatus.FULL?r:s$m.AreaStatus.PARTIAL}getAreaContent(e){let r=this._get_area_node(e);return r===s$m.AreaStatus.EMPTY||r===s$m.AreaStatus.FULL?r:r.content}getInitialContent(){return null}createAreaContent(e,r,a,n){return s$m.AreaStatus.EMPTY}notifyForUpdateContent(){this._tree_root=null;}_create_area_node(e,a,n,o){let l=this.createAreaContent(e,a-n,n,o);return l===s$m.AreaStatus.EMPTY||l===s$m.AreaStatus.FULL?l:new r$8(l)}_get_area_node(e){let r=2,a=-1,n=1;if(null===this._tree_root){let t=this.getInitialContent();this._tree_root=this._create_area_node(a,n,r,t);}let o=this._tree_root,l=Math.round(Math.pow(2,e.z)),s=e.x,u=e.y;for(;1!=l&&o!==s$m.AreaStatus.EMPTY&&o!==s$m.AreaStatus.FULL;){l/=2;let t=s>=l?1:0,e=u>=l?1:0;r/=2,a+=t*r,n-=e*r;let _=t+2*e,i=o.children[_];null===i&&(i=this._create_area_node(a,n,r,o.content),o.children[_]=i),s-=t*l,u-=e*l,o=i;}return o}}class r$8{constructor(t){this.children=[null,null,null,null],this.content=t;}}

class c$3 extends s$m{constructor(t,e,i={}){super(t,i),this._line_type=e,this.altitude_mode===E$4.CLAMP?(this._producer=new c$3.FlakePrimitiveProducer(this),this._is_flake_mode=!0):(this._producer=new c$3.PrimitiveProducer(this),this._is_flake_mode=!1);}getPrimitiveProducer(){return this._is_flake_mode?void 0:this._producer}getFlakePrimitiveProducer(){return this._is_flake_mode?this._producer:void 0}onChangeAltitudeMode(t){this.altitude_mode===E$4.CLAMP?(this._producer=new c$3.FlakePrimitiveProducer(this),this._is_flake_mode=!0):(this._producer=new c$3.PrimitiveProducer(this),this._is_flake_mode=!1);}getLineType(){return this._line_type}getLineWidth(){return this._width}setLineWidth(t){this._width!==t&&(this._width=t,this._producer.onChangeProperty());}getColor(){return this._color}setColor(t){this._color[0]===t[0]&&this._color[1]===t[1]&&this._color[2]===t[2]||(e$z.copyVector3(t,this._color),this._producer.onChangeProperty());}setOpacity(t){this._opacity!==t&&(this._opacity=t,this._producer.onChangeProperty());}getPointArray(){return this._point_array}getBounds(){const t=new _$a;return t.addPointsAsArray(this._point_array),t}_getLineMaterial(t){const e=this.scene,i="_AbstractLineEntity_material"+(this._line_type===c$3.LineType.PATH?"_path":"_markerline")+("RID"===t?"_pick":"");let s=e[i];if(!s){const n={ridMaterial:"RID"===t};s=e[i]=new a$9(e.glenv,this._line_type,n);}return s}}!function(r){class o extends s$m.PrimitiveProducer{constructor(t){super(t),this._transform=e$z.setIdentity(e$z.createMatrix()),this._pivot=e$z.createVector3(),this._bbox=[e$z.createVector3(),e$z.createVector3()],this._properties={width:1,color:e$z.createVector3f(),opacity:1},this.getEntity().getLineType()==d.PATH&&(this._properties.lower_length=0,this._properties.upper_length=0);const i=t._getLineMaterial("SCENE"),r=new s$h(t.scene.glenv,null,i,this._transform);r.pivot=this._pivot,r.bbox=this._bbox,r.properties=this._properties,this._primitive=r;const n=t._getLineMaterial("RID"),o=new s$h(t.scene.glenv,null,n,this._transform);o.pivot=this._pivot,o.bbox=this._bbox,o.properties=this._properties,this._pickPrimitive=o,this._primitives=[r],this._pickPrimitives=[o],this._geom_dirty=!0;}getEntity(){return super.getEntity()}createRegions(){let t=new r$9;return t.addPoints(this.getEntity().getPointArray(),0,3,this._numPoints()),[t]}onChangeElevation(t){this._geom_dirty=!0;}getPrimitives(t){return this.getEntity()._num_floats<6?[]:(this._updatePrimitive(),"SCENE"===t.getRenderTarget()?this._primitives:this._pickPrimitives)}onChangePoints(){this.needToCreateRegions(),this._geom_dirty=!0;}onChangeProperty(){}_updatePrimitive(){if(this._updateProperties(),!this._geom_dirty)return;const t=this.getEntity();var e=this._numPoints(),s=r$z.toGocsArray(this._getFlatGeoPoints_with_Absolute(),e,new Float64Array(t._num_floats));this._updateTransformPivotBBox(s,e);let o=t.getLineType()===r.LineType.PATH,a=o?t._length_array:void 0;var h={vtype:[{name:"a_position",size:3},{name:"a_direction",size:3},{name:"a_where",size:2}],vertices:this._createVertices(s,e,a),indices:this._createIndices()};o&&h.vtype.push({name:"a_length",size:1});var _=new r$h(t.scene.glenv,h),l=this._primitive;l.mesh&&l.mesh.dispose(),l.mesh=_;var p=this._pickPrimitive;p.mesh&&p.mesh.dispose(),p.mesh=_,this._geom_dirty=!1;}_updateProperties(){let t=this.getEntity(),e=this._properties;e.width=t.getLineWidth(),e$z.copyVector3(t.getColor(),e.color),e.opacity=t._opacity,t.getLineType()===r.LineType.PATH&&(e.lower_length=t._lower_length,e.upper_length=t._upper_length);}_getFlatGeoPoints_with_Absolute(){let t=this.getEntity(),e=t.getPointArray(),i=t._num_floats;var r=null;if(t.altitude_mode===E$4.RELATIVE){var s=this._numPoints();r=new Float64Array(i),t.scene.viewer.getExistingElevations(s,e,0,3,r,2,3);for(var n=0;n<i;n+=3)r[n]=e[n],r[n+1]=e[n+1],r[n+2]+=e[n+2];}else r=e;return r}_updateTransformPivotBBox(t,e){var i=t[0],r=t[1],s=t[2],n=this._transform;n[12]=i,n[13]=r,n[14]=s;for(var o=0,a=0,h=0,_=Number.MAX_VALUE,l=Number.MAX_VALUE,p=Number.MAX_VALUE,c=-Number.MAX_VALUE,u=-Number.MAX_VALUE,m=-Number.MAX_VALUE,d=0;d<e;++d){var g=3*d,y=t[g]-i,P=t[g+1]-r,f=t[g+2]-s;o+=y,a+=P,h+=f,y<_&&(_=y),P<l&&(l=P),f<p&&(p=f),y>c&&(c=y),P>u&&(u=P),f>m&&(m=f);}var v=this._pivot;v[0]=o/e,v[1]=a/e,v[2]=h/e;var M=this._bbox,A=M[0],E=M[1];A[0]=_,A[1]=l,A[2]=p,E[0]=c,E[1]=u,E[2]=m;}_createVertices(t,e,i){for(var r=void 0!==i,s=t[0],n=t[1],o=t[2],a=e-1,h=new Float32Array((r?9:8)*(4*a)),_=0;_<a;++_)for(var l=3*_,p=t[l]-s,c=t[l+1]-n,u=t[l+2]-o,m=t[l+3]-s,d=t[l+4]-n,g=t[l+5]-o,y=t[l+3]-t[l],P=t[l+4]-t[l+1],f=t[l+5]-t[l+2],v=(r?36:32)*_,M=0;M<4;++M){var A=M<2,E=v+M*(r?9:8);switch(h[E]=A?p:m,h[E+1]=A?c:d,h[E+2]=A?u:g,h[E+3]=y,h[E+4]=P,h[E+5]=f,M){case 0:h[E+6]=-1,h[E+7]=1;break;case 1:h[E+6]=-1,h[E+7]=-1;break;case 2:h[E+6]=1,h[E+7]=1;break;case 3:h[E+6]=1,h[E+7]=-1;}r&&(h[E+8]=i[A?_:_+1]);}return h}_createIndices(){for(var t=this._numPoints()-1,e=new Uint32Array(6*t),i=0;i<t;++i){var r=6*i,s=4*i;e[r]=s,e[r+1]=s+1,e[r+2]=s+2,e[r+3]=s+2,e[r+4]=s+1,e[r+5]=s+3;}return e}_numPoints(){const t=this.getEntity()._num_floats;return Math.floor(t/3)}}r.PrimitiveProducer=o;class c extends s$m.FlakePrimitiveProducer{constructor(t){super(t),this._material_map=new Map,l$5.ListOfRenderTarget.forEach((e=>{this._material_map.set(e,t._getLineMaterial(e));})),this._properties=void 0,this._area_manager=new m(t);}getEntity(){return super.getEntity()}getAreaStatus(t){return this._area_manager.getAreaStatus(t)}createMesh(t,e,r){let s=this._divideXY(t,e);if(0==s.length)return null;let n=this.getEntity().getLineType()===d.PATH,o={vtype:[{name:"a_position",size:3},{name:"a_direction",size:3},{name:"a_where",size:2}],vertices:this._createVertices(t,r,s,n),indices:this._createIndices(s.length)};return n&&o.vtype.push({name:"a_length",size:1}),new r$h(this.getEntity().scene.glenv,o)}getMaterialAndProperties(t){if(!this._properties){let t=this.getEntity();this._properties={width:t._width,color:e$z.createVector3f(t._color),opacity:t._opacity},t.getLineType()===d.PATH&&(this._properties.lower_length=t._lower_length,this._properties.upper_length=t._upper_length);}return {material:this._material_map.get(t.getRenderTarget()),properties:this._properties}}onChangePoints(){this._area_manager.notifyForUpdateContent(),this.notifyForUpdate();}onChangeProperty(){this._properties=void 0;}_divideXOnly(t,e,i){let r=Math.PI*(t.x*e-1),s=Math.PI*((t.x+1)*e-1),n=1<<i,o=(s-r)/n,a=[];for(let[e,i,h,_,l,p]of this._area_manager.getAreaContent(t)){let[t,c,u,m,d,g]=e<=_?[e,i,h,_,l,p]:[_,l,p,e,i,h];if(m<r||t>=s)continue;if(t==m){a.push([t,c,u,m,d,g]);continue}let y=t,P=c,f=u;if(t<r){let e=(r-t)/(m-t),i=1-e;y=r,P=i*c+e*d,f=i*u+e*g;}let v=m,M=d,A=g;if(m>s){let e=(s-t)/(m-t),i=1-e;v=s,M=i*c+e*d,A=i*u+e*g;}let E=Math.max(Math.ceil((t-r)/o),1),w=Math.min(Math.floor((m-r)/o),n-1),L=y,I=P,b=f;for(let e=E;e<=w;++e){let i=r+o*e,s=(i-t)/(m-t),n=1-s,h=n*c+s*d,_=n*u+s*g;L==i&&I==h||a.push([L,I,b,i,h,_]),L=i,I=h,b=_;}L==v&&I==M||a.push([L,I,b,v,M,A]);}return a}_divideXY(t,e){let i=2/Math.round(Math.pow(2,t.z)),r=Math.PI*(1-(t.y+1)*i),s=Math.PI*(1-t.y*i),n=1<<e[1],o=(s-r)/n,a=[];for(let[h,_,l,p,c,u]of this._divideXOnly(t,i,e[0])){let[t,e,i,m,d,g]=_<=c?[h,_,l,p,c,u]:[p,c,u,h,_,l];if(d<r||e>=s)continue;if(e==d){a.push([t,e,i,m,d,g]);continue}let y=t,P=e,f=i;if(e<r){let s=(r-e)/(d-e),n=1-s;y=n*t+s*m,P=r,f=n*i+s*g;}let v=m,M=d,A=g;if(d>s){let r=(s-e)/(d-e),n=1-r;v=n*t+r*m,M=s,A=n*i+r*g;}let E=Math.max(Math.ceil((e-r)/o),1),w=Math.min(Math.floor((d-r)/o),n-1),L=y,I=P,b=f;for(let s=E;s<=w;++s){let n=r+o*s,h=(n-e)/(d-e),_=1-h,l=_*t+h*m,p=_*i+h*g;L==l&&I==n||a.push([L,I,b,l,n,p]),L=l,I=n,b=p;}L==v&&I==M||a.push([L,I,b,v,M,A]);}return a}_createVertices(t,e,i,r=!1){let n=e.newLinearSampler(),[o,a,h]=a$e.getCenter(t,e$z.createVector3()),l=i.length,p=new Float32Array((r?9:8)*(4*l));for(let t=0;t<l;++t){let[e,s,_,l,g,y]=i[t],[P,f,v]=u(e,s,n),[M,A,E]=u(l,g,n),w=P-o,L=f-a,I=v-h,b=M-o,T=A-a,k=E-h,C=M-P,x=A-f,R=E-v,V=(r?36:32)*t;for(var c=0;c<4;++c){var m=c<2,d=V+c*(r?9:8);switch(p[d]=m?w:b,p[d+1]=m?L:T,p[d+2]=m?I:k,p[d+3]=C,p[d+4]=x,p[d+5]=R,c){case 0:p[d+6]=-1,p[d+7]=1;break;case 1:p[d+6]=-1,p[d+7]=-1;break;case 2:p[d+6]=1,p[d+7]=1;break;case 3:p[d+6]=1,p[d+7]=-1;}r&&(p[d+8]=m?_:y);}}return p}_createIndices(t){let e=new Uint32Array(6*t);for(let i=0;i<t;++i){let t=6*i,r=4*i;e[t]=r,e[t+1]=r+1,e[t+2]=r+2,e[t+3]=r+2,e[t+4]=r+1,e[t+5]=r+3;}return e}}function u(t,e,i){let r=t,n=e$z.gudermannian(e),o=e$z.EARTH_RADIUS+i.sample(t,e),a=Math.cos(n);return [o*a*Math.cos(r),o*a*Math.sin(r),o*Math.sin(n)]}r.FlakePrimitiveProducer=c;class m extends e$9{constructor(t){super(),this._entity=t;}getInitialContent(){const t=e$z.DEGREE,e=Math.PI/2,i=2*Math.PI;let r=[],n=this._entity.getPointArray(),o=this._entity._num_floats;if(o<6)return r;let a,h,_,l=this._entity._line_type===d.PATH,p=l?this._entity._length_array:null,c=n[0]*t,u=n[1]*t,m=l?p[0]:0;for(let d=3;d<o;d+=3,c=a,u=h,m=_){if(a=n[d]*t,h=n[d+1]*t,_=l?p[d/3]:0,u<=-e||u>=e||h<=-e||h>=e)continue;let o=c,g=e$z.invGudermannian(u),y=m,P=a,f=e$z.invGudermannian(h),v=_,[M,A,E,w,L,I]=o<P?[o,g,y,P,f,v]:[P,f,v,o,g,y];if(M<-Math.PI||M>=Math.PI){let t=w-M;M-=i*(Math.floor((M-Math.PI)/i)+1),(M<-Math.PI||M>=Math.PI)&&(M=-Math.PI),w=M+t;}M==w&&A==L||(r.push([M,A,E,w,L,I]),w>Math.PI&&r.push([M-i,A,E,w-i,L,I]));}return r}createAreaContent(e,i,r,s){const n=Math.PI*e,o=Math.PI*(e+r),a=Math.PI*i,h=Math.PI*(i+r);let _=[];for(let t of s){let[e,i,,r,s]=t;this._intersect(n,o,a,h,e,i,r,s)&&_.push(t);}return _.length>0?_:s$m.AreaStatus.EMPTY}_intersect(t,e,i,r,s,n,o,a){return Math.abs(s-o)<Math.abs(n-a)?this._nhorz_intersect(t,e,i,r,s,n,o,a):this._nhorz_intersect(i,r,t,e,n,s,a,o)}_nhorz_intersect(t,e,i,r,s,n,o,a){let[h,_]=n<a?[n,a]:[a,n];if(h>=r||_<i)return !1;let l=s+(o-s)*((i>=h?i:h)-n)/(a-n),p=s+(o-s)*((r<=_?r:_)-n)/(a-n),[c,u]=l<p?[l,p]:[p,l];return c<e&&u>=t}}let d;r.LineAreaManager=m,function(t){t[t.MARKERLINE=0]="MARKERLINE",t[t.PATH=1]="PATH";}(d=r.LineType||(r.LineType={}));}(c$3||(c$3={}));var u$3=c$3;

class s$7 extends u$3{constructor(o,s={}){super(o,u$3.LineType.MARKERLINE,s),this._point_array=new Float64Array(0),this._num_floats=0,this._width=1,this._color=e$z.createVector3([1,1,1]),this._opacity=1,this._setupAnimationBindingBlock(),s&&s.json&&this._setupByJson(s.json);}_setupAnimationBindingBlock(){const t=this.animation,i=s$u.find("number"),s=s$u.find("vector3");t.addEntry("width",[i],null,(t=>{this.setLineWidth(t);})),t.addEntry("color",[s],null,(t=>{this.setColor(t);})),t.addEntry("opacity",[i],null,(t=>{this.setOpacity(t);}));}addPoints(t){var i=t.length;if(0!=i){var o=this._num_floats+i,s=this._point_array.length;if(o>s){for(var n=new Float64Array(Math.max(o,2*s)),a=this._point_array,r=this._num_floats,_=0;_<r;++_)n[_]=a[_];this._point_array=n;}for(var e=this._point_array,h=this._num_floats,l=0;l<i;++l)e[h+l]=t[l];this._num_floats=o,this._producer.onChangePoints();}}removeAllPoints(){this._num_floats=0,this._producer.onChangePoints();}removePointAt(t){let i=3*t;if(i>=this._num_floats)console.log("out of index",i,this._num_floats);else {if(i<0&&(i=this._num_floats+i),this._num_floats-=3,i!==this._num_floats-3)for(let t=i;t<this._num_floats-3;++t)this._point_array[t]=this._point_array[t+3];this._producer.onChangePoints();}}getPointCount(){return this._num_floats/3}getPointAt(t){let i=3*t;if(!(i>=this._num_floats))return i<0&&(i=this._num_floats+i),[this._point_array[i++],this._point_array[i++],this._point_array[i++]];console.log("out of index",i,this._num_floats);}replacePointAt(t,i){let o=3*t;if(o>=this._num_floats)console.log("out of index",o,this._num_floats);else {o<0&&(o=this._num_floats+o);for(let t=0;t<3;++t)this._point_array[o+t]=i[t];this._producer.onChangePoints();}}_setupByJson(t){this.addPoints(t.points),void 0!==t.line_width&&this.setLineWidth(t.line_width),void 0!==t.color&&this.setColor(t.color),void 0!==t.opacity&&this.setOpacity(t.opacity);}}

class n$p extends u$3{constructor(i,n={}){super(i,u$3.LineType.PATH,n),this._point_array=new Float64Array(0),this._num_floats=0,this._length_array=new Float64Array(0),this._width=1,this._color=e$z.createVector3([1,1,1]),this._opacity=1,this._lower_length=0,this._upper_length=0,this._setupAnimationBindingBlock(),n&&n.json&&this._setupByJson(n.json);}_setupAnimationBindingBlock(){const t=this.animation,e=s$u.find("number"),n=s$u.find("vector3");t.addEntry("width",[e],null,(t=>{this.setLineWidth(t);})),t.addEntry("color",[n],null,(t=>{this.setColor(t);})),t.addEntry("opacity",[e],null,(t=>{this.setOpacity(t);})),t.addEntry("lower_length",[e],null,(t=>{this.setLowerLength(t);})),t.addEntry("upper_length",[e],null,(t=>{this.setUpperLength(t);}));}setLowerLength(t){this._lower_length!==t&&(this._lower_length=t,this._producer.onChangeProperty());}setUpperLength(t){this._upper_length!==t&&(this._upper_length=t,this._producer.onChangeProperty());}addPoints(t,e){let i=t.length,n=e.length;if(0==i||0==n)return;let o=this._num_floats/3,r=this._num_floats+i,s=this._point_array.length;if(r>s){let t=new Float64Array(Math.max(r,2*s)),e=this._point_array,i=this._num_floats;for(let n=0;n<i;++n)t[n]=e[n];this._point_array=t;}let h=o+n,l=this._length_array.length;if(h>l){let t=new Float64Array(Math.max(h,2*l)),e=this._length_array,i=o;for(let n=0;n<i;++n)t[n]=e[n];this._length_array=t;}let a=this._point_array,_=this._num_floats;for(let e=0;e<t.length;++e)a[_+e]=t[e];let p=this._length_array,g=o;for(let t=0;t<e.length;++t)p[g+t]=e[t];this._num_floats=r,this._producer.onChangePoints();}_setupByJson(t){this.addPoints(t.points.positions,t.points.lengths),void 0!==t.line_width&&this.setLineWidth(t.line_width),void 0!==t.color&&this.setColor(t.color),void 0!==t.opacity&&this.setOpacity(t.opacity),void 0!==t.lower_length&&this.setLowerLength(t.lower_length),void 0!==t.upper_length&&this.setUpperLength(t.upper_length);}}

class s$6 extends s$m{constructor(t,e){super(t,e),this._entries=[];}getBounds(){const t=new _$a;for(let e of this._entries)t.addPoint(e.position);return t}get entries(){return this._entries}}!function(t){t.Entry=class{};}(s$6||(s$6={}));var r$7=s$6;

var n$o="/**\n * テキスト (頂点シェーダ)\n */\n\nattribute vec4 a_position;    // 頂点位置 (モデル座標系)\nattribute vec2 a_offset;      // 頂点変位 (スクリーン座標系)\nattribute vec2 a_texcoord;    // テクスチャ座標\n\nuniform mat4 u_obj_to_clip;   // モデル座標系からクリップ座標系への変換\nuniform vec2 u_sparam;        // 画面パラメータ: {2/w, 2/h}\n\nvarying vec2 v_texcoord;      // テキストのテクスチャ座標\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    gl_Position.xy += a_offset * u_sparam * gl_Position.w;\n    v_texcoord = a_texcoord;\n}";

var n$n="/**\n * テキスト (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\nvarying vec2 v_texcoord;        // テクスチャ座標\nuniform sampler2D u_image;      // 画像\n\nvoid\nmain()\n{\n    gl_FragColor = texture2D( u_image, v_texcoord );\n}";

class o$9 extends o$b{constructor(r,e={}){super(r,n$o,e.ridMaterial?n$T:n$n),this.bindProgram(),this.setInteger("u_image",o$9.TEXUNIT_IMAGE);}isTranslucent(r,e){return !e.properties.enable_bg}setParameters(r,e){super.setParameters(r,e);var t=e.properties;this.setObjToClip(r,e);var a=o$9._sparam;if(a[0]=2/r._width,a[1]=2/r._height,this.setVector2("u_sparam",a),r.getRenderTarget()===l$5.RenderTarget.SCENE){var s=t.image;this.bindTexture2D(o$9.TEXUNIT_IMAGE,s.handle);}}}o$9.TEXUNIT_IMAGE=0,o$9._sparam=e$z.createVector2f();

var o$8="/**\n * テキスト (頂点シェーダ)\n */\n\nattribute vec4 a_position;    // 頂点位置 (モデル座標系)\nattribute vec2 a_offset;      // 頂点変位 (スクリーン座標系)\nattribute vec2 a_texcoord;    // テクスチャ座標\nattribute vec4 a_color;       // テキストの色と不透明度\n\nuniform mat4 u_obj_to_clip;   // モデル座標系からクリップ座標系への変換\nuniform vec2 u_sparam;        // 画面パラメータ: {2/w, 2/h}\n\nvarying vec2 v_texcoord;      // テキストのテクスチャ座標\nvarying vec4 v_color;         // テキストの色と不透明度\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    gl_Position.xy += a_offset * u_sparam * gl_Position.w;\n    v_texcoord = a_texcoord;\n    v_color    = a_color;\n}\n";

var n$m="/**\n * テキスト (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\nvarying vec2 v_texcoord;     // テキストのテクスチャ座標\nvarying vec4 v_color;        // テキストの色と不透明度\n\nuniform sampler2D u_image;   // テキスト画像\n\nvoid\nmain()\n{\n    float level = texture2D( u_image, v_texcoord ).w;  // 輝度\n    float alpha = v_color.w * level;\n    gl_FragColor = vec4( v_color.xyz * alpha, alpha );\n}\n";

class m$5 extends o$b{constructor(r,e={}){super(r,o$8,e.ridMaterial?n$T:n$m),this.bindProgram(),this.setInteger("u_image",m$5.TEXUNIT_IMAGE);}isTranslucent(r,e){return !0}setParameters(r,e){super.setParameters(r,e);var t=e.properties;this.setObjToClip(r,e);var s=m$5._sparam;if(s[0]=2/r._width,s[1]=2/r._height,this.setVector2("u_sparam",s),r.getRenderTarget()===l$5.RenderTarget.SCENE){var a=t.image;this.bindTexture2D(m$5.TEXUNIT_IMAGE,a.handle);}}}m$5.TEXUNIT_IMAGE=0,m$5._sparam=e$z.createVector2f();

class m$4 extends r$7{constructor(t,e={}){super(t,e),this._text_parent_props={font_style:"normal",font_weight:"normal",font_size:m$4.DEFAULT_FONT_SIZE,font_family:m$4.DEFAULT_FONT_FAMILY,color:m$4.DEFAULT_COLOR,stroke_color:m$4.DEFAULT_STROKE_COLOR,stroke_width:m$4.DEFAULT_STROKE_WIDTH,bg_color:m$4.DEFAULT_BG_COLOR,enable_stroke:!1,enable_bg:!1};this._animation.addDescendantUnbinder((()=>{this._unbindDescendantAnimations();})),this._setupAnimationBindingBlock(),e&&e.json&&this._setupByJson(e.json);}getPrimitiveProducer(){return this._primitive_producer}onChangeAltitudeMode(t){this._primitive_producer&&this._primitive_producer.onChangeAltitudeMode();}_unbindDescendantAnimations(){for(let t of this._entries)t.animation.unbindAllRecursively();}_setupAnimationBindingBlock(){const t=this._animation,e=s$u.find("number"),i=s$u.find("string"),r=s$u.find("vector3");t.addEntry("font_style",[i],null,(t=>{this.setFontStyle(t);})),t.addEntry("font_weight",[i],null,(t=>{this.setFontWeight(t);})),t.addEntry("font_size",[e],null,(t=>{this.setFontSize(t);})),t.addEntry("color",[r],null,(t=>{this.setColor(t);})),t.addEntry("stroke_color",[r],null,(t=>{this.setStrokeColor(t);})),t.addEntry("stroke_width",[e],null,(t=>{this.setStrokeLineWidth(t);}));}setFontStyle(t){this._setValueProperty("font_style",t);}setFontWeight(t){this._setValueProperty("font_weight",t);}setFontSize(t){this._setValueProperty("font_size",t);}setFontFamily(t){this._setValueProperty("font_family",t);}setColor(t){this._setColorProperty("color",t);}setStrokeColor(t){this._setColorProperty("stroke_color",t);}setStrokeLineWidth(t){this._setValueProperty("stroke_width",t);}setEnableStroke(t){this._setValueProperty("enable_stroke",t),this._primitive_producer=new m$4.PrimitiveProducer(this);}setBackgroundColor(t){this._setColorProperty("bg_color",t);}setEnableBackground(t){this._setValueProperty("enable_bg",t),this._primitive_producer=new m$4.PrimitiveProducer(this);}addText(t,e,i){var r=new m$4.TextEntry(this,t,e,i);return this._entries.push(r),this._primitive_producer=new m$4.PrimitiveProducer(this),this._primitive_producer.onAddTextEntry(),r}_getTextMaterial(t){var e=this.scene;if("SCENE"===t)return e._TextEntity_text_material||(e._TextEntity_text_material=new o$9(e.glenv)),e._TextEntity_text_material;if("RID"===t)return e._TextEntity_text_material_pick||(e._TextEntity_text_material_pick=new o$9(e.glenv,{ridMaterial:!0})),e._TextEntity_text_material_pick;throw new Error("unknown render target: "+t)}_getSimpleTextMaterial(t){var e=this.scene;if("SCENE"===t)return e._SimpleTextEntity_text_material||(e._SimpleTextEntity_text_material=new m$5(e.glenv)),e._SimpleTextEntity_text_material;if("RID"===t)return e._SimpleTextEntity_text_material_pick||(e._SimpleTextEntity_text_material_pick=new m$5(e.glenv,{ridMaterial:!0})),e._SimpleTextEntity_text_material_pick;throw new Error("unknown render target: "+t)}_setValueProperty(t,e){var i=this._text_parent_props;i[t]!=e&&(i[t]=e,this._primitive_producer&&this._primitive_producer.onChangeParentProperty());}_setColorProperty(t,e){var i=this._text_parent_props[t];i[0]===e[0]&&i[1]===e[1]&&i[2]===e[2]||(r$o.premultiply(e,i),this._primitive_producer&&this._primitive_producer.onChangeParentProperty());}_setupByJson(t){var e=new r$z;for(let i of t.entries)e.setFromArray(i.position),this.addText(i.text,e,i);void 0!==t.font_style&&this.setFontStyle(t.font_style),void 0!==t.font_weight&&this.setFontWeight(t.font_weight),void 0!==t.font_size&&this.setFontSize(t.font_size),void 0!==t.font_family&&this.setFontFamily(t.font_family),void 0!==t.color&&this.setColor(t.color),void 0!==t.stroke_color&&this.setStrokeColor(t.stroke_color),void 0!==t.stroke_width&&this.setStrokeLineWidth(t.stroke_width),void 0!==t.enable_stroke&&this.setEnableStroke(t.enable_stroke),void 0!==t.bg_color&&this.setBackgroundColor(t.bg_color),void 0!==t.enable_bg&&this.setEnableBackground(t.enable_bg);}_enableStroke(){return this._text_parent_props.enable_stroke}getEntry(t){return this._entries.find((e=>e.id===t))}}!function(s){s.DEFAULT_FONT_SIZE=16,s.DEFAULT_FONT_FAMILY="sans-serif",s.DEFAULT_COLOR=r$o.createColor([1,1,1]),s.DEFAULT_STROKE_COLOR=r$o.createColor([0,0,0]),s.DEFAULT_STROKE_WIDTH=.48,s.DEFAULT_BG_COLOR=r$o.createColor([.3,.3,.3]),s.DEFAULT_TEXT_UPPER=1.1,s.DEFAULT_TEXT_LOWER=.38,s.SAFETY_PIXEL_MARGIN=1,s.MAX_IMAGE_WIDTH=4096;class o extends s$m.PrimitiveProducer{constructor(t){super(t),this._glenv=t.scene.glenv,this._dirty=!0,this._transform=e$z.setIdentity(e$z.createMatrix()),this._properties={enable_bg:!1,image:void 0};let i=null,r=null;this._isSimpleText()?(i=t._getSimpleTextMaterial("SCENE"),r=t._getSimpleTextMaterial("RID")):(i=t._getTextMaterial("SCENE"),r=t._getTextMaterial("RID"));var s=new s$h(this._glenv,null,i,this._transform);s.properties=this._properties,this._primitive=s;var o=new s$h(this._glenv,null,r,this._transform);o.properties=this._properties,this._pickPrimitive=o,this._primitives=[],this._pickPrimitives=[];}getEntity(){return super.getEntity()}createRegions(){const t=new r$9;for(let{position:e}of this.entity._entries)t.addPoint(e);return [t]}onChangeElevation(t){this._dirty=!0;}getPrimitives(t){return this._updatePrimitive(),"SCENE"===t.getRenderTarget()?this._primitives:this._pickPrimitives}onChangeParentProperty(){this._dirty=!0;}onChangeChildProperty(){this._dirty=!0;}onChangeAltitudeMode(){this._dirty=!0;}onAddTextEntry(){this.needToCreateRegions(),this._dirty=!0;}get transform(){return this._transform}_updatePrimitive(){if(!this._dirty)return;this._updateProperties();if(0==this.getEntity()._entries.length)return this._primitives=[],this._pickPrimitives=[],void(this._dirty=!1);var t=this._createFlatGocsArray();this._updateTransform(t);var e=new g(this,t);if(!e.isValid())return this._primitives=[],this._dirty=!1,this._primitives;var r=this._properties;r.image&&r.image.dispose(),r.image=e.texture;var s={vtype:this._isSimpleText()?[{name:"a_position",size:3},{name:"a_offset",size:2},{name:"a_texcoord",size:2},{name:"a_color",size:4}]:[{name:"a_position",size:3},{name:"a_offset",size:2},{name:"a_texcoord",size:2}],vertices:e.vertices,indices:e.indices},o=new r$h(this._glenv,s),n=this._primitive;n.mesh&&n.mesh.dispose(),n.mesh=o;var _=this._pickPrimitive;_.mesh&&_.mesh.dispose(),_.mesh=o,this._primitives=[n],this._pickPrimitives=[_],this._dirty=!1;}_updateProperties(){let t=this.getEntity();this._properties.enable_bg=t._text_parent_props.enable_bg;}_updateTransform(t){var e=this.getEntity()._entries.length,i=0,r=0,s=0;for(let o=0;o<e;++o){let e=3*o;i+=t[e],r+=t[e+1],s+=t[e+2];}var o=this._transform;o[12]=i/e,o[13]=r/e,o[14]=s/e;}_createFlatGocsArray(){const t=this.getEntity()._entries.length;return r$z.toGocsArray(this._getFlatGeoPoints_with_Absolute(),t,new Float64Array(3*t))}_getFlatGeoPoints_with_Absolute(){const t=this.getEntity(),e=t._entries,i=e.length,r=new Float64Array(3*i);for(let t=0;t<i;++t){let i=e[t].position;r[3*t]=i.longitude,r[3*t+1]=i.latitude;}switch(t.altitude_mode){case E$4.RELATIVE:case E$4.CLAMP:if(t.scene.viewer.getExistingElevations(i,r,0,3,r,2,3),t.altitude_mode===E$4.RELATIVE)for(let t=0;t<i;++t)r[3*t+2]+=e[t].position.altitude;break;default:for(let t=0;t<i;++t)r[3*t+2]=e[t].position.altitude;}return r}_isSimpleText(){let t=this.getEntity(),e=!0;(t._text_parent_props.enable_bg||t._text_parent_props.enable_stroke)&&(e=!1);let i=0;const r=t._entries;for(;e&&r.length>i;){e=!r[i].enable_stroke,i++;}return e}}s.PrimitiveProducer=o;class m extends r$7.Entry{constructor(t,e,i,r){super(),this._owner=t,this._text=e,this._position=i.clone(),this._animation=new i$u,this._setupAnimationBindingBlock(),this._props=Object.assign({},r),this._copyColorProperty("color"),this._copyColorProperty("stroke_color"),this._copyColorProperty("bg_color");}get animation(){return this._animation}get text(){return this._text}get position(){return this._position}get id(){return this._props.hasOwnProperty("id")?this._props.id:""}get size(){var t=this._props,e=this._owner._text_parent_props;return t.font_size||e.font_size}get color(){var t=this._props,e=this._owner._text_parent_props;return t.color||e.color}get font(){var t=this._props,e=this._owner._text_parent_props,i=t.font_style||e.font_style,r=t.font_weight||e.font_weight,s=t.font_family||e.font_family;return i+" normal "+r+" "+this.size+"px "+s}get stroke_color(){var t=this._props,e=this._owner._text_parent_props;return t.stroke_color||e.stroke_color}get stroke_width(){var t=this._props,e=this._owner._text_parent_props;return t.stroke_width||e.stroke_width}get enable_stroke(){var t=this._props,e=this._owner._text_parent_props;return t.enable_stroke||e.enable_stroke}get bg_color(){var t=this._props,e=this._owner._text_parent_props;return t.bg_color||e.bg_color}get enable_background(){return this._owner._text_parent_props.enable_bg}_setupAnimationBindingBlock(){const t=this.animation,e=s$u.find("number"),i=s$u.find("string"),r=s$u.find("vector3"),s=new r$z;t.addEntry("position",[r],null,(t=>{s.setFromArray(t),this.setPosition(s);})),t.addEntry("font_style",[i],null,(t=>{this.setFontStyle(t);})),t.addEntry("font_weight",[i],null,(t=>{this.setFontWeight(t);})),t.addEntry("font_size",[e],null,(t=>{this.setFontSize(t);})),t.addEntry("color",[r],null,(t=>{this.setColor(t);})),t.addEntry("stroke_color",[r],null,(t=>{this.setStrokeColor(t);})),t.addEntry("stroke_width",[e],null,(t=>{this.setStrokeLineWidth(t);})),t.addEntry("text",[i],null,(t=>{this.setText(t);}));}setPosition(t){if(this._position.longitude!==t.longitude||this._position.latitude!==t.latitude||this._position.altitude!==t.altitude){this._position.assign(t);const e=this._owner.getPrimitiveProducer();e&&e.onChangeChildProperty();}}setFontStyle(t){this._setValueProperty("font_style",t);}setFontWeight(t){this._setValueProperty("font_weight",t);}setFontSize(t){this._setValueProperty("font_size",t);}setColor(t){this._setColorProperty("color",t);}setStrokeColor(t){this._setColorProperty("stroke_color",t);}setStrokeLineWidth(t){this._setValueProperty("stroke_width",t);}setEnableStroke(t){this._setValueProperty("enable_stroke",t),this._owner._primitive_producer=new o(this._owner);}setText(t){if(this._text!==t){this._text=t;const e=this._owner.getPrimitiveProducer();e&&e.onChangeChildProperty();}}_copyColorProperty(t){var e=this._props;e.hasOwnProperty(t)&&(e[t]=r$o.createColor(e[t]));}_setValueProperty(t,e){var i=this._props;if(i[t]!=e){i[t]=e;const r=this._owner.getPrimitiveProducer();r&&r.onChangeChildProperty();}}_setColorProperty(t,e){var i=this._props[t];if(i){if(i[0]!=e[0]||i[1]!=e[1]||i[2]!=e[2]){r$o.premultiply(e,i);const t=this._owner.getPrimitiveProducer();t&&t.onChangeChildProperty();}}else {this._props[t]=r$o.premultiply(e,r$o.createColor());const i=this._owner.getPrimitiveProducer();i&&i.onChangeChildProperty();}}}s.TextEntry=m;class g{constructor(t,e){this._owner=t,this._items=this._createItemList(),this._is_valid=!0;var i=this._createRowLayouts();if(0==i.length)return this._is_valid=!1,void(this._vertices=[]);var r=this._setupLocation(i);this._isSimpleTextWithAllItems(this._items)?(this._texture=this._createTextureForSimple(r.width,r.height),this._vertices=this._createVerticesForSimple(r.width,r.height,e)):(this._texture=this._createTexture(r.width,r.height),this._vertices=this._createVertices(r.width,r.height,e)),this._indices=this._createIndices();}isValid(){return this._is_valid}get texture(){return this._texture}get vertices(){return this._vertices}get indices(){return this._indices}_createItemList(){var t=r$t.createCanvasContext(1,1),e=[];for(let i of this._owner.getEntity().entries)e.push(new y(this,i,t));return e}_createRowLayouts(){var t=this._items.slice();t.sort((function(t,e){return t.height_pixel-e.height_pixel}));for(var e=[];t.length>0;){var i=new v(t);i.isValid()&&e.push(i);}return e}_createTexture(t,e){var i=r$t.createCanvasContext(t,e);i.textAlign="left",i.textBaseline="alphabetic",i.fillStyle="rgba( 255, 255, 255, 1.0 )";for(var s=this._items,o=0;o<s.length;++o){var n=s[o],_=n.entry;n.is_canceled||(_.enable_background&&n.drawRect(i),_.enable_stroke&&n.drawStrokeText(i),n.drawText(i));}var h=this._owner.getEntity().scene.glenv;return new t$d(h,i.canvas,{usage:"@@_Usage.TEXT"})}_createVertices(t,e,i){for(var r=[],s=this._owner.transform,o=s[12],n=s[13],_=s[14],h=this._items,a=0;a<h.length;++a){var l=h[a];if(!l.is_canceled){var p=3*a,u=i[p]-o,d=i[p+1]-n,c=i[p+2]-_,m=l.pos_x,g=l.pos_y,y=l.upper,v=l.lower,f=l.width,x=1/t,E=1/e;r.push(u,d,c),r.push(-f/2,-v),r.push(m*x,1-(g+v)*E),r.push(u,d,c),r.push(f/2,-v),r.push((m+f)*x,1-(g+v)*E),r.push(u,d,c),r.push(-f/2,y),r.push(m*x,1-(g-y)*E),r.push(u,d,c),r.push(f/2,y),r.push((m+f)*x,1-(g-y)*E);}}return r}_createTextureForSimple(t,e){var i=r$t.createCanvasContext(t,e);i.textAlign="left",i.textBaseline="alphabetic",i.fillStyle="rgba( 255, 255, 255, 1.0 )";for(var s=this._items,o=0;o<s.length;++o){var n=s[o];n.is_canceled||n.drawText(i);}var _=this._owner.getEntity().scene.glenv;return new t$d(_,i.canvas,{usage:"@@_Usage.SIMPLETEXT"})}_createVerticesForSimple(t,e,i){for(var r=[],s=this._owner._transform,o=s[12],n=s[13],_=s[14],h=this._items,a=0;a<h.length;++a){var l=h[a];if(!l.is_canceled){var p=l.entry.color,u=3*a,d=i[u]-o,c=i[u+1]-n,m=i[u+2]-_,g=l.pos_x,y=l.pos_y,v=l.upper,f=l.lower,x=l.width,E=1/t,w=1/e;r.push(d,c,m),r.push(-x/2,-f),r.push(g*E,1-(y+f)*w),r.push(p[0],p[1],p[2],1),r.push(d,c,m),r.push(x/2,-f),r.push((g+x)*E,1-(y+f)*w),r.push(p[0],p[1],p[2],1),r.push(d,c,m),r.push(-x/2,v),r.push(g*E,1-(y-v)*w),r.push(p[0],p[1],p[2],1),r.push(d,c,m),r.push(x/2,v),r.push((g+x)*E,1-(y-v)*w),r.push(p[0],p[1],p[2],1);}}return r}_createIndices(){for(var t=[],e=this._items,i=0;i<e.length;++i){if(!e[i].is_canceled){var r=4*i;t.push(r,r+1,r+2,r+2,r+1,r+3);}}return t}_setupLocation(t){var e=0,i=0;i+=s.SAFETY_PIXEL_MARGIN;for(var r=0;r<t.length;++r){var o=t[r];o.locate(i),e=Math.max(o.width_assumed,e),i+=o.height_pixel+s.SAFETY_PIXEL_MARGIN;}return {width:e,height:i}}_isSimpleText(t){return !t.entry.enable_background&&!t.entry.enable_stroke}_isSimpleTextWithAllItems(t){let e=!0,i=0;for(;e&&t.length>i;){let r=t[i];e=this._isSimpleText(r),i++;}return e}}class y{constructor(t,e,i){this._entry=e,this._pos_x=0,this._pos_y=0,i.font=e.font,this._width=i.measureText(e.text).width,this._upper=e.size*s.DEFAULT_TEXT_UPPER,this._lower=e.size*s.DEFAULT_TEXT_LOWER,this._is_canceled=!1;}get entry(){return this._entry}get pos_x(){return this._pos_x}get pos_y(){return this._pos_y}get width(){return this._width}get upper(){return this._upper}get lower(){return this._lower}get width_pixel(){return Math.ceil(this._width)}get height_pixel(){return Math.ceil(this._upper)+Math.ceil(this._lower)}get is_canceled(){return this._is_canceled}cancel(){this._is_canceled=!0;}locate(t,e){this._pos_x=t,this._pos_y=e+Math.ceil(this._upper);}drawTextOnly(t){var e=this._entry;t.font=e.font,t.fillText(e.text,this._pos_x,this._pos_y);}drawText(t){var e=this._entry;t.font=e.font,t.fillStyle=r$o.toRGBString(e.color),t.fillText(e.text,this._pos_x,this._pos_y);}drawStrokeText(t){var e=this._entry;t.font=e.font,t.strokeStyle=r$o.toRGBString(e.stroke_color),t.lineWidth=2*e.stroke_width,t.lineJoin="round",t.strokeText(e.text,this._pos_x,this._pos_y);}drawRect(t){var e=this._entry;t.fillStyle=r$o.toRGBString(e.bg_color),t.fillRect(this._pos_x-s.SAFETY_PIXEL_MARGIN,this._pos_y-s.SAFETY_PIXEL_MARGIN-this._upper,this.width_pixel+s.SAFETY_PIXEL_MARGIN,this.height_pixel+s.SAFETY_PIXEL_MARGIN);}}class v{constructor(t){var e=0,i=0,r=[];for(e+=s.SAFETY_PIXEL_MARGIN;t.length>0;){var o=t.shift(),n=o.width_pixel+s.SAFETY_PIXEL_MARGIN;if(e+n<=s.MAX_IMAGE_WIDTH)r.push(o),e+=n,i=Math.max(o.height_pixel,i);else {if(0!=r.length){t.unshift(o);break}o.cancel();}}this._items=r,this._width_assumed=e,this._height_pixel=i;}isValid(){return this._items.length>0}get items(){return this._items}get width_assumed(){return this._width_assumed}get height_pixel(){return this._height_pixel}locate(t){var e=this._items,i=0;i+=s.SAFETY_PIXEL_MARGIN;for(var r=0;r<e.length;++r){var o=e[r];o.locate(i,t),i+=o.width_pixel+s.SAFETY_PIXEL_MARGIN;}}}}(m$4||(m$4={}));var g$4=m$4;

class m$3 extends s$m{constructor(t,r){if(super(t,r),this._position=new r$z(0,0,0),this._matrix=e$z.setIdentity(e$z.createMatrix()),this._scale=e$z.createVector3([1,1,1]),this._primitive_producer=new m$3.PrimitiveProducer(this),this._transform_mode=m$3.TransformMode.POSITION_MLOCS_SCALE_ORIENTATION,this._setupAnimationBindingBlock(),r&&r.json){var o=r.json,s=r.refs||{};this._setupTransform(o),this._setupModelObject(o,s);}}get transform_mode(){return this._transform_mode}setTransformMode(t){if(this._transform_mode!==t){if(this._transform_mode===m$3.TransformMode.POSITION_MLOCS_SCALE_ORIENTATION)t===m$3.TransformMode.GOCS_MATRIX&&this._primitive_producer.getMatrix(this._matrix);else if(t===m$3.TransformMode.POSITION_MLOCS_SCALE_ORIENTATION){const t=e$z.createVector3([this._matrix[12],this._matrix[13],this._matrix[14]]);this._position.setFromGocs(t);const e=this._position.getMlocsToGocsMatrix(e$z.createMatrix());e$z.inverse_A(e,e),e$z.mul_AA(e,this._matrix,e);for(let t=0;t<3;++t){let i=0;for(let r=0;r<3;++r){const o=e[4*t+r];i+=o*o;}if(i<1||1<i){i=Math.sqrt(i);for(let r=0;r<3;++r)e[4*t+r]/=i;this._scale[t]=i;}}e$z.copyMatrix(e,this._matrix);}this._transform_mode=t,this._primitive_producer.onChangePosition();}}getPrimitiveProducer(){return this._primitive_producer}onChangeAltitudeMode(t){this._primitive_producer.onChangeAltitudeMode();}getBounds(){const t=this._primitive_producer.getBounds(),i=new _$a;return i.addPointsAsArray(t),i}_setupAnimationBindingBlock(){const t=this.animation,o=s$u.find("number"),s=s$u.find("vector3"),n=s$u.find("matrix"),m=new r$z;t.addEntry("position",[s],null,(t=>{m.setFromArray(t),this.setPosition(m);}));const d=new a$n;let l;t.addEntry("orientation",[n,s],(t=>{if(l=t$z.findFirstTypeSupported(t,[n,s]),!l)throw new Error("could not find type of orientation.");return l}),(t=>{l===n?this._setRotation(t):(d.heading=t[0],d.tilt=t[1],d.roll=t[2],this.setOrientation(d));}));const c=e$z.createVector3();let h;t.addEntry("scale",[s,o],(t=>{if(h=t$z.findFirstTypeSupported(t,[s,o]),!h)throw new Error("could not find type of scale.");return h}),(t=>{h===s?this.setScale(t):(c[0]=t,c[1]=t,c[2]=t,this.setScale(c));}));}_setupTransform(t){let i=t.transform;this.transform_mode!==m$3.TransformMode.POSITION_MLOCS_SCALE_ORIENTATION&&this.setTransformMode(m$3.TransformMode.POSITION_MLOCS_SCALE_ORIENTATION),this.setPosition((new r$z).setFromArray(i.position)),this.setOrientation(new a$n(i.heading,i.tilt,i.roll));const o=i.scale;this.setScale(void 0===o?[1,1,1]:"number"==typeof o?[o,o,o]:o);}_setupModelObject(t,i){let e=i[t.ref_model];this._primitive_producer.setModelObject(e,t.index);}setPosition(t){if(this.transform_mode===m$3.TransformMode.GOCS_MATRIX)return void console.log("Warning: invalid transform mode: "+this.transform_mode);let i=this._position;t.longitude==i.longitude&&t.latitude==i.latitude&&t.altitude==i.altitude||(this._position.assign(t),this._primitive_producer.onChangePosition());}setOrientation(t){this.transform_mode!==m$3.TransformMode.GOCS_MATRIX?t.getTransformMatrix(d$1,this._matrix):console.log("Warning: invalid transform mode: "+this.transform_mode);}setScale(t){this.transform_mode!==m$3.TransformMode.GOCS_MATRIX?e$z.copyVector3(t,this._scale):console.log("Warning: invalid transform mode: "+this.transform_mode);}_setRotation(t){this.transform_mode!==m$3.TransformMode.GOCS_MATRIX?e$z.copyMatrix(t,this._matrix):console.log("Warning: invalid transform mode: "+this.transform_mode);}setMatrix(t){this.transform_mode!==m$3.TransformMode.POSITION_MLOCS_SCALE_ORIENTATION?e$z.copyMatrix(t,this._matrix):console.log("Warning: invalid transform mode: "+this.transform_mode);}_getElevation(){return this.scene.viewer.getExistingElevation(this._position)}}!function(r){class o extends s$m.PrimitiveProducer{constructor(t){super(t),this._primitives=[],this._pickPrimitives=[],this._ptoe_array=[],this._abs_position=null;}getEntity(){return super.getEntity()}setModelObject(t,e){let r=t.createPrimitives(e,{ridMaterial:!1}),o=t.createPrimitives(e,{ridMaterial:!0});if(!r)throw new Error("model is not found in ModelContainer");this._primitives=r,this._pickPrimitives=o||[],this._ptoe_array=r.map((t=>e$z.createMatrix(t.transform)));}createRegions(){const t=new r$9;return t.addPoint(this.getEntity()._position),[t]}onChangeElevation(t){this._abs_position=null;}getPrimitives(t){const e=this.getMatrix(e$z.createMatrix());for(var r="SCENE"===t.getRenderTarget()?this._primitives:this._pickPrimitives,o=this._ptoe_array,s=0;s<r.length;++s){var n=r[s],a=o[s];e$z.mul_AA(e,a,n.transform);}return r}getBounds(){const t=this.getMatrix(e$z.createMatrix()),r=this._primitives,o=this._ptoe_array;let s=Number.MAX_VALUE,n=-Number.MAX_VALUE,a=Number.MAX_VALUE,_=-Number.MAX_VALUE,m=Number.MAX_VALUE,d=-Number.MAX_VALUE,l=new Float64Array(16);for(var c=0;c<r.length;++c){const h=r[c],u=o[c];e$z.mul_AA(t,u,l);const f=h.bbox,p=f[0][0]*l[0]+f[0][1]*l[4]+f[0][2]*l[8]+l[12],M=f[0][0]*l[1]+f[0][1]*l[5]+f[0][2]*l[9]+l[13],A=f[0][0]*l[2]+f[0][1]*l[6]+f[0][2]*l[10]+l[14],T=f[1][0]*l[0]+f[1][1]*l[4]+f[1][2]*l[8]+l[12],O=f[1][0]*l[1]+f[1][1]*l[5]+f[1][2]*l[9]+l[13],g=f[1][0]*l[2]+f[1][1]*l[6]+f[1][2]*l[10]+l[14];let E=new r$z;E.setFromGocs([p,M,A]);let I=new r$z;I.setFromGocs([T,O,g]);let v=E.longitude,S=E.latitude,x=E.altitude;v<s&&(s=v),v>n&&(n=v),S<a&&(a=S),S>_&&(_=S),x<m&&(m=x),x>d&&(d=x),v=I.longitude,S=I.latitude,x=I.altitude,v<s&&(s=v),v>n&&(n=v),S<a&&(a=S),S>_&&(_=S),x<m&&(m=x),x>d&&(d=x);}const h=new Float64Array(6);return h[0]=s,h[1]=a,h[2]=m,h[3]=n,h[4]=_,h[5]=d,h}onChangeAltitudeMode(){this._abs_position=null;}onChangePosition(){this.needToCreateRegions(),this._abs_position=null;}getMatrix(t){const e=this.getEntity();this._updateAbsPosition();const r=this._abs_position;if(!r)throw new Error("Unknown Error");switch(e.transform_mode){case a.GOCS_MATRIX:return e$z.copyMatrix(e._matrix,t);case a.POSITION_MLOCS_SCALE_ORIENTATION:{const o=r.getMlocsToGocsMatrix(e$z.createMatrix()),s=function(t,i,e){let r=i[0],o=i[1],s=i[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=0,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=0,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}(e._matrix,e._scale,e$z.createMatrix());return e$z.mul_AA(o,s,t)}default:throw new Error("Unsupported transform mode: "+e._transform_mode)}}_updateAbsPosition(){if(null!==this._abs_position)return;const t=this.getEntity(),i=t._position.clone();switch(t.altitude_mode){case E$4.RELATIVE:i.altitude+=t._getElevation();break;case E$4.CLAMP:i.altitude=t._getElevation();}this._abs_position=i;}}let a;r.PrimitiveProducer=o,function(t){t[t.POSITION_MLOCS_SCALE_ORIENTATION=0]="POSITION_MLOCS_SCALE_ORIENTATION",t[t.GOCS_MATRIX=1]="GOCS_MATRIX";}(a=r.TransformMode||(r.TransformMode={}));}(m$3||(m$3={}));const d$1=e$z.createVector3([1,1,1]);var l$4=m$3;

var n$l="/**\n * 多角形の頂点シェーダ\n */\n\nattribute vec4 a_position;   // 位置 (モデル座標系)\nattribute vec3 a_normal;     // 法線 (モデル座標系)\n\nuniform mat4 u_obj_to_clip;  // モデル座標系からクリップ座標系への変換\nuniform mat4 u_obj_to_view;  // モデル座標系から視点座標系への変換\nuniform bool u_lighting;     // 照光の有無\nuniform vec3 u_light_dir;    // ライト逆方向 (視点座標系) と強さ\n\nvarying vec3 v_lit_diffuse;  // 拡散光ライト\n\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n\n    if ( u_lighting ) {\n        // 法線 (視点座標系)\n        vec3 normal = normalize( vec3( u_obj_to_view * vec4( a_normal, 0.0 ) ) );\n\n        // 拡散光の強さ\n        v_lit_diffuse = vec3( dot( normal, u_light_dir ) );\n    }\n    else {\n        // 照光なしのときは 1 に固定\n        v_lit_diffuse = vec3( 1 );\n    }\n}\n";

var n$k="/**\n * 多角形のフラグメントシェーダ\n */\n\nprecision mediump float;\n\nvarying vec3 v_lit_diffuse;  // 拡散光ライト\n\nuniform vec4 u_color;        // 基本色と不透明度\n\n\nvoid\nmain()\n{\n    vec3  color   = u_color.xyz * v_lit_diffuse;\n    float opacity = u_color.w;\n\n    gl_FragColor = vec4( color * opacity, opacity );\n}\n";

class a$7 extends o$b{constructor(r,t={}){super(r,n$l,t.ridMaterial?n$T:n$k);}isTranslucent(r,t){var e=t.properties;return (void 0!==e.opacity?e.opacity:a$7.DEFAULT_OPACITY)<1}setParameters(r,e){super.setParameters(r,e);var o=e.properties;if(this.setObjToClip(r,e),this.setObjToView(r,e),r.getRenderTarget()===l$5.RenderTarget.SCENE){var i=void 0!==o.color?o.color:a$7.DEFAULT_COLOR,c=void 0!==o.opacity?o.opacity:a$7.DEFAULT_OPACITY,p=a$7._color;e$z.copyVector3(i,p),p[3]=c,this.setVector4("u_color",p),this.setBoolean("u_lighting",o.lighting),this.setVector3("u_light_dir",[0,0,1]);}}}a$7.DEFAULT_COLOR=e$z.createVector3f([1,1,1]),a$7.DEFAULT_OPACITY=1,a$7._color=e$z.createVector4f();

class e$8{constructor(e,t,r,s){this._points=new Float64Array(2*s),this._polygons=new Set;let i=t,o=0;for(let t=0;t<s;++t)this._points[o]=e[i],this._points[o+1]=e[i+1],i+=r,o+=2;}addBoundary(e){this._polygons.add(r$6.create(this._points,e));}run(){this._makeYMonotonePolygons();let e=new Uint32Array(3*this._numTriangles()),t=0;for(let r of this._polygons){let s=this._makeTriangleArray(r);e.set(s,t),t+=s.length;}return e}_numTriangles(){let e=0;for(let t of this._polygons)e+=t.numVertices()-2;return e}_makeYMonotonePolygons(){let e=this._getYOrderedVertices(),t=new s$5,r=new o$7(this._polygons);for(let s=0;s<e.length;++s){let i=e[s];switch(i.getVertexType()){case"start":{let e=i.getFrontEdge();t.addEdge(e,i);}break;case"end":{let e=i.getBackEdge(),s=t.getHelper(e);"merge"==s.getVertexType()&&r.addDiagonal(i,s),t.removeEdge(e);}break;case"split":{let e=t.findNearestLeftEdge(i);r.addDiagonal(i,t.getHelper(e)),t.setHelper(e,i);let s=i.getFrontEdge();t.addEdge(s,i);}break;case"merge":{let e=i.getBackEdge(),s=t.getHelper(e);"merge"==s.getVertexType()&&r.addDiagonal(i,s),t.removeEdge(e);let o=t.findNearestLeftEdge(i),n=t.getHelper(o);"merge"==n.getVertexType()&&r.addDiagonal(i,n),t.setHelper(o,i);}break;default:if(i.isRightInner()){let e=i.getBackEdge(),s=t.getHelper(e);"merge"==s.getVertexType()&&r.addDiagonal(i,s),t.removeEdge(e);let o=i.getFrontEdge();t.addEdge(o,i);}else {let e=t.findNearestLeftEdge(i),s=t.getHelper(e);"merge"==s.getVertexType()&&r.addDiagonal(i,s),t.setHelper(e,i);}}}r.splitPolygons();}_getYOrderedVertices(){let e=[];for(let t of this._polygons)Array.prototype.push.apply(e,t.getVertices());return e.sort(((e,r)=>t$9.comparePositionY(r,e)))}_makeTriangleArray(e){let r=0,s=new Uint32Array(3*(e.numVertices()-2)),i=new l$3,o=0,n=e.getVertices().sort(((e,r)=>t$9.comparePositionY(r,e))),a=n[0].prev===n[1];for(i.push(n[o++]),i.push(n[o++]);o<n.length-1;){let e=n[o];if(a?e===i.top.prev:e===i.top.next){let o=i.pop();for(;i.size>0;){let n=i.top,[l,g]=a?[o,n]:[n,o];if(!t$9.isCCW(e,l,g))break;s[r++]=e.id,s[r++]=l.id,s[r++]=g.id,o=i.pop();}i.push(o),i.push(e);}else {let t=i.pop();for(;i.size>0;){let o=i.pop(),[n,l]=a?[t,o]:[o,t];s[r++]=e.id,s[r++]=n.id,s[r++]=l.id,t=o;}i.push(n[o-1]),i.push(e),a=!a;}++o;}let g=n[o],p=i.pop();for(;i.size>0;){let e=i.pop(),[t,o]=a?[p,e]:[e,p];s[r++]=g.id,s[r++]=t.id,s[r++]=o.id,p=e;}return s}}class t$9{constructor(e,t,r){this.id=e,this.x=t,this.y=r,this.polygon=null,this.next=null,this.prev=null;}clone(){return new t$9(this.id,this.x,this.y)}getVertexType(){let e=this.prev,r=this.next,s=t$9.comparePositionY(e,this),i=t$9.comparePositionY(r,this);if(s>0&&i>0||s<0&&i<0){let t=e.y-this.y,o=this.x-e.x,n=t*(r.x-this.x)+o*(r.y-this.y);return s>0&&i>0?n<0?"merge":"end":n<0?"split":"start"}return "regular"}getFrontEdge(){return this}getBackEdge(){return this.prev}isRightInner(){return t$9.comparePositionY(this.next,this)<0}static comparePositionY(e,t){return e.y<t.y||e.y==t.y&&e.x>t.x?-1:e.y>t.y||e.y==t.y&&e.x<t.x?1:0}static isCCW(e,t,r){let s=t.x-e.x,i=t.y-e.y,o=r.x-e.x;return s*(r.y-e.y)-i*o>0}}class r$6{constructor(){this._first=null;}static create(e,s){let i=new r$6,o=s[0],n=2*o,l=new t$9(o,e[n],e[n+1]);i._first=l;for(let r=1;r<s.length;++r){let i=l;o=s[r],n=2*o,l=new t$9(o,e[n],e[n+1]),i.next=l,l.prev=i;}return i._first.prev=l,l.next=i._first,i._updateVertices(),i}static createByVertex(e){let t=new r$6;return t._first=e,t._updateVertices(),t}numVertices(){let e=0,t=this._first;++e;let r=this._first;for(t=t.next;t!==r;t=t.next)++e;return e}getVertices(){let e=[],t=this._first;e.push(t);let r=this._first;for(t=t.next;t!==r;t=t.next)e.push(t);return e}_updateVertices(){let e=this._first;e.polygon=this;let t=this._first;for(e=e.next;e!==t;e=e.next)e.polygon=this;}}class s$5{constructor(){this._edges=new Map;}addEdge(e,t){this._edges.set(e,{helper:t});}removeEdge(e){this._edges.delete(e);}setHelper(e,t){this._edges.get(e).helper=t;}getHelper(e){return this._edges.get(e).helper}findNearestLeftEdge(e){let t,r=Number.MAX_VALUE,s=e.x,i=e.y;for(let[e]of this._edges){let o=e.x,n=e.y,l=s-(o+(i-n)*((e.next.x-o)/(e.next.y-n)));l>0&&l<r&&(r=l,t=e);}if(void 0===t)throw new Error("Probably a degenerate polygon");return t}}class i$7{constructor(e,t){this.v1=e,this.v2=t;}}class o$7{constructor(e){this._polygons=e,this._diagonals=[],this._dmap=new n$j;}addDiagonal(e,t){let r=new i$7(e,t);this._diagonals.push(r),this._dmap.addDiagonal(r);}splitPolygons(){for(this._shuffleArray(this._diagonals);this._diagonals.length>0;){let e=this._diagonals.pop();this._dmap.removeDiagonal(e);let t=e.v1,s=e.v2,[i,o]=this._splitPolygonHalf(t,s),[n,l]=this._splitPolygonHalf(s,t),a=t.polygon,g=s.polygon;a===g?(this._polygons.delete(a),this._polygons.add(r$6.createByVertex(i)),this._polygons.add(r$6.createByVertex(l))):(this._polygons.delete(a),this._polygons.delete(g),this._polygons.add(r$6.createByVertex(i))),this._replaceVertexInDiagonals(t,i,l),this._replaceVertexInDiagonals(s,o,n);}}_splitPolygonHalf(e,t){let r=e.clone(),s=t.clone();return r.prev=e.prev,r.next=s,e.prev.next=r,s.prev=r,s.next=t.next,t.next.prev=s,[r,s]}_replaceVertexInDiagonals(e,t,r){for(let s of this._dmap.removeDiagonals(e)){let i=s.v1===e?s.v2:s.v1;s.v1=this._testDiagonal(t,i)?t:r,s.v2=i,this._dmap.addDiagonal(s);}}_testDiagonal(e,t){let r=e.next.x-e.x,s=e.next.y-e.y,i=e.prev.x-e.x,o=e.prev.y-e.y,n=t.x-e.x,l=t.y-e.y,a=r*l-n*s>0,g=i*l-n*o<0;return r*o-i*s>=0?a&&g:a||g}_shuffleArray(e){for(let t=e.length-1;t>0;--t){let r=Math.floor(Math.random()*(t+1)),s=e[t];e[t]=e[r],e[r]=s;}}}class n$j{constructor(){this._map=new Map;}addDiagonal(e){this._addDiagonalByVertex(e.v1,e),this._addDiagonalByVertex(e.v2,e);}removeDiagonal(e){this._removeDiagonalByVertex(e.v1,e),this._removeDiagonalByVertex(e.v2,e);}removeDiagonals(e){let t=this._map.get(e);if(void 0!==t){let e=t.slice();for(let t of e)this.removeDiagonal(t);return e}return []}_addDiagonalByVertex(e,t){let r=this._map.get(e);if(void 0===r)this._map.set(e,[t]);else {if(-1!=r.indexOf(t))throw new Error("Unexpected");if(r.length<1||r.length>2)throw new Error("Unexpected");r.push(t);}}_removeDiagonalByVertex(e,t){let r=this._map.get(e);if(void 0===r)throw new Error("Unexpected");let s=r.indexOf(t);if(-1==s)throw new Error("Unexpected");r.splice(s,1),0==r.length&&this._map.delete(e);}}class l$3{constructor(){this._array=new Array;}get size(){return this._array.length}push(e){this._array.push(e);}pop(){return this._array.pop()}get top(){let e=this._array;return e.length>0?e[e.length-1]:null}}

class m$2 extends s$m{constructor(t,e={}){super(t,e),this._extruded_height=0,this._color=e$z.createVector3([1,1,1]),this._opacity=1,this._boundaries=[],this._position=void 0,this.altitude_mode===E$4.CLAMP?(this._producer=new m$2.FlakePrimitiveProducer(this),this._is_flake_mode=!0):(this._producer=new m$2.PrimitiveProducer(this),this._is_flake_mode=!1),this._setupAnimationBindingBlock(),e&&e.json&&this._setupByJson(e.json);}set extruded_height(t){this._extruded_height!==t&&(this._extruded_height=t,this._producer.onChangeExtruded());}get extruded_height(){return this._extruded_height}get boundaries(){return this._boundaries}getPrimitiveProducer(){return this._is_flake_mode?void 0:this._producer}getFlakePrimitiveProducer(){return this._is_flake_mode?this._producer:void 0}onChangeAltitudeMode(t){this.altitude_mode===E$4.CLAMP?(this._producer=new m$2.FlakePrimitiveProducer(this),this._is_flake_mode=!0):(this._producer=new m$2.PrimitiveProducer(this),this._is_flake_mode=!1);}_setupAnimationBindingBlock(){const t=this.animation,e=s$u.find("number"),r=s$u.find("vector3");t.addEntry("color",[r],null,(t=>{this.setColor(t);})),t.addEntry("opacity",[e],null,(t=>{this.setOpacity(t);})),t.addEntry("height",[e],null,(t=>{this.setExtrudedHeight(t);}));}setColor(t){this._color[0]===t[0]&&this._color[1]===t[1]&&this._color[2]===t[2]||(e$z.copyVector3(t,this._color),this._producer.onChangeProperty());}setOpacity(t){this._opacity!==t&&(this._opacity=t,this._producer.onChangeProperty());}setExtrudedHeight(t){this.extruded_height=t;}addOuterBoundary(t){return this._addBoundary(t,!1)}addInnerBoundary(t){return this._addBoundary(t,!0)}getBoundaryCount(){return this._boundaries.length}getBoundaryAt(t){return this._boundaries[t]}removeBoundary(t){const e=this._boundaries.indexOf(t);return -1!==e&&(this._boundaries.splice(e,1),this._producer.onChangeBoundary(),!0)}removeAllBoundaries(){this._boundaries.length=0,this._position=void 0,this._producer.onChangeBoundary();}getBounds(){const t=new _$a;for(let e of this._boundaries)t.addPointsAsArray(e.points);return t}_addBoundary(t,e){const r=new m$2.Boundary(t,e);return this._boundaries.push(r),this._position=void 0,this._producer.onChangeBoundary(),r}_getMaterial(t){var e=this.scene;if("SCENE"===t)return e._PolygonEntity_material||(e._PolygonEntity_material=new a$7(e.glenv)),e._PolygonEntity_material;if("RID"===t)return e._PolygonEntity_material_pick||(e._PolygonEntity_material_pick=new a$7(e.glenv,{ridMaterial:!0})),e._PolygonEntity_material_pick;throw new Error("unknown render target: "+t)}_setupByJson(t){for(let e of t.boundaries)"inner"==e.type?this.addInnerBoundary(e.points):this.addOuterBoundary(e.points);void 0!==t.extruded_height&&(this.extruded_height=t.extruded_height),void 0!==t.color&&e$z.copyVector3(t.color,this._color),void 0!==t.opacity&&(this._opacity=t.opacity);}_getPosition(){if(void 0!==this._position)return this._position;if(0!=this._boundaries.length){var t=Number.MAX_VALUE,e=-Number.MAX_VALUE,r=Number.MAX_VALUE,i=-Number.MAX_VALUE;for(let o of this._boundaries){let a=o.num_points,_=o.points;for(let o=0;o<a;++o){var s=_[3*o],n=_[3*o+1];s<t&&(t=s),s>e&&(e=s),n<r&&(r=n),n>i&&(i=n);}}return this._position=new r$z((t+e)/2,(r+i)/2),this._position}}_countNumPointsOnBoundaries(){let t=0;for(let e of this._boundaries)t+=e.num_points;return t}_getCombinedBoundaryPoints(){let t=new Float64Array(3*this._countNumPointsOnBoundaries()),e=0;for(let r of this._boundaries)t.set(r.points,e),e+=3*r.num_points;return t}_getCombinedBoundary2DPoints(){let t=new Float64Array(2*this._countNumPointsOnBoundaries()),e=0;for(let r of this._boundaries){let i=3*r.num_points,s=r.points;for(let r=0;r<i;r+=3)t[e++]=s[r],t[e++]=s[r+1];}return t}_createTriangles(){let t=this._getCombinedBoundary2DPoints(),e=this._countNumPointsOnBoundaries(),r=new e$8(t,0,2,e),i=0;for(let t of this._boundaries){let e=t.num_points,s=new Uint32Array(e);for(let t=0;t<e;++t)s[t]=i++;r.addBoundary(s);}try{return r.run()}catch(t){return void(t instanceof Error?console.error(t.message):console.error(t))}}getTriangleIndices(){const t=this._createTriangles();if(t)return Array.from(t)}}!function(i){class n extends s$m.PrimitiveProducer{constructor(t){super(t),this._status=I.INVALID,this._transform=e$z.setIdentity(e$z.createMatrix()),this._pivot=e$z.createVector3(),this._bbox=[e$z.createVector3(),e$z.createVector3()],this._properties={color:e$z.createVector3f(),opacity:1,lighting:!1};var r=new s$h(t.scene.glenv,null,t._getMaterial("SCENE"),this._transform);r.pivot=this._pivot,r.bbox=this._bbox,r.properties=this._properties,this._primitive=r;var i=new s$h(t.scene.glenv,null,t._getMaterial("RID"),this._transform);i.pivot=this._pivot,i.bbox=this._bbox,i.properties=this._properties,this._pickPrimitive=i;}getEntity(){return super.getEntity()}needsElevation(){return this.getEntity().altitude_mode!==E$4.ABSOLUTE}createRegions(){let t=this.getEntity();if(this._status===I.INVALID)return [];var e=new r$9;for(let r of t.boundaries)e.addPoints(r.points,0,3,r.num_points);return e.addPoint(t._getPosition()),[e]}onChangeElevation(t){this._status===I.NORMAL&&(this._status=I.MESH_DIRTY);}getPrimitives(t){if(this._status===I.INVALID)return [];if(this._status===I.TRIANGLE_DIRTY){if(this._triangles=this.getEntity()._createTriangles(),void 0===this._triangles)return this._primitive.mesh=null,this._pickPrimitive.mesh=null,this._status=I.INVALID,[];this._updatePrimitiveMesh();}else this._status===I.MESH_DIRTY&&this._updatePrimitiveMesh();return this._updatePrimitiveProperties(),this._status=I.NORMAL,"SCENE"===t.getRenderTarget()?[this._primitive]:[this._pickPrimitive]}onChangeExtruded(){this._status===I.NORMAL&&(this._status=I.MESH_DIRTY);}onChangeProperty(){}onChangeBoundary(){this._status=I.TRIANGLE_DIRTY,this._triangles=void 0,this.needToCreateRegions();}_updatePrimitiveMesh(){var t=new m(this.getEntity());this._updateTransformPivotBBox(t);var e={vtype:[{name:"a_position",size:3},{name:"a_normal",size:3}],vertices:this._createVertices(t),indices:this._createIndices(t)},i=new r$h(this.getEntity().scene.glenv,e);this._primitive.mesh=i,this._pickPrimitive.mesh=i;}_updateTransformPivotBBox(t){let e=this._transform;e[12]=t.origin[0],e[13]=t.origin[1],e[14]=t.origin[2];let r=Number.MAX_VALUE,i=Number.MAX_VALUE,s=Number.MAX_VALUE,o=-Number.MAX_VALUE,n=-Number.MAX_VALUE,a=-Number.MAX_VALUE,_=[t.upper];t.lower&&_.push(t.lower);for(let e=0;e<_.length;++e){let h=_[e];for(let e=0;e<t.num_points;++e){let t=3*e,_=h[t],l=h[t+1],u=h[t+2];_<r&&(r=_),l<i&&(i=l),u<s&&(s=u),_>o&&(o=_),l>n&&(n=l),u>a&&(a=u);}}let h=this._pivot;h[0]=(r+o)/2,h[1]=(i+n)/2,h[2]=(s+a)/2;let l=this._bbox,u=l[0],c=l[1];u[0]=r,u[1]=i,u[2]=s,c[0]=o,c[1]=n,c[2]=a;}_createVertices(t){const e=6*t.num_points,r=t.lower?4*t.num_points*6:0,i=t.lower?e:0;let o=new Float32Array(e+r+i),n=e$z.normalize3(t.origin,e$z.createVector3());for(let e=0;e<t.num_points;++e){let r=3*e,i=t.upper[r],s=t.upper[r+1],a=t.upper[r+2],_=6*e;o[_]=i,o[_+1]=s,o[_+2]=a,P(n,o,_+3);}if(t.lower){let r=e$z.createVector3(),i=e$z.createVector3(),n=e$z.createVector3(),a=e$z.createVector3(),_=e$z.createVector3(),h=0;for(let s of this.getEntity().boundaries){let l=h+s.num_points;for(let s=h;s<l;++s){let u=3*s,c=3*(s+1<l?s+1:h);A(t.lower,u,r),A(t.lower,c,i),A(t.upper,u,n),A(t.upper,c,a),M(r,i,n,_);let d=e+24*s;P(r,o,d),P(_,o,d+3),d+=6,P(i,o,d),P(_,o,d+3),d+=6,P(n,o,d),P(_,o,d+3),d+=6,P(a,o,d),P(_,o,d+3);}h=l;}}if(t.lower){const i=e$z.scale3(-1,n,e$z.createVector3());for(let s=0;s<t.num_points;++s){let n=3*s,a=t.lower[n],_=t.lower[n+1],h=t.lower[n+2],l=e+r+6*s;o[l]=a,o[l+1]=_,o[l+2]=h,P(i,o,l+3);}}return o}_createIndices(t){const e=this._triangles;let r=e.length/3,i=t.lower?2*t.num_points:0,s=t.lower?r:0,o=new Uint32Array(3*(r+i+s));if(o.set(e),t.lower){let e=t.num_points,i=3*r,s=t.num_points;for(let t=0;t<e;++t,i+=6,s+=4)o[i]=s,o[i+1]=s+1,o[i+2]=s+2,o[i+3]=s+2,o[i+4]=s+1,o[i+5]=s+3;}if(t.lower){const s=e.length/3,n=t.num_points+4*t.num_points;for(let t=0;t<s;++t)o[3*(r+i+t)+0]=e[3*t+0]+n,o[3*(r+i+t)+1]=e[3*t+2]+n,o[3*(r+i+t)+2]=e[3*t+1]+n;}return o}_updatePrimitiveProperties(){let t=this.getEntity(),e=this._properties;const r=t._color;e$z.copyVector3(r,e.color),e.opacity=t._opacity,e.lighting=0!==t.extruded_height;}}i.PrimitiveProducer=n;class h extends s$m.FlakePrimitiveProducer{constructor(t){super(t),this._material_map=new Map,l$5.ListOfRenderTarget.forEach((e=>{this._material_map.set(e,t._getMaterial(e));})),this._properties=void 0,this._area_manager=new g(t);}getAreaStatus(t){return this._area_manager.getAreaStatus(t)}createMesh(t,e,i){let s=this._area_manager.getAreaContent(t),o=Math.PI*Math.pow(2,1-t.z),n=t.x*o-Math.PI,a=Math.PI-(t.y+1)*o,_=1<<e[0],h=1<<e[1],l=this._createSubmeshes(n,a,n+o,a+o,_,h,s),u={vtype:[{name:"a_position",size:3},{name:"a_normal",size:3}],vertices:this._createVertices(l,t,i),indices:this._createIndices(l)};return new r$h(this.getEntity().scene.glenv,u)}getMaterialAndProperties(t){if(void 0===this._properties){let t=this.getEntity();const e=t._color,r=t._opacity;this._properties={color:e$z.createVector3f(e),opacity:r,lighting:!1};}return {material:this._material_map.get(t.getRenderTarget()),properties:this._properties}}onChangeExtruded(){}onChangeProperty(){this._properties=void 0;}onChangeBoundary(){this._area_manager.notifyForUpdateContent(),this.notifyForUpdate();}_createVertices(t,e,r){let i=a$e.getCenter(e,e$z.createVector3()),o=r.newSampler(e),n=0;for(let e of t)n+=e.getNumVertices();let a=new Float32Array(6*n),_=0;for(let e of t)_=e.addVertices(i,o,a,_);return a}_createIndices(t){let e=0;for(let r of t)e+=r.getNumTriangles();let r=new Uint32Array(3*e),i=0,s=0;for(let e of t)s=e.addIndices(i,r,s),i+=e.getNumVertices();return r}_createSubmeshes(e,r,i,s,o,n,a){if(a===s$m.AreaStatus.FULL)return [new y(e,r,i,s,o,n)];if(0==a.length)return [];if(1==o&&1==n){let t=[e,r,i,r,e,s],o=[e,s,i,r,i,s],n=this._create_clipped_polygons_submeshes(t,a),_=this._create_clipped_polygons_submeshes(o,a);return n.concat(_)}if(o>=n){let t=(i-e)/2,_=o/2,h=this._create_submeshes_sp(e,r,e+t,s,_,n,a),l=this._create_submeshes_sp(e+t,r,i,s,_,n,a);return h.concat(l)}{let t=(s-r)/2,_=n/2,h=this._create_submeshes_sp(e,r,i,r+t,o,_,a),l=this._create_submeshes_sp(e,r+t,i,s,o,_,a);return h.concat(l)}}_create_submeshes_sp(e,r,i,s,o,n,a){let _=e$b.createByRectangle(e,r,i,s),h=[];for(let e of a){if(e.includes(_)){h=s$m.AreaStatus.FULL;break}try{_.hasIntersection(e)&&h.push(e);}catch(t){}}return this._createSubmeshes(e,r,i,s,o,n,h)}_create_clipped_polygons_submeshes(t,e){let r=new e$b(t),i=[];for(let t of e)try{let e=r.getIntersection(t);null!==e&&i.push(e);}catch(t){}return i.length>0?[new v(t,i)]:[]}}i.FlakePrimitiveProducer=h;class p{constructor(t,e){let r=Math.floor(t.length/3);this._points=new Float64Array(3*r),this._num_points=r;let i,s,o=p.isCCW(t,r);!e&&o||e&&!o?(i=0,s=3):(i=3*(r-1),s=-3);for(let e=0;e<r;++e)this._points[3*e]=t[i],this._points[3*e+1]=t[i+1],this._points[3*e+2]=t[i+2],i+=s;}get points(){return this._points}get num_points(){return this._num_points}static isCCW(t,e){let r=0,i=-Number.MAX_VALUE,s=-Number.MAX_VALUE;for(let o=0;o<e;++o){let e=t[3*o],n=t[3*o+1];(n>s||n==s&&e<i)&&(r=o,i=e,s=n);}let o=r==e-1?0:r+1,n=t[3*o],a=t[3*o+1],_=0==r?e-1:r-1,h=t[3*_];return (n-i)*(t[3*_+1]-s)-(h-i)*(a-s)>0}}i.Boundary=p;class m{constructor(t){let e=t.scene.viewer,r=t.altitude_mode,i=t._getCombinedBoundaryPoints(),n=t._countNumPointsOnBoundaries(),_=Float64Array.from(i);if(r===E$4.RELATIVE){let r=e.getExistingElevation(t._getPosition());for(let t=0;t<n;++t){_[3*t+2]+=r;}}let h=null,l=null;if(0!==t.extruded_height)if(r===E$4.CLAMP){h=_,l=Float64Array.from(i);for(let t=0;t<n;++t){l[3*t+2]=0;}}else {l=_,h=Float64Array.from(i);for(let e=0;e<n;++e){let r=3*e+2;h[r]=l[r]+t.extruded_height;}}else h=_;let u=t._getPosition().getAsGocs(e$z.createVector3()),c=r$z.toGocsArray(h,n,new Float64Array(3*n));for(let t=0;t<n;++t){let e=3*t;c[e]-=u[0],c[e+1]-=u[1],c[e+2]-=u[2];}let d=null;if(l){d=r$z.toGocsArray(l,n,new Float64Array(3*n));for(let t=0;t<n;++t){let e=3*t;d[e]-=u[0],d[e+1]-=u[1],d[e+2]-=u[2];}}this.origin=u,this.num_points=n,this.upper=c,this.lower=d;}}class g extends e$9{constructor(t){super(),this._entity=t;}getInitialContent(){let t=this._entity._createTriangles()||[],e=t.length,r=this._entity._getCombinedBoundary2DPoints(),i=[];for(let s=0;s<e;s+=3){let e=t[s],o=t[s+1],n=t[s+2];this._add_polygon_to_array(r,e,o,n,i);}return i}createAreaContent(e,r,i,s){const o=Math.PI*e,n=Math.PI*r,a=Math.PI*(e+i),_=Math.PI*(r+i),h=e$b.createByRectangle(o,n,a,_);let l=[];for(let e of s){if(e.includes(h))return s$m.AreaStatus.FULL;try{h.hasIntersection(e)&&l.push(e);}catch(t){}}return l.length>0?l:s$m.AreaStatus.EMPTY}_add_polygon_to_array(t,e,r,i,o){const n=e$z.DEGREE,a=Math.PI/2,_=2*Math.PI;let h=[],l=Number.MAX_VALUE;for(let o of [e,r,i]){let e=t[2*o]*n,r=t[2*o+1]*n;if(Math.abs(r)>=a)return;let i=e,_=e$z.invGudermannian(r);h.push(i),h.push(_),l=Math.min(i,l);}let c=l-_*(Math.floor((l-Math.PI)/_)+1);(c<-Math.PI||c>=Math.PI)&&(c=-Math.PI);let d=-Number.MAX_VALUE;for(let t=0;t<3;++t){let e=2*t,r=c+(h[e]-l);h[e]=r,d=Math.max(r,d);}if(o.push(new e$b(h)),d>Math.PI){for(let t=0;t<3;++t){let e=2*t,r=h[e]-_;h[e]=r;}o.push(new e$b(h));}}}i.PolygonAreaManager=g;class f{constructor(){}}class y extends f{constructor(t,e,r,i,s,o){super(),this._x_min=t,this._y_min=e,this._x_max=r,this._y_max=i,this._div_x=s,this._div_y=o;}getNumVertices(){return (this._div_x+1)*(this._div_y+1)}getNumTriangles(){return 2*this._div_x*this._div_y}addVertices(t,e,r,i){let o=(this._x_max-this._x_min)/this._div_x,n=(this._y_max-this._y_min)/this._div_y,a=this._div_x+1,_=this._div_y+1,h=i;for(let i=0,l=this._y_min;i<_;++i,l+=n){let i=Math.exp(l),n=i*i,_=(n-1)/(n+1),u=2*i/(n+1);for(let i=0,n=this._x_min;i<a;++i,n+=o){let i=Math.sin(n),o=Math.cos(n),a=e.sample(n,l),c=e$z.EARTH_RADIUS+a,d=u*o,p=u*i,m=_,g=c*d,f=c*p,y=c*m;r[h++]=g-t[0],r[h++]=f-t[1],r[h++]=y-t[2],r[h++]=d,r[h++]=p,r[h++]=m;}}return h}addIndices(t,e,r){let i=this._div_x,s=this._div_y,o=r;for(let r=0;r<s;++r)for(let s=0;s<i;++s){var n=t+(i+1)*r+s,a=n+1,_=n+i+1,h=_+1;e[o++]=n,e[o++]=a,e[o++]=_,e[o++]=_,e[o++]=a,e[o++]=h;}return o}}class v extends f{constructor(t,e){super(),this._arit_coords=t,this._polygons=e,this._num_vertices=0,this._num_triangles=0;for(let t of e)this._num_vertices+=t.num_vertices,this._num_triangles+=t.num_vertices-2;}getNumVertices(){return this._num_vertices}getNumTriangles(){return this._num_triangles}addVertices(t,e,r,i){let s=this._get_elevation_plane(e),o=i;for(let e of this._polygons)o=this._add_polygon_vertices(e,s,t,r,o);return o}addIndices(t,e,r){let i=r,s=t;for(let t of this._polygons)i=this._add_polygon_indices(t,s,e,i),s+=t.num_vertices;return i}_add_polygon_vertices(t,e,r,i,o){let n=o,a=t.num_vertices,_=t.vertices;for(let t=0;t<a;++t){let o=_[2*t],a=_[2*t+1],h=Math.exp(a),l=h*h,u=Math.sin(o),c=Math.cos(o),d=(l-1)/(l+1),p=2*h/(l+1),m=-(o*e[0]+a*e[1]+e[3])/e[2],g=e$z.EARTH_RADIUS+m,f=p*c,y=p*u,v=d,A=g*f,P=g*y,M=g*v;i[n++]=A-r[0],i[n++]=P-r[1],i[n++]=M-r[2],i[n++]=f,i[n++]=y,i[n++]=v;}return n}_add_polygon_indices(t,e,r,i){let s=i,o=t.num_vertices-2;for(let t=1;t<=o;++t)r[s++]=e,r[s++]=e+t,r[s++]=e+t+1;return s}_get_elevation_plane(t){let e=this._arit_coords,r=new Array(3);for(let i=0;i<3;++i){let s=e[2*i],o=e[2*i+1];r[i]=t.sample(s,o);}let i=e[0],s=e[1],o=r[0],n=e[2]-i,a=e[3]-s,_=r[1]-o,h=e[4]-i,l=e[5]-s,u=r[2]-o,c=a*u-_*l,d=_*h-n*u,p=n*l-a*h;return [c,d,p,-i*c-s*d-o*p]}}function A(t,e,r){r[0]=t[e],r[1]=t[e+1],r[2]=t[e+2];}function P(t,e,r){e[r]=t[0],e[r+1]=t[1],e[r+2]=t[2];}function M(t,e,r,i){for(let i=0;i<3;++i)E[i]=e[i]-t[i],b[i]=r[i]-t[i];return e$z.cross3(E,b,i),e$z.normalize3(i,i),i}var E=e$z.createVector3(),b=e$z.createVector3();let I;!function(t){t[t.INVALID=0]="INVALID",t[t.NORMAL=1]="NORMAL",t[t.TRIANGLE_DIRTY=2]="TRIANGLE_DIRTY",t[t.MESH_DIRTY=3]="MESH_DIRTY";}(I=i.Status||(i.Status={}));}(m$2||(m$2={}));var g$3=m$2;

var o$6="/**\n * テキスト (頂点シェーダ)\n */\n\nattribute vec4 a_position;     // 頂点位置 (モデル座標系)\nattribute vec2 a_offset;       // 頂点変位 (スクリーン座標系)\nattribute vec2 a_texcoord;     // テクスチャ座標\nattribute vec2 a_texmaskcoord; // テクスチャマスク座標\nattribute vec3 a_fg_color;     // 前景色\nattribute vec3 a_bg_color;     // 背景色\n\nuniform mat4 u_obj_to_clip;    // モデル座標系からクリップ座標系への変換\nuniform vec2 u_sparam;         // 画面パラメータ: {2/w, 2/h}\n\nvarying vec2 v_texcoord;       // テクスチャ座標\nvarying vec2 v_texmaskcoord;   // テクスチャマスク座標\nvarying vec3 v_fg_color;       // 前景色\nvarying vec3 v_bg_color;       // 背景色\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    gl_Position.xy += a_offset * u_sparam * gl_Position.w;\n    v_texcoord = a_texcoord;\n    v_texmaskcoord = a_texmaskcoord;\n    v_fg_color = a_fg_color;\n    v_bg_color = a_bg_color;\n}\n";

var a$6="/**\n * テキスト (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\nvarying vec2 v_texcoord;        // アイコンのテクスチャ座標\nvarying vec2 v_texmaskcoord;    // アイコンマスクのテクスチャ座標\nvarying vec3 v_fg_color;        // 前景色\nvarying vec3 v_bg_color;        // 背景色\n\nuniform sampler2D u_image;      // アイコン画像\nuniform sampler2D u_image_mask; // アイコンマスク画像\n\n\nvoid\nmain()\n{\n    float alpha = texture2D( u_image, v_texcoord ).w;          // 輝度\n    float mask = texture2D( u_image_mask, v_texmaskcoord ).w;  // マスク\n    alpha *= mask;\n    gl_FragColor = vec4(v_fg_color * alpha + v_bg_color * (1.0 - alpha), 1.0);\n}\n";

class o$5 extends o$b{constructor(r,e={}){super(r,o$6,e.ridMaterial?n$T:a$6),this.bindProgram(),this.setInteger("u_image",o$5.TEXUNIT_IMAGE),this.setInteger("u_image_mask",o$5.TEXUNIT_IMAGE_MASK);}isTranslucent(r,e){return !1}setParameters(r,e){super.setParameters(r,e);var t=e.properties;this.setObjToClip(r,e);var a=o$5._sparam;if(a[0]=2/r._width,a[1]=2/r._height,this.setVector2("u_sparam",a),r.getRenderTarget()===l$5.RenderTarget.SCENE){var s=t.image;this.bindTexture2D(o$5.TEXUNIT_IMAGE,s.handle);var m=t.image_mask;this.bindTexture2D(o$5.TEXUNIT_IMAGE_MASK,m.handle);}}}o$5.TEXUNIT_IMAGE=0,o$5.TEXUNIT_IMAGE_MASK=1,o$5._sparam=e$z.createVector2f(),o$5._bg_color=e$z.createVector3f(),o$5._fg_color=e$z.createVector3f();

class e$7{constructor(){this._cache=new Map;}create(t){const s=this.getKey(t);let e=this._cache.get(s);return e||this._cache.set(s,e=this.doCreate(t)),e}doCreate(t){}getKey(t){return t}load(t){const s=this.create(t);return s.load(),s}}class a$5{constructor(){this._status=a$5.Status.NOT_LOADED,this._funcs=[],this._icon=null;}get status(){return this._status}isLoaded(){return this._status===a$5.Status.LOADED}onEnd(t){this._status===a$5.Status.LOADED||this._status===a$5.Status.ABORTED?t(this):this._funcs.push(t);}async load(){if(this._status===a$5.Status.NOT_LOADED){this._status=a$5.Status.LOADING;try{this._icon=await this.doLoad(),this._status=a$5.Status.LOADED;}catch(t){this._status=a$5.Status.ABORTED;}for(var t=0;t<this._funcs.length;t++)this._funcs[t](this);this._funcs.length=0;}}async doLoad(){throw new Error("doLoad() is not implemented in: "+this.constructor.name)}get icon(){return this._icon}get width(){return this._icon?this.icon.width:-1}get height(){return this._icon?this.icon.height:-1}draw(t,s,e,a,r){t.drawImage(this.icon,s,e,a,r);}}a$5.Status={NOT_LOADED:"not loaded",LOADING:"loading",LOADED:"loaded",ABORTED:"aborted"};class r$5 extends e$7{constructor(t,s){super(),this.urlPrefix=t,this.urlSuffix=s;}doCreate(t){return new i$6(this.urlPrefix+t+this.urlSuffix)}}class i$6 extends a$5{constructor(t){super(),this.url=t;}async doLoad(){return await r$t.loadImage(this.url,{crossOrigin:"Anonymous"})}}class n$i extends e$7{doCreate(t){return new o$4(t.text,t.props)}getKey(t){return t.text}}class o$4 extends a$5{constructor(t,s={}){super(),this.text=t,this.props=s;}async doLoad(){var s=this.props,e=s.size?s.size[0]:20,a=s.font_family?"'"+s.font_family+"'":r$t.SYSTEM_FONT_FAMILY,r=r$t.createCanvasContext(e,e);return r.textAlign="center",r.textBaseline="alphabetic",r.font=.6756756757*e+"px "+a,r.fillText(this.text,.5*e,.7432432432*e),r.canvas}draw(t,s,e,a,r){t.drawImage(this.icon,s,e,a,r);}}class c$2 extends e$7{doCreate(t){return new u$2(t)}}class u$2 extends a$5{constructor(t){super(),this._image_src=t;}async doLoad(){const e=this._image_src,a=e instanceof i$s?await e.load({type:i$s.Type.IMAGE}):"string"==typeof e?await r$t.loadImage(e):e instanceof HTMLImageElement?await r$t.waitForLoad(e):e instanceof HTMLCanvasElement?e:null;if(!a)throw new Error("not supported: "+e);return a}}

class g$2 extends r$7{constructor(t,i){super(t,i),this._parent_props={},this._primitive_producer=new g$2.PrimitiveProducer(this);this._animation.addDescendantUnbinder((()=>{this._unbindDescendantAnimations();})),this._setupAnimationBindingBlock(),i&&i.json&&this._setupByJson(i.json);}getPrimitiveProducer(){return this._primitive_producer}onChangeAltitudeMode(t){this._primitive_producer.onChangeAltitudeMode();}_unbindDescendantAnimations(){for(let t of this._entries)t.animation.unbindAllRecursively();}_setupAnimationBindingBlock(){const t=this.animation,i=s$u.find("number"),e=s$u.find("vector2"),r=s$u.find("vector3");t.addEntry("fg_color",[r],null,(t=>{this.setFGColor(t);})),t.addEntry("bg_color",[r],null,(t=>{this.setBGColor(t);}));const s=e$z.createVector2();let n;t.addEntry("size",[e,i],(t=>(n=t$z.findFirstTypeSupported(t,[e,i]),n)),(t=>{n===e?this.setSize(t):(s[0]=t,s[1]=t,this.setSize(s));}));}setSize(t){this._setVector2Property("size",t);}setFGColor(t){this._setVector3Property("fg_color",t);}setBGColor(t){this._setVector3Property("bg_color",t);}setFontFamily(t){this._setValueProperty("font_family",t);}addPin(t,i){return this.addTextPin("",t,i)}addMakiIconPin(t,i,e){var r=new g$2.MakiIconPinEntry(this,t,i,e);return this._entries.push(r),this._primitive_producer.onAddEntry(),r}addTextPin(t,i,e){var r=new g$2.TextPinEntry(this,t,i,e);return this._entries.push(r),this._primitive_producer.onAddEntry(),r}_getMaterial(t){var i=this.scene;if("SCENE"===t)return i._PinEntity_pin_material||(i._PinEntity_pin_material=new o$5(i.glenv)),i._PinEntity_pin_material;if("RID"===t)return i._PinEntity_pin_material_pick||(i._PinEntity_pin_material_pick=new o$5(i.glenv,{ridMaterial:!0})),i._PinEntity_pin_material_pick;throw new Error("unknown render target: "+t)}_setValueProperty(t,i){var e=this._parent_props;e[t]!=i&&(e[t]=i,this._primitive_producer.onChangeParentProperty());}_setVector3Property(t,i){var e=this._parent_props[t];e?e[0]===i[0]&&e[1]===i[1]&&e[2]===i[2]||(e$z.copyVector3(i,e),this._primitive_producer.onChangeParentProperty()):(e=this._parent_props[t]=e$z.createVector3f(i),this._primitive_producer.onChangeParentProperty());}_setVector2Property(t,i){var e=this._parent_props[t];e?e[0]===i[0]&&e[1]===i[1]||(e$z.copyVector2(i,e),this._primitive_producer.onChangeParentProperty()):(this._parent_props[t]=e$z.createVector2f(i),this._primitive_producer.onChangeParentProperty());}_setupByJson(t){var i=new r$z;for(let e of t.entries)switch(i.setFromArray(e.position),e.type){case"text":e.text?this.addTextPin(e.text,i,e):this.addPin(i,e);break;case"icon":e.maki_id?this.addMakiIconPin(e.maki_id,i,e):this.addPin(i,e);break;default:console.error("mapray: unknown pin entry type: "+e.type);}t.size&&this.setSize(t.size),t.fg_color&&this.setFGColor(t.fg_color),t.bg_color&&this.setBGColor(t.bg_color),t.font_family&&this.setFontFamily(t.font_family);}getEntry(t){return this._entries.find((i=>i.id===t))}}g$2.SAFETY_PIXEL_MARGIN=1,g$2.MAX_IMAGE_WIDTH=4096,g$2.CIRCLE_SEP_LENGTH=32,g$2.DEFAULT_SIZE=e$z.createVector2f([30,30]),g$2.DEFAULT_FONT_FAMILY="sans-serif",g$2.DEFAULT_FG_COLOR=e$z.createVector3f([1,1,1]),g$2.DEFAULT_BG_COLOR=e$z.createVector3f([.35,.61,.81]),function(s){class g extends s$m.PrimitiveProducer{constructor(t){super(t),this._dirty=!0,this._transform=e$z.setIdentity(e$z.createMatrix()),this._properties={},this._primitives=[],this._pickPrimitives=[],this._glenv=t.scene.glenv;var e=new s$h(this._glenv,null,t._getMaterial("SCENE"),this._transform);e.properties=this._properties,this._primitive=e;var r=new s$h(this._glenv,null,t._getMaterial("RID"),this._transform);r.properties=this._properties,this._pickPrimitive=r;}createRegions(){const t=new r$9;for(let{position:i}of this.getEntity()._entries)t.addPoint(i);return [t]}onChangeElevation(t){this._dirty=!0;}getPrimitives(t){return this._updatePrimitive(t),"SCENE"===t.getRenderTarget()?this._primitives:this._pickPrimitives}onChangeParentProperty(){this._dirty=!0;}onChangeChildProperty(){this._dirty=!0;}onChangeAltitudeMode(){this._dirty=!0;}onAddEntry(){this.needToCreateRegions(),this._dirty=!0;}_updatePrimitive(t){if(this._dirty){if(0==this.getEntity()._entries.length)return this._primitives=[],this._pickPrimitives=[],void(this._dirty=!1);var i=this._createFlatGocsArray();this._updateTransform(i);var r=new P(this,i);if(!r.isValid())return this._primitives=[],this._pickPrimitives=[],void(this._dirty=!1);var s=this._properties;s.image&&s.image.dispose(),s.image=r.texture,s.image_mask&&s.image_mask.dispose(),s.image_mask=r.texture_mask;var o={vtype:[{name:"a_position",size:3},{name:"a_offset",size:2},{name:"a_texcoord",size:2},{name:"a_texmaskcoord",size:2},{name:"a_fg_color",size:3},{name:"a_bg_color",size:3}],vertices:r.vertices,indices:r.indices},n=new r$h(this._glenv,o),h=this._primitive;h.mesh&&h.mesh.dispose();var _=this._pickPrimitive;_.mesh&&_.mesh.dispose(),h.mesh=n,_.mesh=n,this._primitives=[h],this._pickPrimitives=[_],this._dirty=!1;}}_updateTransform(t){var i=this.getEntity()._entries.length,e=0,r=0,s=0;for(let o=0;o<i;++o){let i=3*o;e+=t[i],r+=t[i+1],s+=t[i+2];}var o=this._transform;o[12]=e/i,o[13]=r/i,o[14]=s/i;}_createFlatGocsArray(){const t=this.getEntity()._entries.length;return r$z.toGocsArray(this._getFlatGeoPoints_with_Absolute(),t,new Float64Array(3*t))}_getFlatGeoPoints_with_Absolute(){const t=this.getEntity(),i=t._entries,e=i.length,r=new Float64Array(3*e);for(let t=0;t<e;++t){let e=i[t].position;r[3*t]=e.longitude,r[3*t+1]=e.latitude;}switch(t.altitude_mode){case E$4.RELATIVE:case E$4.CLAMP:if(t.scene.viewer.getExistingElevations(e,r,0,3,r,2,3),t.altitude_mode===E$4.RELATIVE)for(let t=0;t<e;++t)r[3*t+2]+=i[t].position.altitude;break;default:for(let t=0;t<e;++t)r[3*t+2]=i[t].position.altitude;}return r}}s.PrimitiveProducer=g;class y extends r$7.Entry{constructor(t,i,e){super(),this._owner=t,this._position=i.clone(),this._animation=new i$u,this._setupAnimationBindingBlock(),this._props=Object.assign({},e),this._copyPropertyVector3f("fg_color"),this._copyPropertyVector3f("bg_color"),this._copyPropertyVector2f("size");}_loadIcon(){throw new Error("loadIcon() is not implemented: "+this.constructor.name)}get position(){return this._position}get id(){return this._props.hasOwnProperty("id")?this._props.id:""}get size(){const t=this._props,i=this._owner._parent_props;return t.size||i.size||(this.icon?e$z.createVector2f([this.icon.width,this.icon.height]):s.DEFAULT_SIZE)}get fg_color(){const t=this._props,i=this._owner._parent_props;return t.fg_color||i.fg_color||s.DEFAULT_FG_COLOR}get bg_color(){const t=this._props,i=this._owner._parent_props;return t.bg_color||i.bg_color||s.DEFAULT_BG_COLOR}get animation(){return this._animation}_setupAnimationBindingBlock(){const t=this.animation,i=s$u.find("number"),e=s$u.find("vector2"),r=s$u.find("vector3"),s=new r$z;t.addEntry("position",[r],null,(t=>{s.setFromArray(t),this.setPosition(s);})),t.addEntry("fg_color",[r],null,(t=>{this.setFGColor(t);})),t.addEntry("bg_color",[r],null,(t=>{this.setBGColor(t);}));const h=e$z.createVector2();let _;t.addEntry("size",[e,i],(t=>(_=t$z.findFirstTypeSupported(t,[e,i]),_)),(t=>{_===e?this.setSize(t):(h[0]=t,h[1]=t,this.setSize(h));}));}setPosition(t){this._position.longitude===t.longitude&&this._position.latitude===t.latitude&&this._position.altitude===t.altitude||(this._position.assign(t),this._owner.getPrimitiveProducer().onChangeChildProperty());}setSize(t){this._setVector2Property("size",t);}setFGColor(t){this._setVector3Property("fg_color",t);}setBGColor(t){this._setVector3Property("bg_color",t);}_copyPropertyVector3f(t){var i=this._props;i.hasOwnProperty(t)&&(i[t]=e$z.createVector3f(i[t]));}_copyPropertyVector2f(t){var i=this._props;if(i.hasOwnProperty(t)){const e=i[t];i[t]="number"==typeof e?e$z.createVector2f([e,e]):e$z.createVector2f(e);}}_setVector3Property(t,i){var e=this._props[t];e?e[0]===i[0]&&e[1]===i[1]&&e[2]===i[2]||(e$z.copyVector3(i,e),this._owner.getPrimitiveProducer().onChangeChildProperty()):(e=this._props[t]=e$z.createVector3f(i),this._owner.getPrimitiveProducer().onChangeChildProperty());}_setVector2Property(t,i){var e=this._props[t];e?e[0]===i[0]&&e[1]===i[1]||(e$z.copyVector2(i,e),this._owner.getPrimitiveProducer().onChangeChildProperty()):(this._props[t]=e$z.createVector2f(i),this._owner.getPrimitiveProducer().onChangeChildProperty());}isLoaded(){return this._icon&&this._icon.isLoaded()}get icon(){return this._icon}draw(t,i,e,r,s){this._icon&&this._icon.draw(t,i,e,r,s);}}s.AbstractPinEntry=y;class v extends y{constructor(t,i,e,r={}){super(t,e,r),this.setId(i),this._setupMakiIconPinAnimationBindingBlock();}_setupMakiIconPinAnimationBindingBlock(){const t=this.animation,i=s$u.find("string");t.addEntry("id",[i],null,(t=>{this.setId(t);}));}setId(t){this._maki_id!==t&&(this._maki_id=t,this._icon=v.makiIconLoader.load(t),this._icon.onEnd((t=>{this._owner.getPrimitiveProducer()._dirty=!0;})));}}v.makiIconLoader=new r$5("https://resource.mapray.com/styles/v1/icons/maki/",".svg"),s.MakiIconPinEntry=v;class f extends y{constructor(t,i,e,r={}){super(t,e,r),this._text=i,this._renderIcon(),this._setupTextPinAnimationBindingBlock();}get font_family(){const t=this._props,i=this._owner._parent_props;return t.font_family||i.font_family||s.DEFAULT_FONT_FAMILY}_setupTextPinAnimationBindingBlock(){const t=this.animation,i=s$u.find("string");t.addEntry("text",[i],null,(t=>{this.setText(t);}));}setText(t){this._text!==t&&(this._text=t,this._renderIcon());}_renderIcon(){(this._icon=f.textIconLoader.load({text:this._text,props:{size:this.size,font_family:this.font_family}})).onEnd((t=>{this._owner.getPrimitiveProducer()._dirty=!0;}));}}f.textIconLoader=new n$i,s.TextPinEntry=f;class P{constructor(t,i){this._owner=t,this._items=this._createItemList(),this._is_valid=!0;var e=this._createRowLayouts();if(0==e.length)return this._is_valid=!1,this._vertices=[],void(this._indices=[]);var r=this._setupLocation(e);this._texture=this._createTexture(r.width,r.height),this._texture_mask=this._createTextureMask(),this._vertices=this._createVertices(r.width,r.height,i),this._indices=this._createIndices();}isValid(){return this._is_valid}get texture(){return this._texture}get texture_mask(){return this._texture_mask}get vertices(){return this._vertices}get indices(){return this._indices}_createItemList(){const t=new Map,i=[];let e=0;for(let r of this._owner.getEntity()._entries)if(r.isLoaded()){let s=t.get(r.icon);s||(t.set(r.icon,s=new E(this)),i.push(s)),s.add(e++,r);}return i}_createRowLayouts(){var t=[...this._items];t.sort((function(t,i){return t.height_pixel-i.height_pixel}));for(var i=[];t.length>0;){var e=new w(t);e.isValid()&&i.push(e);}return i}_createTexture(t,i){for(var e=r$t.createCanvasContext(t,i),s=this._items,o=0;o<s.length;++o){var n=s[o];n.is_canceled||n.draw(e);}var h=this._owner._glenv;return new t$d(h,e.canvas,{usage:"@@_Usage.ICON"})}_createTextureMask(){var t=r$t.createCanvasContext(3,3);t.fillRect(1,1,1,1);var i=this._owner._glenv,e={usage:"@@_Usage.ICON",mag_filter:i.context.NEAREST};return new t$d(i,t.canvas,e)}_createVertices(t,i,e){for(var r=[],o=this._owner._transform,n=o[12],h=o[13],_=o[14],a=1/t,p=1/i,c=this._items,d=0;d<c.length;++d){var l=c[d];if(!l.is_canceled)for(var u=0;u<l.entries.length;u++){var m=l.entries[u],g=m.entry,y=g.size,v=1.5*y[0]/2,f=1.5*y[1]/2,P=2*f,E=Math.max(2,v/10),w=3*m.index,x=e[w]-n,A=e[w+1]-h,I=e[w+2]-_,C=g.fg_color,L=g.bg_color,T=l.pos_x,k=l.pos_y,M=l.width,V=l.height,F=(t,i)=>{r.push((T+M*t)*a,1-(k+V*i)*p);};r.push(x,A,I),r.push(-E/2,P-f),F(.5-E/2/v,1.25),r.push(.25,.25),r.push(...C),r.push(...L),r.push(x,A,I),r.push(-E/2,0),F(.5-E/2/v,1.25),r.push(.25,.25),r.push(...C),r.push(...L),r.push(x,A,I),r.push(E/2,0),F(.5+E/2/v,1.25),r.push(.25,.25),r.push(...C),r.push(...L),r.push(x,A,I),r.push(E/2,P-f),F(.5+E/2/v,1.25),r.push(.25,.25),r.push(...C),r.push(...L),r.push(x,A,I),r.push(0,P),F(.5,.5),r.push(.5,.5),r.push(...C),r.push(...L);for(var G=1;G<s.CIRCLE_SEP_LENGTH;G++){var R=(G/s.CIRCLE_SEP_LENGTH*2-.5)*Math.PI,b=Math.cos(R),z=Math.sin(R);r.push(x,A,I),r.push(v*b,f*z+P),F(1.5*b/2+.5,-1.5*z/2+.5),r.push(.25*b+.5,.25*z+.5),r.push(...C),r.push(...L);}}}return r}_createIndices(){for(var t=[],i=this._items,e=0;e<i.length;++e){var r=i[e];if(!r.is_canceled)for(var o=0;o<r.entries.length;o++){var n=r.entries[o],h=(5+s.CIRCLE_SEP_LENGTH-1)*n.index,_=h,a=h+3;t.push(h,h+1,h+2),t.push(h,h+2,h+3),h+=4;var p=h++;t.push(p,_,a),t.push(p,a,h);for(var c=1;c<s.CIRCLE_SEP_LENGTH-1;c++)t.push(p,h++,h);t.push(p,h++,_);}}return t}_setupLocation(t){var i=0,e=0;e+=s.SAFETY_PIXEL_MARGIN;for(var r=0;r<t.length;++r){var o=t[r];o.locate(e),i=Math.max(o.width_assumed,i),e+=o.height_pixel+s.SAFETY_PIXEL_MARGIN;}return {width:i,height:e}}}s.Layout=P;class E{constructor(t){this.entries=[],this._pos_x=0,this._pos_y=0,this._height=-1,this._width=-1,this._is_canceled=!1;}add(t,i){var e=i.size;(-1===this.width||this.width<e[0])&&(this._width=e[0]),(-1===this.height||this.height<e[1])&&(this._height=e[1]),this.entries.push({index:t,entry:i});}get pos_x(){return this._pos_x}get pos_y(){return this._pos_y}get width(){return this._width}get height(){return this._height}get width_pixel(){return Math.ceil(this._width)}get height_pixel(){return Math.ceil(this._height)}get is_canceled(){return this._is_canceled}cancel(){this._is_canceled=!0;}locate(t,i){this._pos_x=t,this._pos_y=i;}draw(t){this.entries[0].entry.draw(t,this._pos_x,this.pos_y,this.width,this.height);}}s.LItem=E;class w{constructor(t){var i=0,e=0,r=[];let o;for(i+=s.SAFETY_PIXEL_MARGIN;o=t.shift();){var n=o.width_pixel+s.SAFETY_PIXEL_MARGIN;if(i+n<=s.MAX_IMAGE_WIDTH)r.push(o),i+=n,e=Math.max(o.height_pixel,e);else {if(0!=r.length){t.unshift(o);break}o.cancel();}}this._items=r,this._width_assumed=i,this._height_pixel=e;}isValid(){return this._items.length>0}get items(){return this._items}get width_assumed(){return this._width_assumed}get height_pixel(){return this._height_pixel}locate(t){var i=this._items,e=0;e+=s.SAFETY_PIXEL_MARGIN;for(var r=0;r<i.length;++r){var o=i[r];o.locate(e,t),e+=o.width_pixel+s.SAFETY_PIXEL_MARGIN;}}}s.RowLayout=w;}(g$2||(g$2={}));var y$1=g$2;

var n$h="/**\n * テキスト (頂点シェーダ)\n */\n\nattribute vec4 a_position;     // 頂点位置 (モデル座標系)\nattribute vec2 a_offset;       // 頂点変位 (スクリーン座標系)\nattribute vec2 a_texcoord;     // テクスチャ座標\n\nuniform mat4 u_obj_to_clip;    // モデル座標系からクリップ座標系への変換\nuniform vec2 u_sparam;         // 画面パラメータ: {2/w, 2/h}\n\nvarying vec2 v_texcoord;       // テクスチャ座標\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    gl_Position.xy += a_offset * u_sparam * gl_Position.w;\n    v_texcoord = a_texcoord;\n}\n";

var n$g="/**\n * テキスト (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\nvarying vec2 v_texcoord;        // テクスチャ座標\nuniform sampler2D u_image;      // 画像\n\n\nvoid\nmain()\n{\n    gl_FragColor = texture2D( u_image, v_texcoord );\n}\n";

class o$3 extends o$b{constructor(r,e={}){super(r,n$h,e.ridMaterial?n$T:n$g),this.bindProgram(),this.setInteger("u_image",o$3.TEXUNIT_IMAGE);}isTranslucent(r,e){return !1}setParameters(r,e){super.setParameters(r,e);var t=e.properties;this.setObjToClip(r,e);var a=o$3._sparam;if(a[0]=2/r._width,a[1]=2/r._height,this.setVector2("u_sparam",a),r.getRenderTarget()===l$5.RenderTarget.SCENE){var s=t.image;this.bindTexture2D(o$3.TEXUNIT_IMAGE,s.handle);}}}o$3.TEXUNIT_IMAGE=0,o$3._sparam=e$z.createVector2f(),o$3._bg_color=e$z.createVector3f(),o$3._fg_color=e$z.createVector3f();

class l$2 extends r$7{constructor(t,i={}){super(t,i),this._parent_props={size:void 0,origin:void 0},this._primitive_producer=new l$2.PrimitiveProducer(this);this._animation.addDescendantUnbinder((()=>{this._unbindDescendantAnimations();})),this._setupAnimationBindingBlock(),i&&i.json&&this._setupByJson(i.json);}getPrimitiveProducer(){return this._primitive_producer}_unbindDescendantAnimations(){for(let t of this._entries)t.animation.unbindAllRecursively();}_setupAnimationBindingBlock(){const t=this._animation,i=s$u.find("number"),e=s$u.find("vector2"),r=e$z.createVector2();let s;t.addEntry("size",[e,i],(t=>(s=t$z.findFirstTypeSupported(t,[e,i]),s)),(t=>{s===e?this.setSize(t):(r[0]=t,r[1]=t,this.setSize(r));}));}setSize(t){this._setVector2Property("size",t);}setOrigin(t){this._setVector2Property("origin",t);}get parent_props(){return this._parent_props}addImageIcon(t,i,e={}){var r=new l$2.ImageEntry(this,t,i,e);return this._entries.push(r),this._primitive_producer.onAddEntry(),r}_getMaterial(t){var i=this.scene;if("SCENE"===t)return i._ImageEntity_image_material||(i._ImageEntity_image_material=new o$3(i.glenv)),i._ImageEntity_image_material;if("RID"===t)return i._ImageEntity_image_material_pick||(i._ImageEntity_image_material_pick=new o$3(i.glenv,{ridMaterial:!0})),i._ImageEntity_image_material_pick;throw new Error("unknown render target: "+t)}_setValueProperty(t,i){var e=this._parent_props;e[t]!=i&&(e[t]=i,this._primitive_producer.onChangeParentProperty());}_setVector2Property(t,i){var e=this._parent_props[t];e?e[0]===i[0]&&e[1]===i[1]||(e$z.copyVector2(i,e),this._primitive_producer.onChangeParentProperty()):(this._parent_props[t]=e$z.createVector2f(i),this._primitive_producer.onChangeParentProperty());}_setupByJson(t){var i=new r$z;for(let e of t.entries)i.setFromArray(e.position),this.addImageIcon(e.image_src,i,e);t.size&&this.setSize(t.size),t.origin&&this.setOrigin(t.origin);}getEntry(t){return this._entries.find((i=>i.id===t))}}!function(s){s.DEFAULT_COLOR=e$z.createVector3f([1,1,1]),s.SAFETY_PIXEL_MARGIN=1,s.MAX_IMAGE_WIDTH=4096,s.CIRCLE_SEP_LENGTH=32,s.DEFAULT_ICON_SIZE=e$z.createVector2f([30,30]),s.DEFAULT_ORIGIN=e$z.createVector2f([.5,.5]);s.Props=class{};class l extends s$m.PrimitiveProducer{constructor(t){super(t),this._glenv=t.scene.glenv,this._dirty=!0,this._transform=e$z.setIdentity(e$z.createMatrix()),this._properties={image:null};var e=new s$h(this._glenv,null,t._getMaterial("SCENE"),this._transform);e.properties=this._properties,this._primitive=e;var r=new s$h(this._glenv,null,t._getMaterial("RID"),this._transform);r.properties=this._properties,this._pickPrimitive=r,this._primitives=[],this._pickPrimitives=[];}getEntity(){return super.getEntity()}createRegions(){const t=new r$9;for(let{position:i}of this.getEntity().entries)t.addPoint(i);return [t]}onChangeElevation(t){this._dirty=!0;}getPrimitives(t){return this._updatePrimitive(),"SCENE"===t.getRenderTarget()?this._primitives:this._pickPrimitives}onChangeParentProperty(){this._dirty=!0;}onChangeChildProperty(){this._dirty=!0;}onChangeAltitudeMode(){this._dirty=!0;}onAddEntry(){this.needToCreateRegions(),this._dirty=!0;}onImageLoaded(t){this._dirty=!0;}get transform(){return this._transform}_updatePrimitive(){if(this._dirty){if(0==this.getEntity().entries.length)return this._primitives=[],this._pickPrimitives=[],void(this._dirty=!1);var t=this._createFlatGocsArray();this._updateTransform(t);var i=new f(this,t);if(!i.isValid())return this._primitives=[],this._pickPrimitives=[],void(this._dirty=!1);var r=this._properties;r.image&&r.image.dispose(),r.image=i.texture;var s={vtype:[{name:"a_position",size:3},{name:"a_offset",size:2},{name:"a_texcoord",size:2}],vertices:i.vertices,indices:i.indices},n=new r$h(this._glenv,s),o=this._primitive;o.mesh&&o.mesh.dispose(),o.mesh=n;var h=this._pickPrimitive;h.mesh&&h.mesh.dispose(),h.mesh=n,this._primitives=[o],this._pickPrimitives=[h],this._dirty=!1;}}_updateTransform(t){var i=this.getEntity().entries.length,e=0,r=0,s=0;for(let n=0;n<i;++n){let i=3*n;e+=t[i],r+=t[i+1],s+=t[i+2];}var n=this._transform;n[12]=e/i,n[13]=r/i,n[14]=s/i;}_createFlatGocsArray(){const t=this.getEntity().entries.length;return r$z.toGocsArray(this._getFlatGeoPoints_with_Absolute(),t,new Float64Array(3*t))}_getFlatGeoPoints_with_Absolute(){const t=this.getEntity(),i=t.entries,e=i.length,r=new Float64Array(3*e);for(let t=0;t<e;++t){let e=i[t].position;r[3*t]=e.longitude,r[3*t+1]=e.latitude;}switch(t.altitude_mode){case E$4.RELATIVE:case E$4.CLAMP:if(t.scene.viewer.getExistingElevations(e,r,0,3,r,2,3),t.altitude_mode===E$4.RELATIVE)for(let t=0;t<e;++t)r[3*t+2]+=i[t].position.altitude;break;default:for(let t=0;t<e;++t)r[3*t+2]=i[t].position.altitude;}return r}}s.PrimitiveProducer=l;class v extends r$7.Entry{constructor(t,i,e,r){super(),this._owner=t,this._position=e.clone(),this._animation=new i$u,this._setupAnimationBindingBlock(),this._props=Object.assign({},r),this._copyPropertyVector2f("size"),this._copyPropertyVector2f("origin"),this.setImage(i);}get animation(){return this._animation}get position(){return this._position}get id(){return this._props.id||""}get size(){const t=this._props,i=this._owner.parent_props,e=this._icon;return t.size||i.size||(e?e$z.createVector2f([e.width,e.height]):e$z.createVector2f([0,0]))}get origin(){const t=this._props,i=this._owner.parent_props;return t.origin||i.origin||s.DEFAULT_ORIGIN}_setupAnimationBindingBlock(){const t=this.animation,i=s$u.find("number"),e=s$u.find("string"),r=s$u.find("vector2"),s=s$u.find("vector3");t.addEntry("image_src",[e],null,(t=>{this.setImage(t);}));const h=new r$z;t.addEntry("position",[s],null,(t=>{h.setFromArray(t),this.setPosition(h);}));const a=e$z.createVector2();let _;t.addEntry("size",[r,i],(t=>(_=t$z.findFirstTypeSupported(t,[r,i]),_)),(t=>{_===r?this.setSize(t):(a[0]=t,a[1]=t,this.setSize(a));}));}setImage(t){if(this._image_src!==t){this._image_src=t;const i=new s$p("string"==typeof t?t:r$t.toBase64String(t),{transform:this._props.transform});this._icon=s.iconLoader.load(i),this._icon.onEnd((t=>{const i=this._owner.getPrimitiveProducer();i&&i.onImageLoaded(this._icon);}));}}setPosition(t){if(this._position.longitude!==t.longitude||this._position.latitude!==t.latitude||this._position.altitude!==t.altitude){this._position.assign(t);const i=this._owner.getPrimitiveProducer();i&&i.onChangeChildProperty();}}setSize(t){this._setVector2Property("size",t);}_copyPropertyVector3f(t){var i=this._props;i.hasOwnProperty(t)&&(i[t]=e$z.createVector3f(i[t]));}_copyPropertyVector2f(t){var i=this._props;if(i.hasOwnProperty(t)){const e=i[t];i[t]=e$z.createVector2f(e);}}_setVector2Property(t,i){var e=this._props[t];if(e){if(e[0]!==i[0]||e[1]!==i[1]){e$z.copyVector2(i,e);const t=this._owner.getPrimitiveProducer();t&&t.onChangeChildProperty();}}else {this._props[t]=e$z.createVector2f(i);const e=this._owner.getPrimitiveProducer();e&&e.onChangeChildProperty();}}isLoaded(){return this._icon.isLoaded()}get icon(){return this._icon}draw(t,i,e,r,s){this._icon.draw(t,i,e,r,s);}}s.ImageEntry=v,s.iconLoader=new c$2;class f{constructor(t,i){this._owner=t,this._items=this._createItemList(),this._is_valid=!0;var e=this._createRowLayouts();if(0==e.length)return this._is_valid=!1,this._vertices=[],void(this._indices=[]);var r=this._setupLocation(e);this._texture=this._createTexture(r.width,r.height),this._vertices=this._createVertices(r.width,r.height,i),this._indices=this._createIndices();}isValid(){return this._is_valid}get texture(){return this._texture}get vertices(){return this._vertices}get indices(){return this._indices}_createItemList(){const t=new Map,i=[];let e=0;for(let r of this._owner.getEntity().entries)if(r.isLoaded()){let s=t.get(r.icon);s||(t.set(r.icon,s=new y(this)),i.push(s)),s.add(e++,r);}return i}_createRowLayouts(){var t=this._items.slice();t.sort((function(t,i){return t.height_pixel-i.height_pixel}));for(var i=[];t.length>0;){var e=new w(t);e.isValid()&&i.push(e);}return i}_createTexture(t,i){for(var e=r$t.createCanvasContext(t,i),s=this._items,n=0;n<s.length;++n){var o=s[n];o.is_canceled||o.draw(e);}var h=this._owner.getEntity().scene.glenv;return new t$d(h,e.canvas,{usage:"@@_Usage.ICON"})}_createVertices(t,i,e){for(var r=[],s=this._owner.transform,n=s[12],o=s[13],h=s[14],a=1/t,_=1/i,p=this._items,c=0;c<p.length;++c){var d=p[c];if(!d.is_canceled)for(var g=0;g<d.entries.length;g++){var m=d.entries[g],u=m.entry,l=u.size,v=u.origin,f=3*m.index,y=e[f]-n,w=e[f+1]-o,E=e[f+2]-h,P=d.pos_x,I=d.pos_y,A=d.width,x=d.height;r.push(y,w,E),r.push(-v[0]*l[0],v[1]*l[1]),r.push(P*a,1-I*_),r.push(y,w,E),r.push(-v[0]*l[0],-(1-v[1])*l[1]),r.push(P*a,1-(I+x)*_),r.push(y,w,E),r.push((1-v[0])*l[0],-(1-v[1])*l[1]),r.push((P+A)*a,1-(I+x)*_),r.push(y,w,E),r.push((1-v[0])*l[0],v[1]*l[1]),r.push((P+A)*a,1-I*_);}}return r}_createIndices(){for(var t=[],i=this._items,e=0;e<i.length;++e){var r=i[e];if(!r.is_canceled)for(var s=0;s<r.entries.length;s++){var n=4*r.entries[s].index;t.push(n,n+1,n+2),t.push(n,n+2,n+3);}}return t}_setupLocation(t){var i=0,e=0;e+=s.SAFETY_PIXEL_MARGIN;for(var r=0;r<t.length;++r){var n=t[r];n.locate(e),i=Math.max(n.width_assumed,i),e+=n.height_pixel+s.SAFETY_PIXEL_MARGIN;}return {width:i,height:e}}}class y{constructor(t){this.entries=[],this._pos_x=0,this._pos_y=0,this._is_canceled=!1;}add(t,i){var e=i.size;(void 0===this._width||this._width<e[0])&&(this._width=e[0]),(void 0===this._height||this._height<e[1])&&(this._height=e[1]),this.entries.push({index:t,entry:i});}get pos_x(){return this._pos_x}get pos_y(){return this._pos_y}get width(){return void 0===this._width?0:this._width}get height(){return void 0===this._height?0:this._height}get width_pixel(){return void 0===this._width?0:Math.ceil(this._width)}get height_pixel(){return void 0===this._height?0:Math.ceil(this._height)}get is_canceled(){return this._is_canceled}cancel(){this._is_canceled=!0;}locate(t,i){this._pos_x=t,this._pos_y=i;}draw(t){this.entries[0].entry.draw(t,this._pos_x,this.pos_y,this.width,this.height);}}class w{constructor(t){var i=0,e=0,r=[];for(i+=s.SAFETY_PIXEL_MARGIN;t.length>0;){var n=t.shift(),o=n.width_pixel+s.SAFETY_PIXEL_MARGIN;if(i+o<=s.MAX_IMAGE_WIDTH)r.push(n),i+=o,e=Math.max(n.height_pixel,e);else {if(0!=r.length){t.unshift(n);break}n.cancel();}}this._items=r,this._width_assumed=i,this._height_pixel=e;}isValid(){return this._items.length>0}get items(){return this._items}get width_assumed(){return this._width_assumed}get height_pixel(){return this._height_pixel}locate(t){var i=this._items,e=0;e+=s.SAFETY_PIXEL_MARGIN;for(var r=0;r<i.length;++r){var n=i[r];n.locate(e,t),e+=n.width_pixel+s.SAFETY_PIXEL_MARGIN;}}}}(l$2||(l$2={}));var v=l$2;

class s$4{constructor(e,a,r={}){if(this._scene=e,!(a instanceof i$s))throw new Error("Unsupported Resource Type: "+a);this._resource=a,this._status=s$4.Status.NOT_LOADED,this._onLoad=r.onLoad||s$4.defaultOnLoadCallback,this._onEntity=r.onEntity||s$4.defaultOnEntityCallback;}get scene(){return this._scene}get resource(){return this._resource}get status(){return this._status}_setStatus(t){this._status=t;}load(){return this.status!==s$4.Status.NOT_LOADED?Promise.reject(new Error("Illegal Status: "+this.status)):Promise.resolve().then((()=>(this._setStatus(s$4.Status.LOADING),this.scene.addLoader(this),this._load()))).catch((t=>{throw console.log(t),this._scene.removeLoader(this),this._onLoad(this,!1),this._status!==s$4.Status.CANCELED&&this._setStatus(s$4.Status.ABORTED),t})).then((t=>{if(this._scene.removeLoader(this),this._status===s$4.Status.CANCELED)throw this._onLoad(this,!1),new Error("canceled");return this._setStatus(s$4.Status.LOADED),this._onLoad(this,!0),t}))}cancel(){this._status!==s$4.Status.LOADING&&this._status!==s$4.Status.LOADED||(this._setStatus(s$4.Status.CANCELED),this._resource.cancel(),this._cancel());}_cancel(){}_check_cancel(){if(this.status===s$4.Status.CANCELED)throw new Error("canceled")}}!function(t){var s;(s=t.Status||(t.Status={}))[s.NOT_LOADED=0]="NOT_LOADED",s[s.LOADING=1]="LOADING",s[s.LOADED=2]="LOADED",s[s.CANCELED=3]="CANCELED",s[s.ERROR=4]="ERROR",s[s.ABORTED=5]="ABORTED",t.defaultOnLoadCallback=function(t,s){},t.defaultOnEntityCallback=function(t,s,e){t.scene.addEntity(s);};}(s$4||(s$4={}));var e$6=s$4;

var n$f="attribute vec4 a_position;    // 位置 (モデル座標系)\nattribute vec3 a_normal;      // 法線 (モデル座標系)\nattribute vec2 a_texcoord;    // テクスチャ座標\n\nuniform mat4  u_obj_to_clip;  // モデル座標系からクリップ座標系への変換\nuniform mat4  u_obj_to_view;  // モデル座標系から視点座標系への変換\n\nvarying vec3  v_normal;       // 法線 (視点座標系)\nvarying vec2  v_texcoord;     // テクスチャ座標\n\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n\n#ifndef UNLIT\n    v_normal = normalize( vec3( u_obj_to_view * vec4( a_normal, 0.0 ) ) );  // 法線 (視点座標系)\n#endif\n\n    v_texcoord = a_texcoord;\n}\n";

var n$e="precision highp float;\n\nvarying vec3  v_normal;    // 法線 (視点座標系)\nvarying vec2  v_texcoord;  // テクスチャ座標\n\nuniform vec3      u_light_dir;   // ライト逆方向 (視点座標系) と強さ\nuniform vec4      u_base_color;  // 基本色係数\nuniform sampler2D u_base_image;  // 基本色画像\n\n\nvoid\nmain()\n{\n#ifndef UNLIT\n    vec3 normal = normalize( v_normal );  // 法線 (視点座標系)\n\n    vec3 dlit = vec3( dot( normal, u_light_dir ) );  // 拡散光の強さ\n#else\n    vec3 dlit = vec3( 1.0 );\n#endif\n\n    gl_FragColor = u_base_color * texture2D( u_base_image, v_texcoord ) * vec4( dlit, 1.0 );\n}\n";

class a$4 extends o$b{constructor(e,o={}){const l=a$4._getPreamble(o);super(e,l+n$f,l+(o.ridMaterial?n$T:n$e)),this._white_texture=new t$d(e,null,{usage:t$d.Usage.COLOR,color:[1,1,1,1]}),this.bindProgram(),this.setInteger("u_base_image",a$4.TEXUNIT_BASE_IMAGE);}setParameters(e,t){super.setParameters(e,t);var r=t.properties.pbrMetallicRoughness;if(this.setObjToClip(e,t),this.setObjToView(e,t),e.getRenderTarget()===l$5.RenderTarget.SCENE){var s=r.baseColorFactor;const t=e.getTranslucentMode()?[.5*s[0],.5*s[1],.5*s[2],.5*s[3]]:s;this.setVector4("u_base_color",t),this.setVector3("u_light_dir",[0,0,1]);var i=this._selectTexture(r.baseColorTexture,this._white_texture);this.bindTexture2D(a$4.TEXUNIT_BASE_IMAGE,i.handle);}}_selectTexture(e,t){return null!==e?e.texture:t}static _getPreamble(e){let t=[];return void 0!==e.is_unlit&&e.is_unlit&&t.push("#define UNLIT"),t.join("\n")+"\n\n"}}a$4.TEXUNIT_BASE_IMAGE=0;

class r$4{constructor(t,i){var e="number"==typeof i?t.gjson.samplers[i]:{};this._magFilter=e.magFilter,this._minFilter=e.minFilter,this._wrapS=void 0!==e.wrapS?e.wrapS:r$4.WRAP_DEFAULT,this._wrapT=void 0!==e.wrapT?e.wrapT:r$4.WRAP_DEFAULT;}get magFilter(){return this._magFilter}get minFilter(){return this._minFilter}get wrapS(){return this._wrapS}get wrapT(){return this._wrapT}}r$4.WRAP_DEFAULT=10497;

class e$5{constructor(e,s){var t=e.gjson.textures[s];this._sampler=new r$4(e,t.sampler),this._source=e.findImage(t.source);}get source(){return this._source}get sampler(){return this._sampler}}

class e$4{constructor(e,r){this._texture=new e$5(r,e.index),this._texCoord=void 0!==e.texCoord?e.texCoord:0;}get texture(){return this._texture}set texture(t){this._texture=t;}get texCoord(){return this._texCoord}}

class s$3 extends e$4{constructor(e,s){super(e,s),this._scale=void 0!==e.scale?e.scale:1;}get texCoord(){return this._scale}}

class e$3 extends e$4{constructor(t,e){super(t,e),this._strength=void 0!==t.strength?t.strength:1;}get strength(){return this._strength}}

class l$1{constructor(t,r){this._entries=[],this._name_map={},this._default=null,this._offset_transform=e$z.setIdentity(e$z.createMatrix());const i={};for(const e of r.scenes){const r=new u$1(t,e,i);this._entries.push(r),null!==e.name&&(this._name_map[e.name]=r);}if(r.default_scene_index>=0){if(!(r.default_scene_index<this._entries.length))throw new Error("default_scene_index is out of range");this._default=this._entries[r.default_scene_index];}else this._entries.length>=1&&(this._default=this._entries[0]);}static getSupportedExtensions_glTF(){return ["KHR_materials_unlit"]}setOffsetTransform(t){e$z.copyMatrix(t,this._offset_transform);}createPrimitives(t,r){const i=this._getEntry(t);if(null===i)return null;const a=[];for(const t of i.getPrimitives(r)){const r=t.fastClone();e$z.mul_AA(this._offset_transform,r.transform,r.transform),r.properties=_$2.fastCloneProperties(r.properties),a.push(r);}return a}_getEntry(e){if("number"==typeof e){if(0<=e&&e<this._entries.length)return this._entries[e]}else if("string"==typeof e){if(this._name_map.hasOwnProperty(e))return this._name_map[e]}else if(this._entries.length>0)return this._entries[0];return null}}class u$1{constructor(e,t,r){this._builder=new _$2(e,t,r);}getPrimitives(e){return this._builder.getPrimitives(e)}}class _$2{constructor(t,r,i){i.buffer_map||(i.buffer_map=new Map,i.texture_map=new Map),this._mr_scene=t,this._glenv=t.glenv,this._primitives=[],this._pickPrimitives=[],this._buffer_map=i.buffer_map,this._texture_map=i.texture_map;var a=e$z.setIdentity(e$z.createMatrix());for(var s of r.root_nodes)this._addNode(s,a);}getPrimitives(e={}){return e.ridMaterial?this._pickPrimitives:this._primitives}_addNode(e,t){var r=_$2._getNodeToScene(e,t);if(null!==e.mesh)for(var i of e.mesh.primitives)this._primitives.push(this._createPrimitive(i,r,{ridMaterial:!1})),this._pickPrimitives.push(this._createPrimitive(i,r,{ridMaterial:!0}));for(var a of e.children)this._addNode(a,r);}static _getNodeToScene(t,r){var i=r,a=t.matrix;return null!==a&&(i=e$z.createMatrix(),e$z.mul_AA(r,a,i)),i}_createPrimitive(r,i,a={}){var s=this._createMesh(r),o=this._createMaterial(r,{ridMaterial:a.ridMaterial}),n=new s$h(this._glenv,s,o,e$z.createMatrix(i));return n.pivot=this._createMeshPivot(r),n.bbox=this._createBoundingBox(r),n.properties=this._createProperties(r),n}_createMesh(e){var t=new r$h.Initializer(_$2._convertPrimitiveMode(e),_$2._calcNumVertices(e)),i=e.attributes;for(var a in i)this._addAttribToInit(t,a,i[a]);var s=e.indices;return null!==s&&this._addIndexToInit(t,s),new r$h(this._glenv,t)}static _convertPrimitiveMode(e){return _$2._DrawMode[e.mode]}static _calcNumVertices(e){var t=e.attributes,r=[];for(var i in t){var a=t[i];r.push(a.count);}return Math.min.apply(null,r)}_addAttribToInit(e,t,r){var a=this._findMeshBuffer(r.bufferView.buffer,t$o.Target.ATTRIBUTE),s=_$2._NumComponents[r.type],o=_$2._ComponentType[r.componentType],n={normalized:r.normalized,byte_stride:r.bufferView.byteStride,byte_offset:r.bufferView.byteOffset+r.byteOffset},l=_$2._VertexAttribId[t]||t;e.addAttribute(l,a,s,o,n);}_addIndexToInit(e,t){var r=this._findMeshBuffer(t.bufferView.buffer,t$o.Target.INDEX),a=t.count,s=_$2._ComponentType[t.componentType],o={byte_offset:t.bufferView.byteOffset+t.byteOffset};e.addIndex(r,a,s,o);}_findMeshBuffer(e,t){var r=this._buffer_map.get(e);return void 0===r&&(r=new t$o(this._glenv,e.binary,{target:t}),this._buffer_map.set(e,r)),r}_createMaterial(e,t={}){let r="basic",i={};e.material&&e.material.commonData.getExtensions("KHR_materials_unlit")&&(r="unlit",i.is_unlit=!0),t.ridMaterial&&(i.ridMaterial=!0);const a=this._mr_scene,o="_ModelEntity_model_material_"+r+(t.ridMaterial?"_pick":"");return a[o]||(a[o]=new a$4(a.glenv,i)),a[o]}_createMeshPivot(t){var r=null,i=this._createBoundingBox(t);if(null!==i){r=e$z.createVector3();for(var a=0;a<3;++a)r[a]=(i[0][a]+i[1][a])/2;}return r}_createBoundingBox(t){var r=null,i=t.attributes.POSITION;if(void 0!==i){var a=i.min,s=i.max;null!==a&&null!==s&&(r=[e$z.createVector3(a),e$z.createVector3(s)]);}return r}_createProperties(t){var r=t.material;if(null===r)return {pbrMetallicRoughness:{baseColorFactor:e$z.createVector4f([1,1,1,1]),baseColorTexture:null,metallicFactor:1,roughnessFactor:1,metallicRoughnessTexture:null},doubleSided:!1,alphaMode:"OPAQUE",alphaCutoff:.5,emissiveFactor:e$z.createVector3f([0,0,0]),emissiveTexture:null,normalTexture:null,occlusionTexture:null};{const t=r.pbrMetallicRoughness;return {pbrMetallicRoughness:{baseColorFactor:e$z.createVector4f(t.baseColorFactor),baseColorTexture:this._createTextureParam(t.baseColorTexture),metallicFactor:t.metallicFactor,roughnessFactor:t.roughnessFactor,metallicRoughnessTexture:this._createTextureParam(t.metallicRoughnessTexture)},doubleSided:r.doubleSided,alphaMode:r.alphaMode,alphaCutoff:r.alphaCutoff,emissiveFactor:e$z.createVector3f(r.emissiveFactor),emissiveTexture:this._createTextureParam(r.emissiveTexture),normalTexture:this._createTextureParam(r.normalTexture),occlusionTexture:this._createTextureParam(r.occlusionTexture)}}}_createTextureParam(e){if(null===e)return null;var t={texture:this._findTexture(e.texture),texCoord:e.texCoord};return e instanceof s$3?t.scale=e.scale:e instanceof e$3&&(t.strength=e.strength),t}static fastCloneProperties(t){const r=t.pbrMetallicRoughness;return {pbrMetallicRoughness:{baseColorFactor:e$z.createVector3f(r.baseColorFactor),baseColorTexture:_$2._fastCloneTextureParam(r.baseColorTexture),metallicFactor:r.metallicFactor,roughnessFactor:r.roughnessFactor,metallicRoughnessTexture:_$2._fastCloneTextureParam(r.metallicRoughnessTexture)},doubleSided:t.doubleSided,alphaMode:t.alphaMode,alphaCutoff:t.alphaCutoff,emissiveFactor:e$z.createVector3f(t.emissiveFactor),emissiveTexture:_$2._fastCloneTextureParam(t.emissiveTexture),normalTexture:_$2._fastCloneTextureParam(t.normalTexture),occlusionTexture:_$2._fastCloneTextureParam(t.occlusionTexture)}}static _fastCloneTextureParam(e){if(null===e)return null;var t={texture:e.texture,texCoord:e.texCoord};return "scale"in e?t.scale=e.scale:"strength"in e&&(t.strength=e.strength),t}_findTexture(e){var t=this._texture_map.get(e);if(void 0===t){var r=e.sampler,i=this._glenv.context,s={mag_filter:void 0!==r.magFilter?r.magFilter:i.LINEAR,min_filter:void 0!==r.minFilter?r.minFilter:i.LINEAR_MIPMAP_LINEAR,wrap_s:r.wrapS,wrap_t:r.wrapT,flip_y:!1};t=new t$d(this._glenv,e.source.image,s),this._texture_map.set(e,t);}return t}}_$2._DrawMode={0:r$h.DrawMode.POINTS,1:r$h.DrawMode.LINES,2:r$h.DrawMode.LINE_LOOP,3:r$h.DrawMode.LINE_STRIP,4:r$h.DrawMode.TRIANGLES,5:r$h.DrawMode.TRIANGLE_STRIP,6:r$h.DrawMode.TRIANGLE_FAN},_$2._NumComponents={SCALAR:1,VEC2:2,VEC3:3,VEC4:4},_$2._ComponentType={5120:r$h.ComponentType.BYTE,5121:r$h.ComponentType.UNSIGNED_BYTE,5122:r$h.ComponentType.SHORT,5123:r$h.ComponentType.UNSIGNED_SHORT,5125:r$h.ComponentType.UNSIGNED_INT,5126:r$h.ComponentType.FLOAT},_$2._VertexAttribId={POSITION:"a_position",NORMAL:"a_normal",TANGENT:"a_tangent",TEXCOORD_0:"a_texcoord",TEXCOORD_1:"a_texcoord1",COLOR_0:"a_color"};

class t$8{constructor(t,s){this._name=t.name||null,this._extensions=s.extractUsedExtensions(t.extensions||{}),this._extras=t.extras||{};}getName(){return this._name}getExtensions(t){const s=this._extensions[t];return void 0!==s?s:null}getExtras(t){const s=this._extras[t];return void 0!==s?s:null}}

class t$7{constructor(t,s,n){this._commonData=new t$8(t.gjson,t),this._scenes=s,this._default_scene_index=n;}get commonData(){return this._commonData}get scenes(){return this._scenes}get default_scene_index(){return this._default_scene_index}}

class t$6{constructor(t,e){var f=t.gjson.bufferViews[e];this._buffer=t.findBuffer(f.buffer),this._byteLength=f.byteLength,this._target=f.target,this._byteOffset=void 0!==f.byteOffset?f.byteOffset:0,this._byteStride=void 0!==f.byteStride?f.byteStride:0;}get buffer(){return this._buffer}get byteOffset(){return this._byteOffset}get byteStride(){return this._byteStride}rebuildBySplitter(t){this._buffer=t,this._byteLength=t.byteLength,this._byteOffset=0;}}

class e$2{constructor(e,r){var i=e.gjson.accessors[r];this._type=i.type,this._componentType=i.componentType,this._count=i.count,this._bufferView=new t$6(e,i.bufferView),this._byteOffset=void 0!==i.byteOffset?i.byteOffset:0,this._normalized=i.normalized||!1,this._min=i.min?i.min.slice():null,this._max=i.max?i.max.slice():null,this._index=r;}get index(){return this._index}get bufferView(){return this._bufferView}get type(){return this._type}get componentType(){return this._componentType}get count(){return this._count}get byteOffset(){return this._byteOffset}get normalized(){return this._normalized}get min(){return this._min}get max(){return this._max}getRangeInBuffer(){var t=this._bufferView,r=e$2._ComponentData[this._componentType].bytes*e$2._NumComponents[this._type],i=0==t.byteStride?r:t.byteStride,s=this._byteOffset+t.byteOffset;return {first:s,last:s+i*(this._count-1)+r}}modifyByteOrder(t){var r=e$2._ComponentData[this._componentType],i=r.bytes;if(1!=i)for(var s=e$2._NumComponents[this._type],n=this._byteOffset+this._bufferView.byteOffset,o=0==this._bufferView.byteStride?s:this._bufferView.byteStride/i,y=this._bufferView.buffer.binary,a=new DataView(y,n),f=new r.typedarray(y,n),p=r.getcompo,_=i/2,b=n/2,u=o*_,m=0;m<this._count;++m)for(var h=b+m*u,c=m*o,d=0;d<s;++d){var g=h+d*_;if(!t.getBit(g)){var w=c+d,V=p.call(a,w*i,!0);f[w]=V,t.setBit(g,!0);}}}isIncluded(t,e){var r=this._byteOffset+this._bufferView.byteOffset;return t<=r&&r<e}rebuildBySplitter(t,e){this._index=-1;var r=this._byteOffset+this._bufferView.byteOffset;this._byteOffset=r-e,this._bufferView.rebuildBySplitter(t);}}e$2._NumComponents={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},e$2._ComponentData={5120:{bytes:1,getcompo:DataView.prototype.getInt8,typedarray:Int8Array},5121:{bytes:1,getcompo:DataView.prototype.getUint8,typedarray:Uint8Array},5122:{bytes:2,getcompo:DataView.prototype.getInt16,typedarray:Int16Array},5123:{bytes:2,getcompo:DataView.prototype.getUint16,typedarray:Uint16Array},5125:{bytes:4,getcompo:DataView.prototype.getUint32,typedarray:Uint32Array},5126:{bytes:4,getcompo:DataView.prototype.getFloat32,typedarray:Float32Array}};

class r$3{constructor(e,t){const o=e.gjson.materials[t];this._commonData=new t$8(o,e),this._pbrMetallicRoughness={baseColorFactor:[1,1,1,1],baseColorTexture:null,metallicFactor:1,roughnessFactor:1,metallicRoughnessTexture:null},this._doubleSided=!1,this._alphaMode="OPAQUE",this._alphaCutoff=.5,this._emissiveFactor=[0,0,0],this._emissiveTexture=null,this._normalTexture=null,this._occlusionTexture=null,this._setupPbrMetallicRoughness(o,e),this._setupGenericParameters(o,e);}get commonData(){return this._commonData}get pbrMetallicRoughness(){return this._pbrMetallicRoughness}get doubleSided(){return this._doubleSided}get alphaMode(){return this._alphaMode}get alphaCutoff(){return this._alphaCutoff}get emissiveFactor(){return this._emissiveFactor}get emissiveTexture(){return this._emissiveTexture}get normalTexture(){return this._normalTexture}get occlusionTexture(){return this._occlusionTexture}_setupPbrMetallicRoughness(t,o){if(void 0!==t.pbrMetallicRoughness){var s=t.pbrMetallicRoughness,r=this._pbrMetallicRoughness;void 0!==s.baseColorFactor&&(r.baseColorFactor=s.baseColorFactor.slice()),void 0!==s.baseColorTexture&&(r.baseColorTexture=new e$4(s.baseColorTexture,o),o.addTextureInfo(r.baseColorTexture)),void 0!==s.metallicFactor&&(r.metallicFactor=s.metallicFactor),void 0!==s.roughnessFactor&&(r.roughnessFactor=s.roughnessFactor),void 0!==s.metallicRoughnessTexture&&(r.metallicRoughnessTexture=new e$4(s.metallicRoughnessTexture,o),o.addTextureInfo(r.metallicRoughnessTexture));}}_setupGenericParameters(s,r){void 0!==s.doubleSided&&(this._doubleSided=s.doubleSided),void 0!==s.alphaMode&&(this._alphaMode=s.alphaMode),void 0!==s.alphaCutoff&&(this._alphaCutoff=s.alphaCutoff),void 0!==s.emissiveFactor&&(this._emissiveFactor=s.emissiveFactor.slice()),void 0!==s.emissiveTexture&&(this._emissiveTexture=new e$4(s.emissiveTexture,r),r.addTextureInfo(this._emissiveTexture)),void 0!==s.normalTexture&&(this._normalTexture=new s$3(s.normalTexture,r),r.addTextureInfo(this._normalTexture)),void 0!==s.occlusionTexture&&(this._occlusionTexture=new e$3(s.occlusionTexture,r),r.addTextureInfo(this._occlusionTexture));}}

class i$5{constructor(t,e){this._mode=void 0!==t.mode?t.mode:4,this._attributes={},this._indices=null,this._material=null,this._setupAttributes(t.attributes,e),this._setupIndices(t,e),this._setupMaterial(t,e);}get mode(){return this._mode}get attributes(){return this._attributes}get indices(){return this._indices}get material(){return this._material}_setupAttributes(e,i){for(var s in e){var r=new e$2(i,e[s]);this._attributes[s]=r,i.addAccessor(r,"ATTRIBUTE");}}_setupIndices(e,i){if(void 0!==e.indices){var s=new e$2(i,e.indices);this._indices=s,i.addAccessor(s,"INDEX");}}_setupMaterial(t,i){void 0!==t.material&&(this._material=new r$3(i,t.material));}}

class s$2{constructor(s,t){this._primitives=[];for(var r=s.gjson.meshes[t].primitives,e=0;e<r.length;++e){var m=r[e];this._primitives.push(new i$5(m,s));}}get primitives(){return this._primitives}}

class i$4{constructor(t,r){var i=t.gjson.nodes[r];this._commonData=new t$8(i,t),this._children=[],this._matrix=null,this._mesh=null,this._setupChildren(i,t),this._setupMatrix(i),this._setupMesh(i,t);}get commonData(){return this._commonData}get children(){return this._children}get matrix(){return this._matrix}get mesh(){return this._mesh}_setupChildren(t,r){var e=t.children;if(void 0!==e)for(var s=0;s<e.length;++s){var a=e[s];this._children.push(new i$4(r,a));}}_setupMatrix(r){if(r.matrix)this._matrix=e$z.createMatrix(r.matrix);else if(r.scale||r.rotation||r.translation){var[e,i,s]=r.scale||[1,1,1],[a,h,n,o]=r.rotation||[0,0,0,1],[m,l,_]=r.translation||[0,0,0];this._matrix=e$z.createMatrix([(1-2*(h*h+n*n))*e,2*(a*h+n*o)*e,2*(a*n-h*o)*e,0,2*(a*h-n*o)*i,(1-2*(a*a+n*n))*i,2*(a*o+h*n)*i,0,2*(h*o+a*n)*s,2*(h*n-a*o)*s,(1-2*(a*a+h*h))*s,0,m,l,_,1]);}}_setupMesh(t,e){var i=t.mesh;void 0!==i&&(this._mesh=new s$2(e,i));}}

class s$1{constructor(s,e){const n=s.gjson.scenes[e];this._commonData=new t$8(n,s),this._root_nodes=[];for(const t of n.nodes||[])this._root_nodes.push(new i$4(s,t));}get commonData(){return this._commonData}get root_nodes(){return this._root_nodes}get name(){return this._commonData.getName()}}

class t$5{constructor(){var t=new e$1(-2,-1),s=new e$1(2**32+1,2**32+2);t.next=s,s.prev=t,this._fragments=t;}update(e){const s=e.getRangeInBuffer();this._updateByRange({first:t$5._floor4(s.first),last:s.last});}close(t){this._fragments=this._fragments.next;for(let e=this._fragments;;e=e.next){if(null===e.next){e.prev.next=null;break}e.buffer=t.createSubBuffer(e.first,e.last);}}rebuildAccessor(t){for(let e=this._fragments;null!==e;e=e.next)if(t.isIncluded(e.first,e.last)){t.rebuildBySplitter(e.buffer,e.first);break}}_updateByRange(t){for(let s=this._fragments;null!==s.next;){if(s.isInside(t)){let r=s,i=s.next,n=new e$1(t.first,t.last);r.next=n,i.prev=n,n.prev=r,n.next=i;break}if(s.isTouch(t)){let e=s.prev,r=s.next;e.next=r,r.prev=e,t=s.mergeRange(t),s=e;}else s=s.next;}}static _floor4(t){return 4*Math.floor(t/4)}}class e$1{constructor(t,e){this.first=t,this.last=e,this.buffer=null,this.prev=null,this.next=null;}isInside(t){return this.last<t.first&&t.last<this.next.first}isTouch(t){return this.last>=t.first&&t.last>=this.first}mergeRange(t){return {first:Math.min(this.first,t.first),last:Math.max(this.last,t.last)}}}

class t$4{constructor(t){this._length=t,this._array=new Uint32Array(Math.ceil(t/32));}get length(){return this._length}setBit(t,r){var a=Math.floor(t/32),e=this._array[a],h=1<<t%32;this._array[a]=r?e|h:e&~h;}getBit(t){var r=Math.floor(t/32);return 0!=(this._array[r]&1<<t%32)}}

class r$2{constructor(s){this._buffer=s,this._attrib_accessors=[],this._index_accessors=[];}get buffer(){return this._buffer}addAttributeAccessor(s){this._attrib_accessors.push(s);}addIndexAccessor(s){this._index_accessors.push(s);}rewriteByteOrder(){var s=new t$4(Math.ceil(this._buffer.byteLength/2));for(const e of this._getUnitedOriginalAccessors())e.modifyByteOrder(s);}splitBufferAndRebuildAccessors(){this._splitBufferAndRebuildAccessors(this._attrib_accessors),this._splitBufferAndRebuildAccessors(this._index_accessors);}_splitBufferAndRebuildAccessors(e){var t=new t$5;for(const s of r$2._getOriginalAccessors(e))t.update(s);t.close(this._buffer);for(const s of e)t.rebuildAccessor(s);}_getUnitedOriginalAccessors(){return r$2._getOriginalAccessors(this._attrib_accessors.concat(this._index_accessors))}static _getOriginalAccessors(s){var e=new Map;for(const r of s){const s=r.index;e.has(s)||e.set(s,r);}return e.values()}}

class t$3{constructor(t){this._image=t,this._texinfo_objects=[];}get image(){return this._image}addTextureInfo(t){this._texinfo_objects.push(t);}rebuildTextureInfo(){var t=this._texinfo_objects;if(!(t.length<=1))for(var e=t[0].texture,i=1;i<t.length;++i)t[i].texture=e;}}

class t$2{constructor(t,e){if(void 0===t)this._index=-1,this._byteLength=0,this._uri=null,this._binary=null;else {this._index=e;var i=t.gjson.buffers[e];this._byteLength=i.byteLength,void 0!==i.uri?(t.onStartLoadBuffer(),t.loadBinary(i.uri).then((e=>{this._binary=e,t.onFinishLoadBuffer();})).catch((e=>{console.error(e),t.onFinishLoadBuffer(e);}))):(this._uri=null,this._binary=null);}}get index(){return this._index}get binary(){return this._binary}get byteLength(){return this._byteLength}createSubBuffer(e,i){var n=new t$2;return n._byteLength=i-e,n._binary=this._binary.slice(e,i),n}}

class i$3{constructor(i,t){this._index=t;var a=i.gjson.images[t];void 0!==a.uri?(i.onStartLoadImage(),i.loadImage(a.uri).then((e=>{this._image=e,i.onFinishLoadImage();})).catch((e=>{i.onFinishLoadImage(e);}))):void 0!==a.bufferView&&(this._bufferView=new t$6(i,a.bufferView)),this._mimeType=a.mimeType,this._image=null;}get index(){return this._index}get image(){return this._image}}

class o$2{constructor(e,s){var t=s||{};this._gjson=e,this._base_resource=t.base_resource,this._binary_type=t.binary_type,this._image_type=t.image_type,this._supported_extensions=t.supported_extensions||[],this._resolve=null,this._reject=null,this._used_extensions=new Set,this._scenes=[],this._default_scene_index=-1,this._buffer_entries=[],this._image_entries=[],this._body_finished=!1,this._load_count=0,this._load_error=null,this._settled=!1;}load(){return new Promise(((e,s)=>{if(this._resolve=e,this._reject=s,this._loadVersion().major<2)return void s(new Error("glTF version error"));const t=this._getSupportedExtensionNames();for(const e of this._enumRequiredExtensionNames())if(!t.has(e))return void s(new Error("glTF extension error: "+e));this._loadExtensionsUsed(),this._loadScenes(),this._loadDefaultSceneIndex(),this._onFinishLoadBody();}))}_loadVersion(){var e=this._gjson.asset.version,s=/^(\d+)\.(\d+)/.exec(e);return {major:Number(s[1]),minor:Number(s[2])}}_enumRequiredExtensionNames(){return this._gjson.extensionsRequired||[]}_getSupportedExtensionNames(){const e=this._supported_extensions;return new Set([].concat(e))}_loadExtensionsUsed(){this._used_extensions=new Set(this._gjson.extensionsUsed||[]);}_loadScenes(){const e=(this._gjson.scenes||[]).length,t=[];for(let i=0;i<e;++i)t.push(new s$1(this,i));this._scenes=t;}_loadDefaultSceneIndex(){"number"==typeof this._gjson.scene&&(this._default_scene_index=this._gjson.scene);}get gjson(){return this._gjson}extractUsedExtensions(e){let s={};for(let t in e)this._used_extensions.has(t)&&(s[t]=e[t]);return s}loadBinary(e){return this._base_resource.loadSubResource(e,{type:this._binary_type})}loadImage(e){return this._base_resource.loadSubResource(e,{type:this._image_type})}findBuffer(e){return void 0===this._buffer_entries[e]&&(this._buffer_entries[e]=new r$2(new t$2(this,e))),this._buffer_entries[e].buffer}findImage(e){return void 0===this._image_entries[e]&&(this._image_entries[e]=new t$3(new i$3(this,e))),this._image_entries[e].image}addAccessor(e,s){var t=this._buffer_entries[e.bufferView.buffer.index];switch(s){case"ATTRIBUTE":t.addAttributeAccessor(e);break;case"INDEX":t.addIndexAccessor(e);}}addTextureInfo(e){var s=e.texture.source;this._image_entries[s.index].addTextureInfo(e);}onStartLoadBuffer(){this._load_count+=1;}onFinishLoadBuffer(e){e&&(this._load_error=e),this._load_count-=1,this._onFinishLoadSomething();}onStartLoadImage(){this._load_count+=1;}onFinishLoadImage(e){e&&(this._load_error=e),this._load_count-=1,this._onFinishLoadSomething();}_onFinishLoadBody(){this._body_finished=!0,this._onFinishLoadSomething();}_onFinishLoadSomething(){this._settled||(null!==this._load_error?(this._reject(this._load_error),this._settled=!0):this._body_finished&&0==this._load_count&&(this._rewriteBuffersForByteOrder(),this._splitBuffersAndRebuildAccessors(),this._rebuildTextureInfo(),this._resolve(new t$7(this,this._scenes,this._default_scene_index)),this._settled=!0));}_rewriteBuffersForByteOrder(){for(const e of this._buffer_entries)void 0!==e&&e.rewriteByteOrder();}_splitBuffersAndRebuildAccessors(){for(const e of this._buffer_entries)void 0!==e&&e.splitBufferAndRebuildAccessors();}_rebuildTextureInfo(){for(const e of this._image_entries)void 0!==e&&e.rebuildTextureInfo();}}

class a$3{static load(a,o){return new o$2(a,o).load()}}

class h$2 extends e$6{constructor(e,r,t={}){let s;if(r instanceof i$s)s=r;else {if("string"!=typeof r)throw new Error("Unsupported Resource: "+r);s=new s$p(r,{type:i$s.Type.JSON,transform:t.transform});}super(e,s,{onEntity:t.onEntity,onLoad:t.callback}),this._glenv=e.glenv,this._references={},this._finished=!1;}getReference(e){var r=this._references[e];return void 0!==r?r:null}_setReference(e,r){this._references[e]=r;}_load(){return this._resource.load({type:i$s.Type.JSON}).then((e=>(this._check_cancel(),this._load_object(e))))}_load_object(e){return Promise.resolve().then((()=>this._load_model_register(e))).then((()=>this._postload_object(e)))}_postload_object(r){this.status===e$6.Status.LOADING&&this._load_entity_list(r);}_load_model_register(e){var r=e.model_register;if(r){for(var t=Object.keys(r),s=[],o=0;o<t.length;++o){var n=t[o],i=r[n];s.push(this._load_model_container(e,n,i));}return Promise.all(s)}}_load_model_container(e,r,t){var o=t.link;if(!this._resource.resolveResourceSupported())return Promise.reject(new Error("Sub Resource is not supported"));const n=this._resource.resolveResource(o);return n.load({type:i$s.Type.JSON}).then((e=>(this._check_cancel(),a$3.load(e,{base_resource:n,binary_type:i$s.Type.BINARY,image_type:i$s.Type.IMAGE,supported_extensions:l$1.getSupportedExtensions_glTF()})))).then((e=>{var o=new l$1(this._scene,e);if(t.offset_transform){var n=h$2.parseOffsetTransform(t.offset_transform);o.setOffsetTransform(n);}this._setReference(r,o);}))}_load_entity_list(e){var r=e.entity_list;if(r)for(var t=this._scene,s=0;s<r.length;++s){var l=r[s],m=l.type,p=null;switch(m){case"markerline":p=new s$7(t,{json:l,refs:this._references});break;case"path":p=new n$p(t,{json:l,refs:this._references});break;case"text":p=new g$4(t,{json:l,refs:this._references});break;case"model":p=new l$4(t,{json:l,refs:this._references});break;case"polygon":p=new g$3(t,{json:l,refs:this._references});break;case"pin":p=new y$1(t,{json:l,refs:this._references});break;case"imageicon":p=new v(t,{json:l,refs:this._references});break;default:console.error("mapray: unknown entity type: "+m);}if(p){this._onEntity(this,p,l);var h=l.id;h&&this._setReference(h,p);}}}static parseOffsetTransform(e){var s=e,o=s.translate||[0,0,0],n=new a$n(s.heading,s.tilt,s.roll),i=s.scale;const a=void 0===i?[1,1,1]:"number"==typeof i?[i,i,i]:i;var f=e$z.createMatrix();return n.getTransformMatrix(a,f),f[12]=o[0],f[13]=o[1],f[14]=o[2],f}}!function(e){e._defaultHeaders={};}(h$2||(h$2={}));

var e;!function(e){let t,n;e.isFeatureCollectionJson=function(e){return e.type===t.FeatureCollection},e.isFeatureJson=function(e){return e.type===t.Feature},e.isPointGeometryJson=function(e){return e.type===n.Point},function(e){e.Feature="Feature",e.FeatureCollection="FeatureCollection";}(t=e.FeatureType||(e.FeatureType={})),function(e){e.Point="Point";}(n=e.GeometryType||(e.GeometryType={}));}(e||(e={}));var t$1=e;

class d extends e$6{constructor(t,e,o={}){let i;if(e instanceof i$s)i=e;else {if("string"!=typeof e)throw new Error("Unsupported Resource: "+e);i=new s$p(e,{type:i$s.Type.JSON,transform:o.transform});}super(t,i,{onEntity:o.onEntity,onLoad:o.onLoad}),this._getPointFGColor=o.getPointFGColor||h$1,this._getPointBGColor=o.getPointBGColor||g$1,this._getPointSize=o.getPointSize||f,this._getPointIconId=o.getPointIconId||P,this._getLineColor=o.getLineColor||u,this._getLineWidth=o.getLineWidth||_$1,this._getFillColor=o.getFillColor||c$1,this._getExtrudedHeight=o.getExtrudedHeight||I,this._getAltitudeMode=o.getAltitudeMode||L,this._getAltitude=o.getAltitude||y,this._glenv=t.glenv,this._cancelled=!1,this._finished=!1;}_load(){return this._resource.load({type:i$s.Type.JSON}).then((t=>{this._check_cancel(),this._load_geojson_object(t);}))}_load_geojson_object(t){var e;if(t$1.isFeatureCollectionJson(t)){e=!1;for(var o=0,i=t.features.length;o<i;o++){var n=t.features[o],r=this._load_geojson_object(n.featureId?n.feature:n);r&&!e&&(e=r);}}else e=t$1.isFeatureJson(t)?this._load_geometry_object(t.geometry,t):this._load_geometry_object(t,void 0);return !this._cancelled&&e}_load_geometry_object(t,e){const o=e||{id:"",type:"Feature",geometry:t};switch(t.type){case E.POINT:case E.MULTI_POINT:return this._loadPoint(t,o);case E.LINE_STRING:case E.MULTI_LINE_STRING:return this._loadLines(t,o);case E.POLYGON:case E.MULTI_POLYGON:return this._loadPolygons(t,o);case E.GEOMETRY_COLLECTION:return !0;default:throw new Error("Invalid GeoJSON type: "+t.type)}}_loadLines(t,e){const o=this._getLineColor(e),i=this._getLineWidth(e),n=this._getAltitude(e),r=this._getAltitudeMode(e);if(!t||4!==o.length)return !1;var l=t.type;t.coordinates;var s=o.slice(0,3),a=o[3];if(l===E.MULTI_LINE_STRING){let o=!0;return t.coordinates.forEach((t=>{const l=this._generateLine(t,i,s,a,r,n,e);return l||(o=!1),l})),o}{const o=t;return this._generateLine(o.coordinates,i,s,a,r,n,e)}}_generateLine(t,e,i,n,r,l,s){if(!t)return !1;var a=new s$7(this._scene);a.altitude_mode=r;var d=this._flatten(t,l);return a.addPoints(d),a.setLineWidth(e),a.setColor(i),a.setOpacity(n),this._onEntity(this,a,s),!0}_loadPoint(t,o){const i=this._getPointFGColor(o),r=this._getPointBGColor(o),l=this._getPointIconId(o),s=this._getPointSize(o),u=this._getAltitudeMode(o),_=this._getAltitude(o);if(!t)return !1;t.type;var c={fg_color:i.slice(0,3),bg_color:r.slice(0,3),size:s};const h=new y$1(this._scene);if(h.altitude_mode=u,t$1.isPointGeometryJson(t)){var g=this._getActualValue(_,t.coordinates[2],d.defaultAltitude),f=new r$z(t.coordinates[0],t.coordinates[1],g);l?h.addMakiIconPin(l,f,c):h.addPin(f,c);}else for(var P=0;P<t.coordinates.length;P++){var L=t.coordinates[P];g=this._getActualValue(_,L[2],d.defaultAltitude),f=new r$z(L[0],L[1],g);l?h.addMakiIconPin(l,f,c):h.addPin(f,c);}return this._onEntity(this,h,o),!0}_loadPolygons(t,e){const o=this._getFillColor(e),i=this._getAltitudeMode(e),n=this._getAltitude(e),r=this._getExtrudedHeight(e);if(!t||4!==o.length)return !1;var l=t.type;t.coordinates;var s=o.slice(0,3),a=o[3];if(l===E.MULTI_POLYGON){let o=!0;return t.coordinates.forEach((t=>{const l=this._generatePolygon(t,s,a,i,n,r,e);return l||(o=!1),l})),o}{const o=t;return this._generatePolygon(o.coordinates,s,a,i,n,r,e)}}_generatePolygon(t,e,o,n,r,l,s){if(!t)return !1;const a=new g$3(this._scene);a.altitude_mode=n,a.extruded_height=l,a.setColor(e),a.setOpacity(o);for(let e=0;e<t.length;e++){const o=this._flatten(t[e],r,t[e].length-1);if(!o)return !1;0===e?a.addOuterBoundary(o):a.addInnerBoundary(o);}return this._onEntity(this,a,s),!0}_getActualValue(t,e,o){return null!=t?t:null!=e?e:o}_flatten(t,e,o=t.length){return t.reduce(((t,i,n)=>n>=o?t:t.concat(i.slice(0,2),this._getActualValue(e,i[2],d.defaultAltitude))),[])}}function u(t){return d.defaultLineColor}function _$1(t){return d.defaultLineWidth}function c$1(t){return d.defaultFillColor}function h$1(t){return d.defaultPointFGColor}function g$1(t){return d.defaultPointBGColor}function f(t){return d.defaultPointSize}function P(t){return d.defaultPointIconId}function L(t){return E$4.ABSOLUTE}function y(t){}function I(t){return d.defaultExtrudedHeight}!function(t){t._defaultHeaders={},t.defaultLineColor=[0,0,0,1],t.defaultFillColor=[0,0,0,1],t.defaultLineWidth=1,t.defaultPointFGColor=[1,1,1],t.defaultPointBGColor=[.35,.61,.81],t.defaultPointSize=30,t.defaultPointIconId=void 0,t.defaultAltitude=0,t.defaultExtrudedHeight=0;}(d||(d={}));var E={POINT:"Point",MULTI_POINT:"MultiPoint",LINE_STRING:"LineString",MULTI_LINE_STRING:"MultiLineString",POLYGON:"Polygon",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",FEATURE:"Feature"};Object.values(E);

class i$2{constructor(t={}){this._status=i$2.Status.NOT_INITIALIZED,this._time_info_handler=null==t?void 0:t.time_info_handler;}init(){return __awaiter(this,void 0,void 0,(function*(){if(this._status!==i$2.Status.NOT_INITIALIZED)throw new Error("invalid status");try{yield this.doInit(),this._status=i$2.Status.INITIALIZED;}catch(t){throw this._status=i$2.Status.DESTROYED,t}}))}isReady(){return this._status==i$2.Status.INITIALIZED&&this.getNumberOfRequests()<10}load(s,e,n,a){if(this._status!==i$2.Status.INITIALIZED)return {id:-1,done:Promise.reject(new Error("invalid status"))};const r=i$2._id_max++;return {id:r,done:(()=>__awaiter(this,void 0,void 0,(function*(){const t=Date.now(),i=yield this.doLoad(r,s,e,n,a);if(this._time_info_handler){const r=s+"/"+e+"/"+n+"/"+a,o=Date.now();i.times?(i.times.path=r,i.times.start=t,i.times.end=o):i.times={path:r,start:t,end:o},this._time_info_handler(i.times);}return i})))()}}flushQueue(){}toString(){return "PointCloudProvider"}setTimeInfoHandler(t){this._time_info_handler!==t&&(this._time_info_handler=t,this.onChangeTimeInfoHandler(!0));}clearTimeInfoHandler(){this._time_info_handler&&(this._time_info_handler=void 0,this.onChangeTimeInfoHandler(!1));}onChangeTimeInfoHandler(t){}isTimeInfoHandlerAvailable(){return void 0!==this._time_info_handler}cancel(t){if(this._status!==i$2.Status.INITIALIZED)throw new Error("invalid status");this.doCancel(t);}doCancel(t){}destroy(){return __awaiter(this,void 0,void 0,(function*(){if(this._status!==i$2.Status.INITIALIZED)throw new Error("invalid status");try{yield this.doDestroy();}finally{this._status=i$2.Status.DESTROYED;}}))}}i$2._id_max=0,function(t){var i;(i=t.Status||(t.Status={}))[i.NOT_INITIALIZED=0]="NOT_INITIALIZED",i[i.INITIALIZED=1]="INITIALIZED",i[i.DESTROYED=2]="DESTROYED";}(i$2||(i$2={}));

var n$d="/**\n * Modified from GPU Gems 2 (https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html)\n * Includes the following third-party code.\n *\n * s_p_oneil@hotmail.com\n * Copyright (c) 2000, Sean O'Neil\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of this project nor the names of its contributors\n *   may be used to endorse or promote products derived from this software\n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nprecision highp float;\n\nattribute vec3 a_position;\n\nuniform mat4  u_gocs_to_clip;\nuniform vec3  u_camera_position;    // The camera's current position\nuniform vec3  u_sun_vector;         // The direction vector to the light source\nuniform float u_camera_height;      // The camera's current height\nuniform float u_camera_height2;     // u_camera_height^2\nuniform float u_kr;                 // Kr\nuniform float u_km;                 // Km\nuniform float u_scale_depth;        // scale_depth\nuniform float u_esun;               // Kr\nuniform float u_exposure;           // Exposure\n\nvarying vec4 v_color;\n\nconst float loop_float = 10.0;         // loop\nconst int   loop_int   = 10;           // loop\n\nconst float planet_radius = 10.0;\nconst float atmosphere_radius = 10.25;\nconst float planet_factor = 637813.7;\n\nconst float PI = 3.14159265358932384626;\n\nconst vec3 inv_wave_length = vec3( 5.60204474633241, 9.47328443792304, 19.64380261047720 );\n\nconst float outer_radius  = atmosphere_radius;                      // The outer (atmosphere) radius\nconst float outer_radius2 = atmosphere_radius * atmosphere_radius;  // outer_radius^2\nconst float inner_radius  = planet_radius;                          // The inner (planetary) radius\nconst float inner_radius2 = planet_radius * planet_radius;          // inner_radius^2\n\n// variavle\n// float ratio = ( u_kr * 100.0 - 0.25 ) / 0.25;\n// float vkr = clamp( ( 0.25 - ( u_camera_height - 10.0 ) ) * ratio + 0.25, 0.25, u_kr * 100.0 ) * 0.01;\n\n// fixed\nfloat vkr = u_kr;\n\n// float Kr_ESun = u_kr * u_esun;      // Kr * ESun\nfloat Kr_ESun = vkr  * u_esun;      // Kr * ESun\nfloat Km_ESun = u_km * u_esun;      // Km * ESun\n// float Kr_4PI  = u_kr * 4.0 * PI;  // Kr * 4 * PI\nfloat Kr_4PI  = vkr  * 4.0 * PI;  // Kr * 4 * PI\nfloat Km_4PI  = u_km * 4.0 * PI;  // Km * 4 * PI\n\nconst float radius_scale = 1.0 / ( atmosphere_radius - planet_radius );   // 1 / (outer_radius - inner_radius)\nfloat scale_over_scale_depth = radius_scale / u_scale_depth;              // radius_scale / scale_depth\n\n\nfloat\nscale( float angle )\n{\n    float x = 1.0 - angle;\n    return u_scale_depth * exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * ( -6.80 + x * 5.25 ) ) ) );\n}\n\n\nvoid\nmain()\n{\n    vec3  ray        = a_position - u_camera_position;\n    float far_length = length( ray );\n    ray /= far_length;\n\n#ifdef SKY_IN_ATMOSPHERE\n    vec3  start_position = u_camera_position;\n    float start_height   = length( start_position );\n    float depth          = exp( scale_over_scale_depth * ( inner_radius - u_camera_height ) );\n    float start_angle    = dot( ray, start_position ) / start_height;\n    float start_offset   = depth * scale( start_angle );\n#else\n    float B           = 2.0 * dot( u_camera_position, ray );\n    float C           = u_camera_height2 - outer_radius2;\n    float det         = max( 0.0, B * B - 4.0 * C );\n    float near_length = 0.5 * ( -B - sqrt( det ) );\n\n    vec3  start_position = u_camera_position + ray * near_length;\n    far_length -= near_length;\n    float start_angle    = dot( ray, start_position ) / outer_radius;\n    float start_depth    = exp( -1.0 / u_scale_depth );\n    float start_offset   = start_depth * scale( start_angle ) ;\n#endif\n\n    float sample_length = far_length / loop_float;\n    float scaled_length = sample_length * radius_scale;\n    vec3  sample_ray    = ray * sample_length;\n    vec3  sample_point  = start_position + sample_ray * 0.5;\n\n    vec3 front_color = vec3( 0.0, 0.0, 0.0 );\n    for ( int i=0; i<loop_int; i++ )\n    {\n        float sample_height = length( sample_point );\n        float sample_depth  = exp( scale_over_scale_depth * ( inner_radius - sample_height ) );\n        float light_angle   = dot( u_sun_vector, sample_point ) / sample_height;\n        float camera_angle  = dot( ray, sample_point ) / sample_height;\n        float scatter = ( start_offset + sample_depth * ( scale( light_angle ) - scale( camera_angle ) ) );\n        vec3 attenuate = exp( -scatter * ( inv_wave_length * Kr_4PI + Km_4PI ) );\n        front_color += attenuate * ( sample_depth * scaled_length );\n        front_color   = clamp( front_color, 0.0, 10.0 );\n        sample_point += sample_ray;\n    }\n\n    vec4 first_color;\n    vec4 secondary_color;\n    secondary_color.rgb = front_color * Km_ESun;\n    secondary_color.a   = 1.0;\n    first_color.rgb     = front_color * ( inv_wave_length * Kr_ESun );\n    first_color.a       = 1.0;\n\n    v_color   = first_color + secondary_color;\n    v_color   = vec4( 1.0 ) - exp( v_color * u_exposure );\n    v_color.a = 1.0;\n    v_color   = clamp( v_color, 0.0, 1.0 );\n\n    #ifdef MASK_SKY\n        float mask_color = clamp ( v_color.b * 2.0 + v_color.r, 0.0, 1.0 );\n        v_color = vec4 ( vec3 ( 0.0 ), mask_color );\n    #endif\n\n    vec3 atmosphere_position = a_position * planet_factor;\n    gl_Position = u_gocs_to_clip * vec4( atmosphere_position, 1.0 );\n}\n";

var n$c="precision highp float;\n\nvarying   vec4 v_color;\n\nvoid\nmain()\n{\n    gl_FragColor = v_color;\n}\n";

class r$1 extends e$o{constructor(e,o={}){const a=r$1._getPreamble(o);super(e.glenv,a+n$d,a+n$c),this._viewer=e;}static _getPreamble(e){const t=void 0!==e.from_atmosphere&&e.from_atmosphere,s=void 0!==e.mask&&e.mask,r=[];return t&&r.push("#define SKY_IN_ATMOSPHERE"),s&&r.push("#define MASK_SKY"),r.join("\n")+"\n\n"}setParameter(e,t,s,r,o){this.setMatrix("u_gocs_to_clip",t),this.setVector3("u_camera_position",s),this.setVector3("u_sun_vector",this._viewer.sun.sun_direction),this.setFloat("u_camera_height",r),this.setFloat("u_camera_height2",r*r),this.setFloat("u_kr",o.kr),this.setFloat("u_km",o.km),this.setFloat("u_scale_depth",o.scale_depth),this.setFloat("u_esun",o.esun),this.setFloat("u_exposure",o.exposure);}}

class a$2{init(e){this._viewer=e,this._glenv=e.glenv,this._visibility={sky:!0,ground:!0},this._star_mask=!0,this._parameters={kr:.01,km:.001,scale_depth:.13,esun:17.5,exposure:-1.4,g_kr:.0025,g_km:.001,g_scale_depth:.25,g_esun:16,g_exposure:-2},this._createMesh(),this._checkMaterials();}destroy(){this._deleteMaterials(),this._mesh&&this._mesh.dispose();}get visibility(){return this._visibility}get starMask(){return this._star_mask}setSkyVisibility(e){this._visibility.sky=e;}setGroundVisibility(e){this._visibility.ground=e;}setStarMask(e){this._star_mask=e;}get parameters(){return this._parameters}setRayleigh(e){this._parameters.kr=e;}setMie(e){this._parameters.km=e;}setScaleDepth(e){this._parameters.scale_depth=e;}setSunRate(e){this._parameters.esun=e;}setExposure(e){this._parameters.exposure=e;}setGroundRayleigh(e){this._parameters.g_kr=e;}setGroundMie(e){this._parameters.g_km=e;}setGroundScaleDepth(e){this._parameters.g_scale_depth=e;}setGroundSunRate(e){this._parameters.g_esun=e;}setGroundExposure(e){this._parameters.g_exposure=e;}_createMesh(){const s=320;let t,a,r,_,i,h,m,p,o,c;const n=10.25;let l=[],k=[];for(i=0;i<=s;i++)for(h=i*Math.PI/s,m=Math.sin(h),p=Math.cos(h),t=0;t<=s;t++)a=2*t*Math.PI/s,r=Math.sin(a),_=Math.cos(a),l.push(r*m*n),l.push(p*n),l.push(_*m*n);for(i=0;i<s;i++)for(t=0;t<s;t++)o=321*i+t,c=o+321,k.push(o),k.push(c),k.push(o+1),k.push(o+1),k.push(c),k.push(c+1);const d={vtype:[{name:"a_position",size:3}],vertices:l,indices:k};this._mesh=new r$h(this._glenv,d);}_checkMaterials(){const e=this._viewer._render_cache||(this._viewer._render_cache={});e.sky_space_material||(e.sky_space_material=new r$1(this._viewer),e.sky_atmosphere_material=new r$1(this._viewer,{from_atmosphere:!0}),e.mask_sky_space_material=new r$1(this._viewer,{mask:!0}),e.mask_sky_atmosphere_material=new r$1(this._viewer,{from_atmosphere:!0,mask:!0}));}_deleteMaterials(){const e=this._viewer._render_cache;e&&e.sky_space_material&&(e.sky_space_material.dispose(),e.sky_atmosphere_material.dispose(),e.mask_sky_space_material.dispose(),e.mask_sky_atmosphere_material.dispose(),e.sky_space_material=void 0,e.sky_atmosphere_material=void 0,e.mask_sky_space_material=void 0,e.mask_sky_atmosphere_material=void 0);}draw(e,s,t){this._draw(e,s,t,!1);}drawMask(e,s,t){this._draw(e,s,t,!0);}_draw(e,t,a,r){const _=e._glenv.context,i=.1*e$z.EARTH_RADIUS,h=a[12]/i,m=a[13]/i,p=a[14]/i,o=[h,m,p],c=Math.sqrt(h*h+m*m+p*p),n=c>=10.25?r?this._viewer._render_cache.mask_sky_space_material:this._viewer._render_cache.sky_space_material:r?this._viewer._render_cache.mask_sky_atmosphere_material:this._viewer._render_cache.sky_atmosphere_material;n.bindProgram(),n.setParameter(e,t,o,c,this._parameters),_.frontFace(_.CW),this._mesh.draw(n),_.frontFace(_.CCW);}selectGroundShader(e){return Math.sqrt(e[12]*e[12]+e[13]*e[13]+e[14]*e[14])>=1.025*e$z.EARTH_RADIUS?this._viewer._render_cache.surface_ground_space_material:this._viewer._render_cache.surface_ground_atmosphere_material}}

var n$b="/**\n * Modified from GPU Gems 2 (https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html)\n * Includes the following third-party code.\n *\n * s_p_oneil@hotmail.com\n * Copyright (c) 2000, Sean O'Neil\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of this project nor the names of its contributors\n *   may be used to endorse or promote products derived from this software\n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n/**\n * 太陽 (頂点シェーダ)\n */\n\nprecision mediump float;\n\nuniform mat4  u_billboard_matrix;\nuniform mat4  u_camera_direction_matrix;\nuniform vec3  u_sun_direction;\nuniform float u_intensity;\n\nattribute vec3 a_position;\nattribute float a_glow;\n\nvarying vec4 v_color;\n\n// <atmosphere\nconst float sun_length = 149597.870000;  // 1/1000000\n\nuniform vec3  u_camera_position;    // The camera's current position\nuniform vec3  u_sun_vector;         // The direction vector to the light source\nuniform float u_camera_height;      // The camera's current height\nuniform float u_kr;                 // Kr\nuniform float u_km;                 // Km\nuniform float u_scale_depth;        // scale_depth\nuniform float u_esun;               // Kr\n\nconst float planet_radius = 6.378137;               // 1/1000000\nconst float atmosphere_radius = 6.378137 * 1.025;   // 1/1000000\n\nconst float PI = 3.14159265358932384626;\n\nconst vec3 inv_wave_length = vec3( 5.60204474633241, 9.47328443792304, 19.64380261047720 );\n\nconst float outer_radius  = atmosphere_radius;                      // The outer (atmosphere) radius\nconst float outer_radius2 = atmosphere_radius * atmosphere_radius;  // outer_radius^2\nconst float inner_radius  = planet_radius;                          // The inner (planetary) radius\nconst float inner_radius2 = planet_radius * planet_radius;          // inner_radius^2\n\nfloat Kr_ESun = u_kr * u_esun;      // Kr * ESun\nfloat Km_ESun = u_km * u_esun;      // Km * ESun\nfloat Kr_4PI  = u_kr * 4.0 * PI;    // Kr * 4 * PI\nfloat Km_4PI  = u_km * 4.0 * PI;    // Km * 4 * PI\n\nconst float radius_scale = 1.0 / ( atmosphere_radius - planet_radius );   // 1 / (outer_radius - inner_radius)\nfloat scale_over_scale_depth = radius_scale / u_scale_depth;              // radius_scale / scale_depth\n\nfloat\nscale( float angle )\n{\n    float x = 1.0 - angle;\n    return u_scale_depth * exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * ( -6.80 + x * 5.25 ) ) ) );\n}\n// atmosphere>\n\nvoid\nmain()\n{\n    // <atmosphere\n    vec3  sun_pos    = -u_sun_vector * sun_length;\n    vec3  ray        = sun_pos - u_camera_position;\n    float far_length = length( ray );\n    ray /= far_length;\n\n    vec3  start_position = u_camera_position;\n\n    float start_height   = length( start_position );\n    float depth          = exp( scale_over_scale_depth * ( inner_radius - u_camera_height ) );\n\n    vec4 cam_vec      = u_camera_direction_matrix * vec4( 0.0, 0.0, 1.0, 1.0 );\n    float start_angle = dot( normalize( ray ), cam_vec.xyz );\n    start_angle       = clamp( start_angle, 0.0, 1.0 );\n    start_angle       = 1.0 - start_angle;\n\n    float up_angle = dot( normalize( start_position ), cam_vec.xyz );\n    up_angle       = clamp( up_angle, 0.0, 1.0 );\n    up_angle       = 1.0 - up_angle;\n\n    float scatter = depth * ( scale( start_angle ) - scale( up_angle ) );\n    vec3  FrontSecondaryColor = exp( -scatter * ( inv_wave_length * Kr_4PI + Km_4PI ) );\n    // atmosphere>\n\n    vec3 vertex_pos = a_position;\n    gl_Position = u_billboard_matrix * vec4( vertex_pos, 1.0 );\n\n    vec3 color = vec3( a_glow * u_intensity );\n    color *= FrontSecondaryColor;\n    v_color = vec4( color, 1.0 );\n}\n";

var n$a="/**\n * 太陽 (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid\nmain()\n{\n    gl_FragColor = v_color;\n}\n";

class a$1 extends e$o{constructor(t){super(t.glenv,n$b,n$a),this._viewer=t,this._matrix=e$z.createMatrix();}setParameter(t,r,s,a,i,c,o){const n=s,h=e$z.createVector3([s[12],s[13],s[14]]),u=e$z.createVector3([s[8],s[9],s[10]]),_=e$z.createVector3(),l=e$z.createMatrix([n[0],n[1],n[2],0,n[4],n[5],n[6],0,n[8],n[9],n[10],0,0,0,0,1]);this.setFloat("u_intensity",c),this.setMatrix("u_camera_direction_matrix",l),this.setVector3("u_sun_direction",a.sun_direction);const m=1e-6*e$z.length3(h);this.setVector3("u_camera_position",e$z.scale3(1e-6,h,e$z.createVector3())),this.setVector3("u_sun_vector",a.sun_direction),this.setFloat("u_camera_height",m),this.setFloat("u_kr",o.kr),this.setFloat("u_km",o.km),this.setFloat("u_scale_depth",o.scale_depth),this.setFloat("u_esun",o.esun);const d=(this._viewer.camera.far+this._viewer.camera.near)/2,V=e$z.scale3(d,u,e$z.createVector3()),x=e$z.add3(h,V,e$z.createVector3()),M=e$z.scale3(14959787e4,a.sun_direction,e$z.createVector3()),b=e$z.sub3(M,x,e$z.createVector3());let p=e$z.dot3(V,u),f=e$z.dot3(b,u);if(Math.abs(p)<1e-6&&(p=0),Math.abs(f)<1e-6&&(f=0),!(p>=0&&f<=0||p<=0&&f>=0))return !1;const v=Math.abs(p),F=Math.abs(f),g=e$z.sub3(M,h,_),j=v/(v+F),k=e$z.add3(h,e$z.scale3(j,g,_),e$z.createVector3()),w=this._matrix,G=e$z.length3(e$z.sub3(k,h,_))/2.5*i,y=l;y[0]*=G,y[1]*=G,y[2]*=G,y[4]*=G,y[5]*=G,y[6]*=G,y[8]*=G,y[9]*=G,y[10]*=G,y[12]=k[0],y[13]=k[1],y[14]=k[2];const A=e$z.mul_GA(r,y,w);return this.setMatrix("u_billboard_matrix",A),!0}}

class t{constructor(s){s<3&&(s=3),this._divide=s;}init(s){this._viewer=s,this._glenv=s.glenv,this._visibility=!0,this._radius=1,this._intensity=1,this._parameters={kr:.0025,km:.001,scale_depth:.25,esun:20},this._createMesh(),this._checkMaterials();}destroy(){this._deleteMaterials(),this._mesh&&this._mesh.dispose();}get visibility(){return this._visibility}setVisibility(s){this._visibility=s;}setRadius(s){s<0&&(s=.1),this._radius=s;}setIntensity(s){this._intensity=s;}setRayleigh(s){this._parameters.kr=s;}setMie(s){this._parameters.km=s;}setScaleDepth(s){this._parameters.scale_depth=s;}setSunRate(s){this._parameters.esun=s;}_createMesh(){const e=this._divide;let t,r,a,_,u;let n=[],p=[];n.push(0),n.push(0),n.push(0),n.push(1);for(let s=0;s<15;s++){_=i$1[s],u=h[s];for(let s=0;s<e;s++)t=2*s*Math.PI/e,r=Math.sin(t),a=Math.cos(t),n.push(r*_),n.push(a*_),n.push(0),n.push(u/255);}for(let s=1;s<e;s++)p.push(0),p.push(s+1),p.push(s);p.push(0),p.push(1),p.push(e);for(let s=1;s<15;s++){let t;for(t=e*s;t<e*(s+1)-1;t++)p.push(t-e+1),p.push(t+2),p.push(t+1),p.push(t-e+1),p.push(t-e+2),p.push(t+2);t=e*(s+1)-1,p.push(t-e+1),p.push(t-e+2),p.push(t+1),p.push(t-e+1),p.push(t+2-2*e),p.push(t-e+2);}const l={vtype:[{name:"a_position",size:3},{name:"a_glow",size:1}],vertices:n,indices:p};this._mesh=new r$h(this._glenv,l);}_checkMaterials(){const s=this._viewer._render_cache||(this._viewer._render_cache={});s.sun_material||(s.sun_material=new a$1(this._viewer));}_deleteMaterials(){const s=this._viewer._render_cache;s&&s.sun_material&&s.sun_material.dispose();}draw(s,e,t){const i=this._viewer._render_cache.sun_material;i.bindProgram();i.setParameter(s,e,t,this._viewer.sun,this._radius,this._intensity,this._parameters)&&this._mesh.draw(i);}}const i$1=[.0128,.0176,.0264,.0312,.0344,.0408,.0456,.052,.064,.0792,.1,.1176,.148,.18,1],h=[255,247,200,172,157,131,115,99,76,58,43,35,26,20,0];

var n$9="/**\n * Modified from GPU Gems 2 (https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html)\n * Includes the following third-party code.\n *\n * s_p_oneil@hotmail.com\n * Copyright (c) 2000, Sean O'Neil\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of this project nor the names of its contributors\n *   may be used to endorse or promote products derived from this software\n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n/**\n * 太陽 (頂点シェーダ)\n */\n\nprecision mediump float;\n\nuniform mat4  u_gocs_to_clip;\nuniform mat4  u_billboard_matrix;\nuniform mat4  u_camera_direction_matrix;\nuniform vec3  u_sun_direction;\nuniform float u_sun_scale;\n\nuniform float u_intensity;\n\nattribute vec3 a_position;\nattribute vec2 a_texcoord;     // テクスチャ座標\n\nvarying vec4 v_color;\nvarying vec2 v_texcoord;       // テクスチャ座標\n\nconst float sun_length = 149597.870000;  // 1/1000000\n\nconst float GAMMA = 1.0 / 2.2;\n\n// <atmosphere\nuniform vec3  u_camera_position;    // The camera's current position\nuniform vec3  u_sun_vector;         // The direction vector to the light source\nuniform float u_camera_height;      // The camera's current height\nuniform float u_camera_height2;     // u_camera_height^2\nuniform float u_kr;                 // Kr\nuniform float u_km;                 // Km\nuniform float u_scale_depth;        // scale_depth\nuniform float u_esun;               // Kr\nuniform float u_exposure;           // Exposure\n\nconst float planet_radius = 6.378137;               // 1/1000000\nconst float atmosphere_radius = 6.378137 * 1.025;   // 1/1000000\n\nconst float PI = 3.14159265358932384626;\n\nconst vec3 inv_wave_length = vec3( 5.60204474633241, 9.47328443792304, 19.64380261047720 );\n\nconst float outer_radius  = atmosphere_radius;                      // The outer (atmosphere) radius\nconst float outer_radius2 = atmosphere_radius * atmosphere_radius;  // outer_radius^2\nconst float inner_radius  = planet_radius;                          // The inner (planetary) radius\nconst float inner_radius2 = planet_radius * planet_radius;          // inner_radius^2\n\nfloat Kr_ESun = u_kr * u_esun;      // Kr * ESun\nfloat Km_ESun = u_km * u_esun;      // Km * ESun\nfloat Kr_4PI  = u_kr * 4.0 * PI;    // Kr * 4 * PI\nfloat Km_4PI  = u_km * 4.0 * PI;    // Km * 4 * PI\n\nconst float radius_scale = 1.0 / ( atmosphere_radius - planet_radius );   // 1 / (outer_radius - inner_radius)\nfloat scale_over_scale_depth = radius_scale / u_scale_depth;              // radius_scale / scale_depth\n// atmosphere>\n\n\nfloat\nscale( float angle )\n{\n    float x = 1.0 - angle;\n    return u_scale_depth * exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * ( -6.80 + x * 5.25 ) ) ) );\n}\n// atmosphere>\n\nvoid\nmain()\n{\n    // <atmosphere\n    vec3  sun_pos    = -u_sun_vector * sun_length;\n    vec3  ray        = sun_pos - u_camera_position;\n    float far_length = length( ray );\n    ray /= far_length;\n\n    vec3  start_position = u_camera_position;\n\n    float start_height   = length( start_position );\n    float depth          = exp( scale_over_scale_depth * ( inner_radius - u_camera_height ) );\n\n    vec4 cam_vec      = u_camera_direction_matrix * vec4( 0.0, 0.0, 1.0, 1.0 );\n    float start_angle = dot( normalize( ray ), cam_vec.xyz );\n    start_angle       = clamp( start_angle, 0.0, 1.0 );\n    start_angle       = 1.0 - start_angle;\n\n    float up_angle = dot( normalize( start_position ), cam_vec.xyz );\n    up_angle       = clamp( up_angle, 0.0, 1.0 );\n    up_angle       = 1.0 - up_angle;\n\n    float scatter = depth * ( scale( start_angle ) - scale( up_angle ) );\n    vec3  FrontSecondaryColor = exp( -scatter * ( inv_wave_length * Kr_4PI + Km_4PI ) );\n    // atmosphere>\n\n\n    vec3 vertex_pos = a_position * u_sun_scale;\n    vec4 pos = u_gocs_to_clip * u_billboard_matrix * vec4( vertex_pos, 1.0 );\n    gl_Position = pos;\n\n    v_color = vec4( FrontSecondaryColor * u_intensity, 1.0 );\n\n    v_texcoord = a_texcoord;\n}\n";

var n$8="/**\n * 太陽 (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\nuniform sampler2D u_image;      // 画像\n\nvarying vec4 v_color;\nvarying vec2 v_texcoord;        // テクスチャ座標\n\nvoid\nmain()\n{\n    gl_FragColor = v_color * texture2D( u_image, v_texcoord );\n}\n";

class n$7 extends e$o{constructor(t,e){super(t.glenv,n$9,n$8),this._viewer=t,this._width=1024,this._height=1024,this._context=r$t.createCanvasContext(this._width,this._height),this._image=new t$d(t.glenv,this._context.canvas,{}),this.setImage(e);}setParameter(t,s,i,r,a,o,_){const h=i,c=h[12],u=h[13],m=h[14],l=[h[0],h[1],h[2],0,h[4],h[5],h[6],0,h[8],h[9],h[10],0,0,0,0,1];this.setMatrix("u_gocs_to_clip",s),this.setFloat("u_intensity",o),this.setMatrix("u_camera_direction_matrix",l),this.setVector3("u_sun_direction",r.sun_direction);const d=1e-6*Math.sqrt(c*c+u*u+m*m);this.setVector3("u_camera_position",[1e-6*c,1e-6*u,1e-6*m]),this.setVector3("u_sun_vector",r.sun_direction),this.setFloat("u_camera_height",d),this.setFloat("u_camera_height2",d*d),this.setFloat("u_kr",_.kr),this.setFloat("u_km",_.km),this.setFloat("u_scale_depth",_.scale_depth),this.setFloat("u_esun",_.esun),this.setFloat("u_exposure",_.exposure);const g=[h[8],h[9],h[10]],x=(t._viewer.camera.far-t._viewer.camera.near)/2+t._viewer.camera.near,p=[h[8]*x,h[9]*x,h[10]*x],f=c+p[0],M=u+p[1],v=m+p[2],w=14959787e4,I=w*r.sun_direction[0],F=w*r.sun_direction[1],j=w*r.sun_direction[2],T=[I-f,F-M,j-v];let b=e$z.dot3(p,g),E=e$z.dot3(T,g);if(Math.abs(b)<1e-6&&(b=0),Math.abs(E)<1e-6&&(E=0),!(b>=0&&E<=0||b<=0&&E>=0))return !1;const k=Math.abs(b),G=[I-c,F-u,j-m],A=k/(k+Math.abs(E)),N=c+G[0]*A,U=u+G[1]*A,V=m+G[2]*A;let X=l;X[12]=N,X[13]=U,X[14]=V,this.setMatrix("u_billboard_matrix",X);const q=N-c,C=U-u,D=V-m,y=Math.sqrt(q*q+C*C+D*D)/2.5*a;return this.setFloat("u_sun_scale",y),this.setInteger("u_image",n$7.TEXUNIT_IMAGE),this.bindTexture2D(n$7.TEXUNIT_IMAGE,this._image.handle),!0}setImage(t){if(this._image_src!==t){this._image_src=t;const e=t instanceof i$s?t:new s$p(t,{}),o=new c$2;this._icon=o.load(e),this._icon.onEnd((t=>{this._context.drawImage(t._icon,0,0,this._width,this._height),this._image=new t$d(this._viewer.glenv,this._context.canvas,{});}));}}}n$7.TEXUNIT_IMAGE=0;

var n$6="/**\n * 月 (頂点シェーダ)\n */\n\nprecision mediump float;\n\nuniform vec3  u_sun_direction;\nuniform mat4  u_moon_matrix;\n\nuniform mat4  u_billboard_matrix;\nuniform float u_moon_scale;\n\nattribute vec3 a_position;\nattribute vec2 a_texcoord;     // テクスチャ座標\n\nvarying vec4 v_color;\nvarying vec2 v_texcoord;       // テクスチャ座標\n\n\n#ifndef MASK_MOON\nfloat sigmoid( float a, float x )\n{\n    return 1.0 / ( 1.0 + exp( -( a * x )) );\n}\n#endif\n\nvoid\nmain()\n{\n    vec3 moon =  mat3( u_moon_matrix ) * a_position;\n    gl_Position = u_billboard_matrix * vec4( moon, 1.0 );\n\n#ifndef MASK_MOON\n    // lighting\n    float moon_light = sigmoid ( 5.0, dot( u_sun_direction, normalize( moon ) ) );\n    v_color = vec4( moon_light, moon_light, moon_light, 1.0 );\n    v_texcoord = a_texcoord;\n#endif\n\n}\n";

var n$5="/**\n * 月 (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\n#ifndef MASK_MOON\nuniform sampler2D u_image;      // 画像\n\nvarying vec4 v_color;\nvarying vec2 v_texcoord;        // テクスチャ座標\n#endif\n\nvoid\nmain()\n{\n#ifdef MASK_MOON\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n#else\n    gl_FragColor = v_color * texture2D( u_image, v_texcoord );\n#endif\n}\n";

class c extends e$o{constructor(t,e,s={}){const i=c._getPreamble(s);super(t.glenv,i+n$6,i+n$5),this._viewer=t,this._mask_mode=void 0!==s.mask&&s.mask,this._matrix_1=e$z.createMatrix(),this._matrix_2=e$z.createMatrix(),this._mask_mode||(this._width=512,this._height=512,this._context=r$t.createCanvasContext(this._width,this._height),this._image=new t$d(t.glenv,this._context.canvas,{}),this.setImage(e));}static _getPreamble(t){const e=[];return void 0!==t.mask&&t.mask&&e.push("#define MASK_MOON"),e.join("\n")+"\n\n"}setParameter(t,e,s,i,r,a,n){const h=e$z.createVector3([s[12],s[13],s[14]]),_=e$z.createVector3([s[8],s[9],s[10]]),m=e$z.createVector3(),d=r.moon_direction,u=this._viewer.camera.near+1737150+10,l=e$z.scale3(u,_,e$z.createVector3()),x=e$z.add3(h,l,e$z.createVector3()),g=e$z.scale3(3844e5,d,e$z.createVector3()),M=e$z.sub3(g,x,e$z.createVector3());let f=e$z.dot3(l,_),I=e$z.dot3(M,_);if(Math.abs(f)<1e-6&&(f=0),Math.abs(I)<1e-6&&(I=0),!(f>=0&&I<=0||f<=0&&I>=0))return !1;const v=this._viewer.camera.canvas_size;this.setVector2("u_resolution",[v.width/2,v.height/2]),this.setFloat("u_radius",a),this.setFloat("u_intensity",n),this.setVector3("u_sun_direction",i.sun_direction),this.setVector3("u_moon_direction",d),!1===this._mask_mode&&(this.setInteger("u_image",c.ListOfTextureUnit.TEXUNIT_IMAGE),this.bindTexture2D(c.ListOfTextureUnit.TEXUNIT_IMAGE,this._image.handle));const E=this._matrix_1,T=this._matrix_2,b=Math.abs(f),w=b/(b+Math.abs(I)),p=e$z.sub3(g,h,m),V=e$z.add3(h,e$z.scale3(w,p,m),e$z.createVector3());let A=e$z.setIdentity(E);A[12]=V[0],A[13]=V[1],A[14]=V[2];const j=e$z.mul_GA(e,A,E);this.setMatrix("u_billboard_matrix",j);const G=e$z.length3(e$z.sub3(V,h,m))/e$z.length3(e$z.sub3(M,h,m))*a*173715,U=e$z.setIdentity(E);U[0]=U[5]=U[10]=G;{const t=e$z.setIdentity(T),e=Math.atan2(d[0],d[1])+90*e$z.DEGREE,s=Math.sin(e),i=Math.cos(e);t[0]=i,t[1]=s,t[4]=-s,t[5]=i,e$z.mul_AA(U,t,U);}{const t=e$z.setIdentity(T),e=-(5.14+23.44)*e$z.DEGREE,s=Math.sin(e),i=Math.cos(e);t[0]=i,t[2]=-s,t[8]=s,t[10]=i,e$z.mul_AA(U,t,U);}return this.setMatrix("u_moon_matrix",U),!0}setImage(t){if(this._image_src===t)return;this._image_src=t;const a=t instanceof i$s?t:new s$p(t,{}),o=new c$2;this._icon=o.load(a),this._icon.onEnd((t=>{this._context.drawImage(t._icon,0,0,this._width,this._height),this._image=new t$d(this._viewer.glenv,this._context.canvas,{});}));}}!function(t){var e;(e=t.ListOfTextureUnit||(t.ListOfTextureUnit={}))[e.TEXUNIT_IMAGE=0]="TEXUNIT_IMAGE";}(c||(c={}));

var n$4="/**\n * 雲 (頂点シェーダ)\n */\n\nprecision mediump float;\n\nuniform mat4  u_gocs_to_clip;\nuniform vec3  u_sun_direction;\nuniform float u_intensity;\nuniform float u_margin;\n\nuniform float u_cloud_frame;\n\nattribute vec3 a_position;\nattribute vec2 a_cloud;     // 雲量パラメータ 2ch\n\nvarying float v_light;\nvarying float v_level;\n\nconst float planet_factor = 637813.7;\n\nconst float value_rate = 255.0;\n\nfloat sigmoid( float a, float x )\n{\n    return 1.0 / ( 1.0 + exp( -( a * x )) );\n}\n\nvoid\nmain()\n{\n    vec3 atmosphere_position = a_position * planet_factor;\n    gl_Position = u_gocs_to_clip * vec4( atmosphere_position, 1.0 );\n\n    // 影面\n    vec3 cloud_vert_normal = normalize( atmosphere_position );\n    float cloud_light = dot( u_sun_direction, cloud_vert_normal );\n    cloud_light = sigmoid( 5.0, cloud_light );\n\n    // from と to を合成\n    float cloud_level1 = a_cloud.x / value_rate * ( 1.0 - u_cloud_frame );\n    float cloud_level2 = a_cloud.y / value_rate * u_cloud_frame;\n    float cloud_level = clamp ( cloud_level1 + cloud_level2, 0.0, 1.0 );\n \n    v_light = clamp( cloud_light + u_intensity, 0.0, 1.0 ); // u_intensityでlightの有無(強度)を切り替え\n\n    v_level = cloud_level * (1.0 - 2.0 * u_margin) + u_margin;\n}\n";

var o$1="/**\n * 雲 (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\nuniform sampler2D u_image;      // contour画像\nuniform float u_margin;\n\nvarying float v_light;\nvarying float v_level;\n\nvoid\nmain()\n{\n    vec4 color = texture2D( u_image, vec2( v_level, 0.5 ) );\n    color.r /= color.a;\n    color.g /= color.a;\n    color.b /= color.a;\n    gl_FragColor = vec4( color.r * v_light, color.g * v_light, color.b * v_light, color.a );\n}\n";

class n$3 extends e$o{constructor(t,e,i=m$1.GradientMode.LINEAR){super(t.glenv,n$4,o$1),this._viewer=t,this._gradient_mode=i,this._margin=0,this._image=this._createImage(e,i);}setParameter(t,e,i,r,s,a){return this.setMatrix("u_gocs_to_clip",e),this.setFloat("u_intensity",a),this.setFloat("u_margin",this._margin),this.setVector3("u_sun_direction",r.sun_direction),this.setFloat("u_cloud_frame",s),this.setInteger("u_image",n$3.ListOfTextureUnit.TEXUNIT_IMAGE),this.bindTexture2D(n$3.ListOfTextureUnit.TEXUNIT_IMAGE,this._image.handle),!0}_createImage(t,r){this._width=t.length,this._height=1;const s=r$t.createCanvasContext(this._width,this._height),n=s.createImageData(this._width,this._height);let _,h=0;for(let e=0;e<t.length;e++)n.data[h++]=255*t[e][0],n.data[h++]=255*t[e][1],n.data[h++]=255*t[e][2],n.data[h++]=255*t[e][3];return s.putImageData(n,0,0),r===m$1.GradientMode.STEP?(this._margin=0,_=this._viewer.glenv.context.NEAREST):(this._margin=.5/t.length,_=this._viewer.glenv.context.LINEAR),new t$d(this._viewer.glenv,s.canvas,{wrap_s:this._viewer.glenv.context.CLAMP_TO_EDGE,wrap_t:this._viewer.glenv.context.CLAMP_TO_EDGE,mag_filter:_,min_filter:_})}}!function(t){var e;(e=t.ListOfTextureUnit||(t.ListOfTextureUnit={}))[e.TEXUNIT_IMAGE=0]="TEXUNIT_IMAGE";}(n$3||(n$3={}));var _=n$3;

class g{constructor(e={}){this._loaded_image_src=[void 0,void 0],this._initial_from_image_src=e.from_image,this._initial_to_image_src=e.to_image,this._vertices=[],this._indices=[],this._height=e.height||1e4,this._fade=0,this._imageArray=[],this._imageArray[g.ImageTarget.FROM]=[],this._imageArray[g.ImageTarget.TO]=[],this._gradient_array=e.gradient_array||[e$z.createVector4([1,1,1,0]),e$z.createVector4([1,1,1,1])],this._gradient_mode=e.gradient_mode||g.GradientMode.LINEAR;}init(e){this._viewer=e,this._glenv=e.glenv,this._visibility=!0,this._intensity=1,this._fade=0,this._image_width=g.CLOUD_WIDTH,this._image_height=g.CLOUD_HEIGHT,this._context=r$t.createCanvasContext(this._image_width,this._image_height),this._imageArray[g.ImageTarget.FROM].length=this._image_width*this._image_height,this._imageArray[g.ImageTarget.FROM].fill(0),this._imageArray[g.ImageTarget.TO].length=this._image_width*this._image_height,this._imageArray[g.ImageTarget.TO].fill(0),this._checkMaterials(),this._createMesh(),this.loadData(this._initial_from_image_src,this._initial_to_image_src);}destroy(){this._deleteMaterials(),this._mesh&&this._mesh.dispose();}get visibility(){return this._visibility}setVisibility(e){this._visibility=e;}setFade(e){this._fade=e;}setIntensity(e){this._intensity=e;}_createMesh(){let e,a,s,r,_,h,m,d;const o=10*(1+this._height/e$z.EARTH_RADIUS);let n=0;this._vertices=[],this._indices=[];for(let i=0;i<this._image_height;i++){r=.25*i*e$z.DEGREE,_=Math.sin(r),h=Math.cos(r);for(let i=0;i<this._image_width;i++)e=.25*i*e$z.DEGREE,a=Math.sin(e),s=Math.cos(e),this._vertices.push(s*_*o),this._vertices.push(a*_*o),this._vertices.push(h*o),this._vertices.push(this._imageArray[g.ImageTarget.FROM][n]),this._vertices.push(this._imageArray[g.ImageTarget.TO][n]),n++;}for(let e=0;e<this._image_height-1;e++)for(let i=0;i<this._image_width;i++)m=e*this._image_width+i,d=m+this._image_width,this._indices.push(m),this._indices.push(d),this._indices.push(m+1),this._indices.push(m+1),this._indices.push(d),e===this._image_height-2&&i===this._image_width-1?this._indices.push(d-(this._image_width-1)):this._indices.push(d+1);const c={vtype:[{name:"a_position",size:3},{name:"a_cloud",size:2}],vertices:this._vertices,indices:this._indices};this._mesh&&this._mesh.dispose(),this._mesh=new r$h(this._glenv,c);}_updateMesh(){if(!this._mesh)throw new Error("Illegal State: mesh was not created.");const e=this._imageArray[g.ImageTarget.FROM],t=this._imageArray[g.ImageTarget.TO];let a=0,s=3;for(let i=0;i<this._image_height;i++)for(let i=0;i<this._image_width;i++)this._vertices[s++]=e[a],this._vertices[s]=t[a++],s+=4;const r={vtype:[{name:"a_position",size:3},{name:"a_cloud",size:2}],vertices:this._vertices,indices:this._indices};this._mesh&&this._mesh.dispose(),this._mesh=new r$h(this._glenv,r);}_checkMaterials(){const e=this._viewer._render_cache||(this._viewer._render_cache={});e.cloud_material||(e.cloud_material=new _(this._viewer,this._gradient_array,this._gradient_mode));}_updateMaterials(){const e=this._viewer._render_cache||(this._viewer._render_cache={});e.cloud_material?(e&&e.cloud_material&&e.cloud_material.dispose(),e.cloud_material=new _(this._viewer,this._gradient_array,this._gradient_mode)):e.cloud_material=new _(this._viewer,this._gradient_array,this._gradient_mode);}_deleteMaterials(){const e=this._viewer._render_cache;e&&e.cloud_material&&e.cloud_material.dispose();}draw(e,i,t){if(!this._mesh)return;const a=this._viewer._render_cache.cloud_material;a.bindProgram();a.setParameter(e,i,t,this._viewer.sun,this._fade,this._intensity)&&this._mesh.draw(a);}setGradient(e,i=g.GradientMode.LINEAR){this._gradient_array=e,this._gradient_mode=i,this._updateMaterials();}loadFrom(i,t=-1){return __awaiter(this,void 0,void 0,(function*(){const e=this._loaded_image_src[g.ImageTarget.TO];return yield this._loadImages(i,e,t)}))}loadTo(i,t=-1){return __awaiter(this,void 0,void 0,(function*(){const e=this._loaded_image_src[g.ImageTarget.FROM];return yield this._loadImages(e,i,t)}))}loadData(i,t,a=-1){return __awaiter(this,void 0,void 0,(function*(){return this._loadImages(i,t||i,a)}))}pushFront(i,t=-1){return __awaiter(this,void 0,void 0,(function*(){const e=this._loaded_image_src[g.ImageTarget.FROM];return yield this._loadImages(i,e,t)}))}pushBack(i,t=-1){return __awaiter(this,void 0,void 0,(function*(){const e=this._loaded_image_src[g.ImageTarget.TO];return yield this._loadImages(e,i,t)}))}_loadImages(i,t,a=-1){return __awaiter(this,void 0,void 0,(function*(){let e=this._loaded_image_src[g.ImageTarget.TO],s=this._loaded_image_src[g.ImageTarget.FROM];if(e===t&&s===i);else {let a=!1;const r=[];if(e===i||s===t){if(i===t)s!==i?this._imageArray[g.ImageTarget.FROM]=this._imageArray[g.ImageTarget.TO].concat():this._imageArray[g.ImageTarget.TO]=this._imageArray[g.ImageTarget.FROM].concat();else {const i=this._imageArray[g.ImageTarget.TO];this._imageArray[g.ImageTarget.TO]=this._imageArray[g.ImageTarget.FROM],this._imageArray[g.ImageTarget.FROM]=i,this._loaded_image_src[g.ImageTarget.FROM]=e,this._loaded_image_src[g.ImageTarget.TO]=s,s=this._loaded_image_src[g.ImageTarget.FROM],e=this._loaded_image_src[g.ImageTarget.TO];}a=!0;}s!==i&&(r.push(this._loadImageData(i,this._imageArray[g.ImageTarget.FROM])),this._loaded_image_src[g.ImageTarget.FROM]=i,a=!0),e!==t&&(r.push(this._loadImageData(t,this._imageArray[g.ImageTarget.TO])),this._loaded_image_src[g.ImageTarget.TO]=t,a=!0),r.length>0&&(yield Promise.all(r)),a&&this._updateMesh();}-1!==a&&(this._fade=a);}))}_loadImageData(i,t){return __awaiter(this,void 0,void 0,(function*(){if(i){let e;if(i instanceof HTMLImageElement||i instanceof HTMLCanvasElement)e=i;else {const t=i instanceof i$s?i:new s$p(i.toString(),{}),a=(new c$2).load(t);e=yield new Promise(((e,t)=>{a.onEnd((s=>{a.isLoaded()?e(s._icon):t("image load error: "+i);}));}));}this._context.drawImage(e,0,0,this._image_width,this._image_height);const a=this._context.getImageData(0,0,this._image_width,this._image_height).data;for(let e=0;e<t.length;e++)t[e]=a[4*e];}else for(let e=0;e<t.length;e++)t[e]=0;return t}))}}g.CLOUD_WIDTH=1440,g.CLOUD_HEIGHT=722,function(e){var i,t;(i=e.ImageTarget||(e.ImageTarget={}))[i.FROM=0]="FROM",i[i.TO=1]="TO",(t=e.GradientMode||(e.GradientMode={}))[t.LINEAR=0]="LINEAR",t[t.STEP=1]="STEP";}(g||(g={}));var m$1=g;

var n$2="/**\n * 天の川 (頂点シェーダ)\n */\n\nprecision mediump float;\n\nuniform mat4  u_longitude_matrix;\nuniform float u_intensity;\n\nattribute vec3 a_position;\nattribute vec2 a_texcoord;     // テクスチャ座標\n\nvarying vec2 v_texcoord;       // テクスチャ座標\nvarying vec4 v_intensity;\n\nconst float parsec_factor = 3085677581000000.0;    //parsec\n\nvoid\nmain()\n{\n    vec3 position = a_position * parsec_factor;\n\n    gl_Position = u_longitude_matrix * vec4( position, 1.0 );\n\n    v_texcoord = a_texcoord;\n\n    v_intensity = vec4 ( vec3 ( u_intensity ), 1.0 );\n}\n";

var n$1="/**\n * 天の川 (フラグメントシェーダ)\n */\n\nprecision mediump float;\n\nuniform sampler2D u_image;      // 画像\n\nvarying vec2 v_texcoord;        // テクスチャ座標\nvarying vec4 v_intensity;\n\nvoid\nmain()\n{\n    gl_FragColor = texture2D( u_image, v_texcoord ) * v_intensity;\n}\n";

class m extends e$o{constructor(t,i){super(t.glenv,n$2,n$1),this._width=512,this._height=512,this._context=r$t.createCanvasContext(this._width,this._height),this._matrix=e$z.createMatrix(),this._image=new t$d(t.glenv,this._context.canvas,{}),this.setImage(i);}setParameter(t,i,e,s){const r=e*e$z.DEGREE,a=Math.sin(r),o=Math.cos(r),h=e$z.setIdentity(this._matrix);h[0]=o,h[1]=a,h[4]=-a,h[5]=o;const _=e$z.mul_GA(i,h,this._matrix);this.setMatrix("u_longitude_matrix",_),this.setFloat("u_intensity",s),this.setInteger("u_image",m.ListOfTextureUnit.TEXUNIT_IMAGE),this.bindTexture2D(m.ListOfTextureUnit.TEXUNIT_IMAGE,this._image.handle);}setImage(t){if(this._image_src===t)return;this._image_src=t;const a=t instanceof i$s?t:new s$p(t,{}),n=new c$2;this._icon=n.load(a),this._icon.onEnd((t=>{this._context.drawImage(t._icon,0,0,this._width,this._height),this._image=new t$d(this.glenv,this._context.canvas,{});}));}}!function(t){var i;(i=t.ListOfTextureUnit||(t.ListOfTextureUnit={}))[i.TEXUNIT_IMAGE=0]="TEXUNIT_IMAGE";}(m||(m={}));

var a=e$z,i=r$z;class r extends t$u{constructor(e,i,o={}){super(),this._default_fov=r.DEFAULT_CAMERA_PARAMETER.fov,this.createViewer(e,i,o),this._camera_parameter={latitude:0,longitude:0,height:0,pitch:0,yaw:0,fov:0,near:0,far:0,roll:0,speed_factor:2e3},this._operation_mode=r.OperationMode.NONE,this._mouse_down_position=[0,0],this._pre_mouse_position=[0,0],this._rotate_center=a.createVector3(),this._translate_drag=a.createVector2f(),this._translate_eye_drag=a.createVector2f(),this._rotate_drag=a.createVector2f(),this._free_rotate_drag=a.createVector2f(),this._height_drag=a.createVector2f(),this._zoom_wheel=0,this._fovy_key=0,this._default_fov=r.DEFAULT_CAMERA_PARAMETER.fov,this._key_mode=!1,this._update_url_hash=!1,this._update_url_hash_backup=!1,this._update_url_hash_full_digits=!1,this._last_camera_parameter={latitude:-1,longitude:-1,height:0,pitch:0,yaw:0,fov:0,near:0,far:0,roll:0,speed_factor:2e3},this._viewer_camera_mode=r.CameraMode.CAMERA_FREE,this._animation=new i$u,this._updater=new s$s,this._flycamera_total_time=0,this._flycamera_target_time=0,this._altitude_range={min:r.ALTITUDE_RANGE.min,max:r.ALTITUDE_RANGE.max||Number.MAX_VALUE},this._buf_matrix1=a.createMatrix(),this._buf_matrix2=a.createMatrix(),this._initCameraParameter(o),this._controllable=!0,this._addEventListener();}createViewer(e,a,i={}){this._viewer&&this.destroy();const r=(this._viewer=new x(e,{dem_provider:this.createDemProvider(a,i),image_provider:this.createImageProvider(i),layers:i.layers,render_callback:this,ground_visibility:!(!1===i.ground_visibility),entity_visibility:!(!1===i.entity_visibility),render_mode:i.render_mode||"@@_Viewer.RenderMode.SURFACE",debug_stats:i.debug_stats,attribution_controller:i.attribution_controller,atmosphere:i.atmosphere,sun_visualizer:i.sun_visualizer,moon_visualizer:i.moon_visualizer,cloud_visualizer:i.cloud_visualizer,star_visualizer:i.star_visualizer,pole:i.pole})).canvas_element;return r.setAttribute("oncontextmenu","return false;"),r.setAttribute("tabindex","0"),this._viewer}destroy(){this._viewer&&(this._removeEventListener(),this._viewer.destroy());}get viewer(){return this._viewer}createDemProvider(e,a){return a.dem_provider||new r$a(e)}createImageProvider(e){return e.image_provider||new o$d("https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/",".jpg",256,2,18)}_initCameraParameter(e){const t=e.camera_position||r.DEFAULT_CAMERA_POSITION,a=e.lookat_position||r.DEFAULT_LOOKAT_POSITION,i=e.camera_parameter||r.DEFAULT_CAMERA_PARAMETER;this.setCameraPosition(t),this.setLookAtPosition(a),this.setCameraParameter(i),this.updateCamera();}enableURLUpdate(e){e&&this._restoreCameraParameterFromHash(),this._update_url_hash=!0;}disableURLUpdate(){this._update_url_hash=!1;}_onHashChange(){this._restoreCameraParameterFromHash();}_restoreCameraParameterFromHash(){const e=this.getCameraParameterFromHash(window.location.hash);e&&(this.setCameraPosition(e.camera_position),this.setLookAtPosition(e.lookat_position,e.yaw),this.updateCamera());}getCameraParameterFromHash(e){if(e.length<3)return;"#"===e[0]&&(e=e.slice(1));const t=e.split("/");if(t.length<2)return;const r=parseFloat(t[0]),o=parseFloat(t[1]);if(isNaN(r)||isNaN(o))return;const s={};for(let e=2;e<t.length;e++){const a=t[e],i=a.slice(-1),r=parseFloat(a.slice(0,-1));isNaN(r)||(s[i]=r);}const _=void 0!==s.a?s.a:8e3,n=void 0!==s.r?s.r:1e3,h=void 0!==s.t?s.t:0,m=void 0!==s.h?s.h:0,c=h*a.DEGREE,d=n*Math.cos(c),l=n*Math.sin(c),u=this._getOffsetPoint(o,r,l,m,new i);return {camera_position:{height:_+d,longitude:u.longitude,latitude:u.latitude},lookat_position:{height:_,longitude:o,latitude:r},yaw:m}}_addEventListener(){const e=this.viewer.canvas_element;this._onBlur=this._onBlur.bind(this),this._onMouseDown=this._onMouseDown.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this._onMouseUp=this._onMouseUp.bind(this),this._onMouseWheel=this._onMouseWheel.bind(this),this._onKeyDown=this._onKeyDown.bind(this),this._onKeyUp=this._onKeyUp.bind(this),this._onHashChange=this._onHashChange.bind(this),window.addEventListener("blur",this._onBlur,{passive:!1}),e.addEventListener("mousedown",this._onMouseDown,{passive:!0}),e.addEventListener("mousemove",this._onMouseMove,{passive:!0}),document.addEventListener("mousemove",this._onMouseMove,{capture:!0}),e.addEventListener("mouseup",this._onMouseUp,{passive:!0}),document.addEventListener("mouseup",this._onMouseUp,{capture:!1}),e.addEventListener("wheel",this._onMouseWheel,{passive:!1}),e.addEventListener("keydown",this._onKeyDown,{capture:!1,passive:!1}),e.addEventListener("keyup",this._onKeyUp,{passive:!0}),window.addEventListener("hashchange",this._onHashChange,{passive:!1});}_removeEventListener(){const e=this.viewer.canvas_element;window.removeEventListener("blur",this._onBlur,{passive:!1}),e.removeEventListener("mousedown",this._onMouseDown,{passive:!0}),e.removeEventListener("mousemove",this._onMouseMove,{passive:!0}),document.removeEventListener("mousemove",this._onMouseMove,{capture:!0}),e.removeEventListener("mouseup",this._onMouseUp,{passive:!0}),document.removeEventListener("mouseup",this._onMouseUp,{capture:!1}),e.removeEventListener("wheel",this._onMouseWheel,{passive:!1}),e.removeEventListener("keydown",this._onKeyDown,{capture:!1,passive:!1}),e.removeEventListener("keyup",this._onKeyUp,{passive:!0}),window.removeEventListener("hashchange",this._onHashChange,{passive:!1});}onStart(){}onStop(){}onUpdateFrame(e){this._viewer_camera_mode===r.CameraMode.CAMERA_FLY?this.updateFlyCamera(e):(this._controllable&&(this.updateTranslation(e),this.updateRotation(e),this._freeRotation(e),this.updateTranslationOfHeight(),this.updateTranslationOfEyeDirection()),this._changeFovy(),this._correctAltitude(),this.updateClipPlane(),this.updateCamera());}updateCamera(){const e=this.viewer.camera,t=this._buf_matrix1,r=this._buf_matrix2,o=new i(this._camera_parameter.longitude,this._camera_parameter.latitude,this._camera_parameter.height),s=a.rotation_matrix([1,0,0],this._camera_parameter.pitch,t),_=a.rotation_matrix([0,0,1],this._camera_parameter.yaw,r),n=a.mul_AA(_,s,r),h=o.getMlocsToGocsMatrix(t);a.mul_AA(h,n,e.view_to_gocs),e.fov=this._camera_parameter.fov,e.near=this._camera_parameter.near,e.far=this._camera_parameter.far,this._updateURLHash();}_updateURLHash(){if(!this._update_url_hash||this._operation_mode!==r.OperationMode.NONE)return;if(this._last_camera_parameter.latitude!==this._camera_parameter.latitude||this._last_camera_parameter.longitude!==this._camera_parameter.longitude||this._last_camera_parameter.height!==this._camera_parameter.height||this._last_camera_parameter.pitch!==this._camera_parameter.pitch||this._last_camera_parameter.yaw!==this._camera_parameter.yaw){const e=this.createCameraParameterHash();e&&(this._last_camera_parameter.latitude=this._camera_parameter.latitude,this._last_camera_parameter.longitude=this._camera_parameter.longitude,this._last_camera_parameter.height=this._camera_parameter.height,this._last_camera_parameter.pitch=this._camera_parameter.pitch,this._last_camera_parameter.yaw=this._camera_parameter.yaw,window.location.hash!==e&&history.replaceState(null,window.location.hash,e));}}createCameraParameterHash(){const e=this.viewer,i=e.canvas_element,r=a.createVector2([i.width/2,i.height/2]),o=e.camera.getCanvasRay(r,new o$o),s=e.pickWithRay(o);if(!s)return;const _=s.position,n=new r$z;n.setFromGocs(_),n.altitude=e.getElevation(n.latitude,n.longitude),n.getAsGocs(_);const h=e.camera,m=a.length3(a.createVector3([h.view_to_gocs[12]-_[0],h.view_to_gocs[13]-_[1],h.view_to_gocs[14]-_[2]])),c=n.latitude,d=n.longitude,l=n.altitude,u=this._camera_parameter.pitch,p=m,g=this._camera_parameter.yaw;return "#"+(this._update_url_hash_full_digits?c+"/"+d+"/"+l+"a/"+u+"t/"+p+"r/"+g+"h":c.toFixed(10)+"/"+d.toFixed(10)+"/"+l.toFixed(5)+"a/"+u.toFixed(5)+"t/"+p.toFixed(5)+"r/"+g.toFixed(5)+"h")}updateClipPlane(){const e=this.viewer.getElevation(this._camera_parameter.latitude,this._camera_parameter.longitude),t=a.clamp(this._camera_parameter.height-e,this._altitude_range.min,this._altitude_range.max);this._camera_parameter.near=Math.max(t*r.NEAR_FACTOR,r.MINIMUM_NEAR),this._camera_parameter.far=Math.max(this._camera_parameter.near*r.FAR_FACTOR,r.MINIMUM_FAR);}_correctAltitude(){const e=this.viewer.getElevation(this._camera_parameter.latitude,this._camera_parameter.longitude);this._camera_parameter.height=a.clamp(this._camera_parameter.height,e+this._altitude_range.min,e+this._altitude_range.max);}setCameraAltitudeRange(e,t=Number.MAX_VALUE){if(e>t)throw new Error("Illegal Argument");this._altitude_range.min=e,this._altitude_range.max=t,this._correctAltitude();}resetOpEvent(){this._resetEventParameter();}onBlur(e){this._resetEventParameter();}_onBlur(e){this.onBlur(e);}onMouseDown(e,t){const a=this.viewer;if(this._mouse_down_position=e,this._pre_mouse_position=e,0===t.button)if(t.shiftKey){this._operation_mode=r.OperationMode.ROTATE;const e=a.camera.getCanvasRay(this._mouse_down_position),t=a.pickWithRay(e);this._rotate_center=t?t.position:void 0;}else t.ctrlKey?this._operation_mode=r.OperationMode.FREE_ROTATE:this._operation_mode=r.OperationMode.TRANSLATE;else if(1===t.button){this._operation_mode=r.OperationMode.ROTATE;const e=a.camera.getCanvasRay(this._mouse_down_position),t=a.pickWithRay(e);this._rotate_center=t?t.position:void 0;}else 2===t.button&&(this._operation_mode=t.shiftKey?r.OperationMode.HEIGHT_TRANSLATE:r.OperationMode.EYE_TRANSLATE);}_onMouseDown(e){const t=this._mousePos(this.viewer.canvas_element,e);this.onMouseDown(t,e);}onMouseMove(e,t){const a=e;this._operation_mode===r.OperationMode.TRANSLATE?(this._translate_drag[0]+=a[0]-this._pre_mouse_position[0],this._translate_drag[1]+=a[1]-this._pre_mouse_position[1]):this._operation_mode===r.OperationMode.ROTATE?(this._rotate_drag[0]+=a[0]-this._pre_mouse_position[0],this._rotate_drag[1]+=a[1]-this._pre_mouse_position[1]):this._operation_mode===r.OperationMode.FREE_ROTATE?(this._free_rotate_drag[0]+=a[0]-this._pre_mouse_position[0],this._free_rotate_drag[1]+=a[1]-this._pre_mouse_position[1]):this._operation_mode===r.OperationMode.HEIGHT_TRANSLATE?(this._translate_drag[0]+=a[0]-this._pre_mouse_position[0],this._height_drag[1]+=a[1]-this._pre_mouse_position[1]):this._operation_mode===r.OperationMode.EYE_TRANSLATE&&(this._translate_eye_drag[1]+=a[1]-this._pre_mouse_position[1]),this._pre_mouse_position=a;}_onMouseMove(e){const t=this._mousePos(this.viewer.canvas_element,e);this.onMouseMove(t,e);}onMouseUp(e,t){this._resetEventParameter();}_onMouseUp(e){const t=this._mousePos(this.viewer.canvas_element,e);this.onMouseUp(t,e);}onMouseWheel(e,t){if(t.preventDefault(),this._viewer_camera_mode!=r.CameraMode.CAMERA_FREE)return;this._mouse_down_position=e;const a=-1*Math.sign(t.deltaY)*Math.ceil(Math.abs(t.deltaY)/100);this._zoom_wheel+=a;}_onMouseWheel(e){const t=this._mousePos(this.viewer.canvas_element,e);this.onMouseWheel(t,e);}onKeyDown(e){switch(e.key){case"c":case"C":this._operation_mode=r.OperationMode.CHANGE_FOVY,this._fovy_key=1;break;case"z":case"Z":this._operation_mode=r.OperationMode.CHANGE_FOVY,this._fovy_key=-1;break;case"x":case"X":this._camera_parameter.fov=this._default_fov;break;case"ArrowUp":{e.preventDefault();const t=this.viewer.canvas_element,a=[t.width/2,t.height/2];this._mouse_down_position=a,this._translate_drag[1]=100,this._key_mode=!0;}break;case"ArrowDown":{e.preventDefault();const t=this.viewer.canvas_element,a=[t.width/2,t.height/2];this._mouse_down_position=a,this._translate_drag[1]=-100,this._key_mode=!0;}break;case"ArrowLeft":e.preventDefault(),this._free_rotate_drag[0]=100,this._key_mode=!0;break;case"ArrowRight":e.preventDefault(),this._free_rotate_drag[0]=-100,this._key_mode=!0;}}_onKeyDown(e){this.onKeyDown(e);}onKeyUp(e){switch(e.key){case"c":case"C":case"z":case"Z":this._operation_mode=r.OperationMode.NONE,this._fovy_key=0;break;case"ArrowUp":case"ArrowDown":this._operation_mode=r.OperationMode.NONE,this._translate_drag[1]=0,this._key_mode=!1;break;case"ArrowLeft":case"ArrowRight":this._operation_mode=r.OperationMode.NONE,this._free_rotate_drag[0]=0,this._key_mode=!1;}}_onKeyUp(e){this.onKeyUp(e);}_resetEventParameter(){this._translate_drag[0]=0,this._translate_drag[1]=0,this._rotate_drag[0]=0,this._rotate_drag[1]=0,this._free_rotate_drag[0]=0,this._free_rotate_drag[1]=0,this._height_drag[0]=0,this._height_drag[1]=0,this._operation_mode=r.OperationMode.NONE;}updateTranslation(e){const i=this.viewer;if(0!==this._translate_drag[0]||0!==this._translate_drag[1]){this._key_mode&&(this._translate_drag[0]*=e,this._translate_drag[1]*=e);const r=i.camera;let o=r.getCanvasRay(this._mouse_down_position);const s=i.pickWithRay(o),_=a.createVector2([this._mouse_down_position[0]+this._translate_drag[0],this._mouse_down_position[1]+this._translate_drag[1]]);o=r.getCanvasRay(_);const n=i.pickWithRay(o);if(!s||!n)return;const h=s.position,m=n.position,c=new r$z;c.setFromGocs(h);const d=new r$z;d.setFromGocs(m);const l=2*a.dot3(o.position,o.direction),u=l*l-4*(a.lengthSquared3(o.position)-Math.pow(c.altitude+a.EARTH_RADIUS,2));if(c.altitude<this._camera_parameter.height&&d.altitude<this._camera_parameter.height&&u>=0){const e=.5*(-l-Math.sqrt(u));a.add3(a.scale3(e,o.direction,m),o.position,m),d.setFromGocs(m);}const p=d.latitude-c.latitude,g=d.longitude-c.longitude,v=c.longitude-this._camera_parameter.longitude,E=v-360*Math.floor(v/360+.5);this._camera_parameter.latitude+=Math.abs(E)<90?-p:p,this._camera_parameter.longitude-=g,this._translate_drag[0]=0,this._translate_drag[1]=0,this._mouse_down_position=this._pre_mouse_position;}}updateRotation(e){if(0===this._rotate_drag[0]&&0===this._rotate_drag[1])return;if(!this._rotate_center)return this._rotate_drag[0]=0,void(this._rotate_drag[1]=0);const i=this.viewer.camera,r=a.createVector3([i.view_to_gocs[12],i.view_to_gocs[13],i.view_to_gocs[14]]),o=a.sub3(r,this._rotate_center,a.createVector3()),s=new r$z;s.setFromGocs(this._rotate_center);const _=s.getMlocsToGocsMatrix(a.createMatrix()),n=a.createVector3([_[8],_[9],_[10]]);a.normalize3(n,n);const h=-this._rotate_drag[0]/10,m=-this._rotate_drag[1]/10;let c=this.rotateVector(o,n,h);const d=a.clamp(this._camera_parameter.pitch+m,0,90);d!==this._camera_parameter.pitch&&(n[0]=i.view_to_gocs[0],n[1]=i.view_to_gocs[1],n[2]=i.view_to_gocs[2],c=this.rotateVector(c,n,m));const l=a.add3(this._rotate_center,c,a.createVector3()),u=new r$z;u.setFromGocs(l),this._camera_parameter.latitude=u.latitude,this._camera_parameter.longitude=u.longitude,this._camera_parameter.height=u.altitude,this._camera_parameter.yaw+=h,this._camera_parameter.pitch=d,this._rotate_drag[0]=0,this._rotate_drag[1]=0;}_freeRotation(e){if(0===this._free_rotate_drag[0]&&0===this._free_rotate_drag[1])return;this._key_mode&&(this._free_rotate_drag[0]*=e,this._free_rotate_drag[1]*=e);const t=this._free_rotate_drag[0]/10,i=this._free_rotate_drag[1]/10,r=a.clamp(this._camera_parameter.pitch+i,0,90);this._camera_parameter.yaw+=t,this._camera_parameter.pitch=r,this._free_rotate_drag[0]=0,this._free_rotate_drag[1]=0;}updateTranslationOfHeight(){if(0===this._height_drag[0]&&0===this._height_drag[1])return;const e=100*this._height_drag[1]*(a.gudermannian((this._camera_parameter.height-5e4)/1e4)+Math.PI/2);this._camera_parameter.height+=e,this._height_drag[0]=0,this._height_drag[1]=0;}updateTranslationOfEyeDirection(){let e=0;if(0!==this._zoom_wheel?(e=Math.pow(.9,this._zoom_wheel),this._zoom_wheel=0):0!==this._translate_eye_drag[1]&&(e=Math.pow(.995,this._translate_eye_drag[1]),this._translate_eye_drag[1]=0),0===e)return;const i=this.viewer,r=i.camera,o=r.getCanvasRay(this._mouse_down_position),s=i.pickWithRay(o);if(!s)return;const _=s.position,n=new r$z;n.setFromGocs(_);const h=a.createVector3();h[0]=(_[0]-r.view_to_gocs[12])*e,h[1]=(_[1]-r.view_to_gocs[13])*e,h[2]=(_[2]-r.view_to_gocs[14])*e;const m=a.sub3(_,h,a.createVector3()),c=new r$z;c.setFromGocs(m);const d=i.getElevation(c.latitude,c.longitude),l=d+this._altitude_range.min>c.altitude?d+this._altitude_range.min:d+this._altitude_range.max<c.altitude?d+this._altitude_range.max:void 0;if(l){const e=c.altitude-l,t=n.getUpwardVector(a.createVector3()),i=a.length3(h),r=a.dot3(h,t)/i;a.scale3(1-e/r/i,h,h),a.sub3(_,h,m),c.setFromGocs(m);}this._camera_parameter.latitude=c.latitude,this._camera_parameter.longitude=c.longitude,this._camera_parameter.height=c.altitude,this._zoom_wheel=0;}_changeFovy(){const e=Math.tan(.5*this._camera_parameter.fov*a.DEGREE),t=2*Math.atan(e*Math.pow(r.FOV_FACTOR,-this._fovy_key)),i=r.FOV_RANGE;this._camera_parameter.fov=a.clamp(t/a.DEGREE,i.min,i.max),this._fovy_key=0;}getCameraPosition(){const e=this._camera_parameter;return {longitude:e.longitude,latitude:e.latitude,height:e.height}}setCameraPosition(e){this._camera_parameter.latitude=e.latitude,this._camera_parameter.longitude=e.longitude,this._camera_parameter.height=e.height,this._camera_parameter.height=a.clamp(this._camera_parameter.height,this._altitude_range.min,this._altitude_range.max);}getCameraAngle(){const e=this._camera_parameter;return {roll:e.roll,pitch:e.pitch,yaw:e.yaw}}setCameraAngle(e){const t=this._camera_parameter;t.roll=e.roll,t.pitch=e.pitch,t.yaw=e.yaw;}_isSame(e,t,a=1e-6){return Math.abs(e-t)<a}setLookAtPosition(e,t=0){if(this._isSame(this._camera_parameter.longitude,e.longitude)&&this._isSame(this._camera_parameter.latitude,e.latitude))return this._camera_parameter.yaw=t,void(this._camera_parameter.pitch=0);const r=new i(this._camera_parameter.longitude,this._camera_parameter.latitude,this._camera_parameter.height).getMlocsToGocsMatrix(a.createMatrix()),o=new i(e.longitude,e.latitude,e.height).getMlocsToGocsMatrix(a.createMatrix()),s=a.createVector3([r[4],r[5],r[6]]);a.normalize3(s,s);const _=a.createVector3([o[12]-r[12],o[13]-r[13],o[14]-r[14]]);a.normalize3(_,_);let n=a.createVector3([r[8],r[9],r[10]]);const h=this.calculateAngle(n,s,_);this._camera_parameter.yaw=h;const m=a.createVector3([r[8],r[9],r[10]]),c=a.createVector3([r[0],r[1],r[2]]);n=this.rotateVector(c,n,h),a.scale3(-1,_,_);const d=a.clamp(Math.abs(this.calculateAngle(n,m,_)),0,90);this._camera_parameter.pitch=d;}getCameraParameter(){const e=this._camera_parameter;return {fov:e.fov,near:e.near,far:e.far,speed_factor:e.speed_factor}}setCameraParameter(e){e.fov&&(this._camera_parameter.fov=e.fov,this._default_fov=e.fov),e.near&&(this._camera_parameter.near=e.near),e.far&&(this._camera_parameter.far=e.far),e.speed_factor&&(this._camera_parameter.speed_factor=e.speed_factor);}getLayer(e){return this.viewer.layers.getLayer(e)}getLayerNum(){return this.viewer.layers.num_layers}addLayer(e){this.viewer.layers.add(e);}insertLayer(e,t){this.viewer.layers.insert(e,t);}removeLayer(e){this.viewer.layers.remove(e);}clearLayer(){this.viewer.layers.clear();}getEntity(e){return this.viewer.scene.getEntity(e)}getEntityNum(){return this.viewer.scene.num_entities}addEntity(e){this.viewer.scene.addEntity(e);}removeEntity(e){this._viewer.scene.removeEntity(e);}clearEntities(){this.viewer.scene.clearEntities();}rotateVector(e,t,i){const r=a.rotation_matrix(t,i,this._buf_matrix1),o=a.createVector3();return o[0]=e[0]*r[0]+e[1]*r[4]+e[2]*r[8]+r[12],o[1]=e[0]*r[1]+e[1]*r[5]+e[2]*r[9]+r[13],o[2]=e[0]*r[2]+e[1]*r[6]+e[2]*r[10]+r[14],o}calculateAngle(e,t,i){const r=a.createVector3(),o=a.createVector3(),s=e,_=a.createVector3();if(a.sub3(t,a.scale3(a.dot3(s,t),s,r),r),a.sub3(i,a.scale3(a.dot3(s,i),s,_),_),a.length3(r)<1e-6||a.length3(_)<1e-6)return 0;a.normalize3(r,r),a.normalize3(_,_),a.cross3(s,r,o);return Math.atan2(a.dot3(o,_),a.dot3(r,_))/a.DEGREE}_mousePos(e,t){const a=e.getBoundingClientRect();return [t.clientX-a.left-e.clientLeft,t.clientY-a.top-e.clientTop]}startFlyCamera(t){return __awaiter(this,void 0,void 0,(function*(){if(this._viewer_camera_mode!==r.CameraMode.CAMERA_FREE)throw new Error("viewer camera is not in CAMERA_FREE mode");if(null===t.time||void 0===t.time)throw new Error("time is not defined");if(!t.iscs_end)throw new Error("iscs_end is not defined");this._flycamera_total_time=0,this._flycamera_target_time=t.time;const e=this.createFlyCurve(this.viewer,t);this._curve_move=e.move,this._curve_rotation=e.rotation,this._setupAnimationBindingBlock(),this._animation.bind("position",this._updater,this._curve_move),this._animation.bind("orientation",this._updater,this._curve_rotation),this._update_url_hash_backup=this._update_url_hash,this._update_url_hash=!1,this._viewer_camera_mode=r.CameraMode.CAMERA_FLY,yield new Promise(((e,t)=>{this._flycamera_on_success=e;}));}))}_calculateKeyPoint(e,r){let o;if(r.iscs_start)o=r.iscs_start;else {const i=e.camera.view_to_gocs;o=new r$z,o.setFromGocs(a.createVector3([i[12],i[13],i[14]]));}const s=r.iscs_end,_=void 0!==r.end_from_lookat?r.end_from_lookat:2e4,n=void 0!==r.end_altitude?r.end_altitude:2e4,h=this._getOffsetPoint(s.longitude,s.latitude,_,0,new i);h.altitude=e.getElevation(h.latitude,h.longitude)+n,r.target_clamp,s.altitude=e.getElevation(s.latitude,s.longitude);const m=this._getLookAtAngle(h,s),c=new i(o.longitude,o.latitude,0),d=new i(s.longitude,s.latitude,0),l=Math.min(c.getGeographicalDistance(d),12e5),u=h.altitude+l,p=new i;p.assign(o),p.altitude=u;const g=new i;return g.assign(h),g.altitude=u,this.setCameraParameter({near:30,far:1e7}),{fly_iscs_start:o,fly_iscs_end:h,target_angle:m,start_top:p,end_top:g,heading:this._camera_parameter.yaw,tilt:this._camera_parameter.pitch,roll:0}}createFlyCurve(e,a){const i=this._calculateKeyPoint(e,a);let r=[],o=[],s=new a$k(s$u.find("vector3")),_=new a$k(s$u.find("vector3"));const n=i.fly_iscs_start,h=i.fly_iscs_end,m=this._flycamera_target_time/3;let c=!0;return n.altitude>i.start_top.altitude&&(c=!1),r.push(t$F.fromNumber(0)),r.push(e$z.createVector3([n.longitude,n.latitude,n.altitude])),c&&(r.push(t$F.fromNumber(m)),r.push(e$z.createVector3([i.start_top.longitude,i.start_top.latitude,i.start_top.altitude])),r.push(t$F.fromNumber(2*m)),r.push(e$z.createVector3([i.end_top.longitude,i.end_top.latitude,i.end_top.altitude]))),r.push(t$F.fromNumber(this._flycamera_target_time)),r.push(e$z.createVector3([h.longitude,h.latitude,h.altitude])),s.setKeyFrames(r),o.push(t$F.fromNumber(0)),o.push(e$z.createVector3([i.heading,i.tilt,i.roll])),c&&(o.push(t$F.fromNumber(m)),o.push(e$z.createVector3([i.heading,10,i.roll])),o.push(t$F.fromNumber(2*m)),o.push(e$z.createVector3([i.heading,10,i.roll]))),o.push(t$F.fromNumber(this._flycamera_target_time)),o.push(e$z.createVector3([i.target_angle.heading,-1*i.target_angle.tilt,this._camera_parameter.roll])),_.setKeyFrames(o),{move:s,rotation:_}}updateFlyCamera(e){this._flycamera_total_time+=e,this._updater.update(t$F.fromNumber(this._flycamera_total_time)),this._flycamera_total_time>=this._flycamera_target_time&&this.onEndFlyCamera();}onEndFlyCamera(){this._animation.unbind("position"),this._animation.unbind("orientation"),this._curve_move=void 0,this._curve_rotation=void 0,this._update_url_hash=this._update_url_hash_backup,this._viewer_camera_mode=r.CameraMode.CAMERA_FREE,this._resetEventParameter(),this._flycamera_on_success&&(this._flycamera_on_success(),this._flycamera_on_success=void 0);}_setupAnimationBindingBlock(){const e=this._animation,a=s$u.find("vector3");e.addEntry("position",[a],null,(e=>{this.setCameraPosition({longitude:e[0],latitude:e[1],height:e[2]});})),e.addEntry("orientation",[a],null,(e=>{this._camera_parameter.yaw=e[0],this._camera_parameter.pitch=e[1],this.updateCamera();}));}_getLookAtAngle(e,t){const i=e.getMlocsToGocsMatrix(a.createMatrix());let r=a.createVector3([i[4],i[5],i[6]]);r=a.normalize3(r,a.createVector3());const o=t.getMlocsToGocsMatrix(a.createMatrix());let s=a.createVector3([o[12]-i[12],o[13]-i[13],o[14]-i[14]]);s=a.normalize3(s,a.createVector3());const _=a.createVector3([i[8],i[9],i[10]]),n=this.calculateAngle(_,r,s),h=a.createVector3([i[8],i[9],i[10]]),m=a.createVector3([i[0],i[1],i[2]]);s[0]=-1*s[0],s[1]=-1*s[1],s[2]=-1*s[2];return {heading:n,tilt:-1*a.clamp(Math.abs(this.calculateAngle(m,h,s)),0,90)}}_getOffsetPoint(e,t,i,r,o){const s=-(180-r)*a.DEGREE,_=-i*Math.sin(s),n=i*Math.cos(s);o.setFromArray([e,t,0]);const h=o.getMlocsToGocsMatrix(a.createMatrix());return o.setFromGocs([_*h[0]+n*h[4]+h[12],_*h[1]+n*h[5]+h[13],_*h[2]+n*h[6]+h[14]]),o}getControllable(){return this._controllable}setControllable(e){!this._controllable&&e&&(this._resetEventParameter(),this._zoom_wheel=0),this._controllable=e;}}!function(e){var t,a;(t=e.CameraMode||(e.CameraMode={}))[t.NONE=0]="NONE",t[t.CAMERA_FREE=1]="CAMERA_FREE",t[t.CAMERA_FLY=2]="CAMERA_FLY",(a=e.OperationMode||(e.OperationMode={}))[a.NONE=0]="NONE",a[a.TRANSLATE=1]="TRANSLATE",a[a.ROTATE=2]="ROTATE",a[a.FREE_ROTATE=3]="FREE_ROTATE",a[a.EYE_TRANSLATE=4]="EYE_TRANSLATE",a[a.HEIGHT_TRANSLATE=5]="HEIGHT_TRANSLATE",a[a.CHANGE_FOVY=6]="CHANGE_FOVY",e.DEFAULT_CAMERA_POSITION={latitude:35.475968,longitude:138.573161,height:2e3},e.DEFAULT_LOOKAT_POSITION={latitude:35.360626,longitude:138.727363,height:2e3},e.DEFAULT_CAMERA_PARAMETER={fov:60,near:30,far:5e5,speed_factor:2e3},e.ALTITUDE_RANGE={min:2,max:void 0},e.MINIMUM_NEAR=1,e.MINIMUM_FAR=2870162,e.NEAR_FACTOR=.01,e.FAR_FACTOR=1e4,e.FOV_RANGE={min:5,max:120},e.FOV_FACTOR=1.148698354997035;}(r||(r={}));var o=r;

const default_config = [
    {
        name: "Fuji",
        target_lng: 138.727484,
        target_lat: 35.3606158,
        target_altitude: 3700,
        cam_distance: 25000,
        cam_altitude: 1500,
        ray_leigh: 0.003,
        mie: 0.001,
        sun_x_angle: -200,
        sun_y_angle: -200,
        sun_z_angle: 0,
        year: 2022,
        month: 2,
        day: 14,
        hour: 16,
        minute: 27,
        timezone: "Asia/Tokyo"
    },
    {
        name: "NorthernAlps",
        target_lng: 137.555378,
        target_lat: 36.3055625,
        target_altitude: 3000,
        cam_distance: 10000,
        cam_altitude: 6000,
        ray_leigh: 0.003,
        mie: 0.001,
        sun_x_angle: 102,
        sun_y_angle: 36.3055625 - 80,
        sun_z_angle: 0,
        year: 2020,
        month: 8,
        day: 1,
        hour: 11,
        minute: 50,
        timezone: "Asia/Tokyo"
    },
    {
        name: "GrandCanyon",
        target_lng: -112.143933,
        target_lat: 36.105581,
        target_altitude: 2000,
        cam_distance: 6000,
        cam_altitude: 3000,
        ray_leigh: 0.003,
        mie: 0.001,
        sun_x_angle: -200,
        sun_y_angle: -200,
        sun_z_angle: 0,
        year: 2022,
        month: 8,
        day: 12,
        hour: 6,
        minute: 30,
        timezone: "America/Denver"
    },
    {
        name: "Everest",
        target_lng: 86.9136453,
        target_lat: 27.9863758,
        target_altitude: 4000,
        cam_distance: 12000,
        cam_altitude: 10000,
        ray_leigh: 0.003,
        mie: 0.001,
        sun_x_angle: -200,
        sun_y_angle: -200,
        sun_z_angle: 0,
        year: 2022,
        month: 10,
        day: 12,
        hour: 14,
        minute: 55,
        timezone: "Asia/Kathmandu"
    },
    {
        name: "AyersRock",
        target_lng: 131.037146,
        target_lat: -25.345657,
        target_altitude: 0,
        cam_distance: 5000,
        cam_altitude: 1000,
        ray_leigh: 0.003,
        mie: 0.001,
        sun_x_angle: -200,
        sun_y_angle: -200,
        sun_z_angle: 0,
        year: 2022,
        month: 10,
        day: 12,
        hour: 12,
        minute: 32,
        timezone: "Australia/Darwin"
    },
    {
        name: "TableMountain",
        target_lng: 18.4250663,
        target_lat: -33.9830228,
        target_altitude: 1000,
        cam_distance: 5000,
        cam_altitude: 500,
        ray_leigh: 0.003,
        mie: 0.001,
        sun_x_angle: 200,
        sun_y_angle: 200,
        sun_z_angle: 0,
        year: 2022,
        month: 10,
        day: 12,
        hour: 14,
        minute: 55,
        timezone: "Africa/Johannesburg"
    },
    {
        name: "Taranaki",
        target_lng: 174.0546231,
        target_lat: -39.2967528,
        target_altitude: 5000,
        cam_distance: 5000,
        cam_altitude: 3500,
        ray_leigh: 0.003,
        mie: 0.001,
        sun_x_angle: 200,
        sun_y_angle: 200,
        year: 2022,
        month: 10,
        day: 12,
        hour: 14,
        minute: 55,
        timezone: "Pacific/Auckland"
    },
    {
        name: "LakeMcDonald",
        target_lng: -113.8670045609,
        target_lat: 48.6096768230,
        target_altitude: 0,
        cam_distance: 3000,
        cam_altitude: 1000,
        ray_leigh: 0.003,
        mie: 0.001,
        sun_x_angle: 200,
        sun_y_angle: 200,
        year: 2022,
        month: 10,
        day: 12,
        hour: 14,
        minute: 55,
        timezone: "America/Denver"
    },
    {
        name: "Darvaza",
        target_lng: 58.4422051896,
        target_lat: 40.2514796768,
        target_altitude: 0,
        cam_distance: 1000,
        cam_altitude: 1000,
        ray_leigh: 0.003,
        mie: 0.001,
        sun_x_angle: 200,
        sun_y_angle: 200,
        year: 2022,
        month: 10,
        day: 12,
        hour: 14,
        minute: 55,
        timezone: "Asia/Ashgabat"
    },
    {
        name: "StHelens",
        target_lng: -122.1781366795,
        target_lat: 46.1982293962,
        target_altitude: 1000,
        cam_distance: 10000,
        cam_altitude: 6000,
        ray_leigh: 0.003,
        mie: 0.001,
        sun_x_angle: 200,
        sun_y_angle: 200,
        year: 2022,
        month: 10,
        day: 12,
        hour: 14,
        minute: 55,
        timezone: "America/Los_Angeles"
    }
];
function getCameraInfoFromLocation(location) {
    const i = default_config.findIndex(p => p.name == location);
    if (i < 0) {
        return -1;
    }
    return i;
}

var ImageProvider = a$g;
class BingMapsImageProvider extends ImageProvider {
    constructor(options = {}) {
        super();
        var opts = options;
        this._status = "@@_ImageProvider.Status.NOT_READY";
        this._callbacks = [];
        this._size = undefined;
        this._min_level = undefined;
        this._max_level = options.maxLevel;
        this._counter = 0;
        this._load_matadata(opts);
    }
    _load_matadata(opts) {
        var url = BingMapsImageProvider.TemplMetadataURL;
        url = url.replace('{key}', opts.key || '');
        url = url.replace('{imagerySet}', opts.imagerySet || BingMapsImageProvider.DefaultImagerySet);
        url = url.replace(/\{uriScheme\}/g, opts.uriScheme || BingMapsImageProvider.DefaultUriScheme);
        fetch(url)
            .then(response => {
            return response.ok ?
                response.json() : Promise.reject(Error(response.statusText));
        })
            .then(json => {
            this._analyze_matadata(json, opts);
            this._status = "@@_ImageProvider.Status.READY";
        })
            .catch(err => {
            console.error("BingMapsImageProvider: " + err.message);
            this._status = "@@_ImageProvider.Status.FAILED";
        }).then(() => {
            for (var i = 0; i < this._callbacks.length; ++i) {
                this._callbacks[i](this._status);
            }
        });
    }
    _analyze_matadata(json, opts) {
        var resource = json.resourceSets[0].resources[0];
        if (resource.imageWidth != resource.imageHeight) {
            throw new Error("it supports only square images");
        }
        var culture = opts.culture || BingMapsImageProvider.DefaultCulture;
        var templ = resource.imageUrl.replace('{culture}', culture);
        this._size = resource.imageWidth;
        this._min_level = resource.zoomMin;
        this._max_level = this._max_level || resource.zoomMax;
        this._templ_urls = resource.imageUrlSubdomains.map((subdomain) => templ.replace('{subdomain}', subdomain));
    }
    status(callback) {
        if (this._status === "@@_ImageProvider.Status.NOT_READY") {
            if (callback) {
                this._callbacks.push(callback);
            }
        }
        return this._status;
    }
    requestTile(z, x, y, callback) {
        var image = new Image();
        image.onload = function () { callback(image); };
        image.onerror = function () { callback(null); };
        image.crossOrigin = "anonymous";
        image.src = this._makeURL(z, x, y);
        return image;
    }
    cancelRequest(id) {
    }
    getImageSize() {
        return this._size !== undefined ? this._size : 0;
    }
    getZoomLevelRange() {
        if (this._min_level === undefined || this._max_level === undefined) {
            throw new Error("min_level or max_level is not defined");
        }
        return new ImageProvider.Range(this._min_level, this._max_level);
    }
    _makeURL(z, x, y) {
        var templ_url = this._templ_urls[this._counter % this._templ_urls.length];
        var quadkey = '';
        for (var i = 0; i < z; ++i) {
            var bx = (x >> i) & 1;
            var by = (y >> i) & 1;
            quadkey = (bx + 2 * by) + quadkey;
        }
        ++this._counter;
        return templ_url.replace('{quadkey}', quadkey);
    }
}
(function (BingMapsImageProvider) {
    BingMapsImageProvider.TemplMetadataURL = "{uriScheme}://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}?uriScheme={uriScheme}&include=ImageryProviders&key={key}";
    BingMapsImageProvider.DefaultCulture = "";
    BingMapsImageProvider.DefaultUriScheme = "http";
    BingMapsImageProvider.DefaultImagerySet = "Aerial";
})(BingMapsImageProvider || (BingMapsImageProvider = {}));
var BingMapsImageProvider$1 = BingMapsImageProvider;

var suncalc = {exports: {}};

(function (module, exports) {
	(function () {
	// shortcuts for easier to read formulas

	var PI   = Math.PI,
	    sin  = Math.sin,
	    cos  = Math.cos,
	    tan  = Math.tan,
	    asin = Math.asin,
	    atan = Math.atan2,
	    acos = Math.acos,
	    rad  = PI / 180;

	// sun calculations are based on http://aa.quae.nl/en/reken/zonpositie.html formulas


	// date/time constants and conversions

	var dayMs = 1000 * 60 * 60 * 24,
	    J1970 = 2440588,
	    J2000 = 2451545;

	function toJulian(date) { return date.valueOf() / dayMs - 0.5 + J1970; }
	function fromJulian(j)  { return new Date((j + 0.5 - J1970) * dayMs); }
	function toDays(date)   { return toJulian(date) - J2000; }


	// general calculations for position

	var e = rad * 23.4397; // obliquity of the Earth

	function rightAscension(l, b) { return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l)); }
	function declination(l, b)    { return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l)); }

	function azimuth(H, phi, dec)  { return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi)); }
	function altitude(H, phi, dec) { return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H)); }

	function siderealTime(d, lw) { return rad * (280.16 + 360.9856235 * d) - lw; }

	function astroRefraction(h) {
	    if (h < 0) // the following formula works for positive altitudes only.
	        h = 0; // if h = -0.08901179 a div/0 would occur.

	    // formula 16.4 of "Astronomical Algorithms" 2nd edition by Jean Meeus (Willmann-Bell, Richmond) 1998.
	    // 1.02 / tan(h + 10.26 / (h + 5.10)) h in degrees, result in arc minutes -> converted to rad:
	    return 0.0002967 / Math.tan(h + 0.00312536 / (h + 0.08901179));
	}

	// general sun calculations

	function solarMeanAnomaly(d) { return rad * (357.5291 + 0.98560028 * d); }

	function eclipticLongitude(M) {

	    var C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 0.0003 * sin(3 * M)), // equation of center
	        P = rad * 102.9372; // perihelion of the Earth

	    return M + C + P + PI;
	}

	function sunCoords(d) {

	    var M = solarMeanAnomaly(d),
	        L = eclipticLongitude(M);

	    return {
	        dec: declination(L, 0),
	        ra: rightAscension(L, 0)
	    };
	}


	var SunCalc = {};


	// calculates sun position for a given date and latitude/longitude

	SunCalc.getPosition = function (date, lat, lng) {

	    var lw  = rad * -lng,
	        phi = rad * lat,
	        d   = toDays(date),

	        c  = sunCoords(d),
	        H  = siderealTime(d, lw) - c.ra;

	    return {
	        azimuth: azimuth(H, phi, c.dec),
	        altitude: altitude(H, phi, c.dec)
	    };
	};


	// sun times configuration (angle, morning name, evening name)

	var times = SunCalc.times = [
	    [-0.833, 'sunrise',       'sunset'      ],
	    [  -0.3, 'sunriseEnd',    'sunsetStart' ],
	    [    -6, 'dawn',          'dusk'        ],
	    [   -12, 'nauticalDawn',  'nauticalDusk'],
	    [   -18, 'nightEnd',      'night'       ],
	    [     6, 'goldenHourEnd', 'goldenHour'  ]
	];

	// adds a custom time to the times config

	SunCalc.addTime = function (angle, riseName, setName) {
	    times.push([angle, riseName, setName]);
	};


	// calculations for sun times

	var J0 = 0.0009;

	function julianCycle(d, lw) { return Math.round(d - J0 - lw / (2 * PI)); }

	function approxTransit(Ht, lw, n) { return J0 + (Ht + lw) / (2 * PI) + n; }
	function solarTransitJ(ds, M, L)  { return J2000 + ds + 0.0053 * sin(M) - 0.0069 * sin(2 * L); }

	function hourAngle(h, phi, d) { return acos((sin(h) - sin(phi) * sin(d)) / (cos(phi) * cos(d))); }
	function observerAngle(height) { return -2.076 * Math.sqrt(height) / 60; }

	// returns set time for the given sun altitude
	function getSetJ(h, lw, phi, dec, n, M, L) {

	    var w = hourAngle(h, phi, dec),
	        a = approxTransit(w, lw, n);
	    return solarTransitJ(a, M, L);
	}


	// calculates sun times for a given date, latitude/longitude, and, optionally,
	// the observer height (in meters) relative to the horizon

	SunCalc.getTimes = function (date, lat, lng, height) {

	    height = height || 0;

	    var lw = rad * -lng,
	        phi = rad * lat,

	        dh = observerAngle(height),

	        d = toDays(date),
	        n = julianCycle(d, lw),
	        ds = approxTransit(0, lw, n),

	        M = solarMeanAnomaly(ds),
	        L = eclipticLongitude(M),
	        dec = declination(L, 0),

	        Jnoon = solarTransitJ(ds, M, L),

	        i, len, time, h0, Jset, Jrise;


	    var result = {
	        solarNoon: fromJulian(Jnoon),
	        nadir: fromJulian(Jnoon - 0.5)
	    };

	    for (i = 0, len = times.length; i < len; i += 1) {
	        time = times[i];
	        h0 = (time[0] + dh) * rad;

	        Jset = getSetJ(h0, lw, phi, dec, n, M, L);
	        Jrise = Jnoon - (Jset - Jnoon);

	        result[time[1]] = fromJulian(Jrise);
	        result[time[2]] = fromJulian(Jset);
	    }

	    return result;
	};


	// moon calculations, based on http://aa.quae.nl/en/reken/hemelpositie.html formulas

	function moonCoords(d) { // geocentric ecliptic coordinates of the moon

	    var L = rad * (218.316 + 13.176396 * d), // ecliptic longitude
	        M = rad * (134.963 + 13.064993 * d), // mean anomaly
	        F = rad * (93.272 + 13.229350 * d),  // mean distance

	        l  = L + rad * 6.289 * sin(M), // longitude
	        b  = rad * 5.128 * sin(F),     // latitude
	        dt = 385001 - 20905 * cos(M);  // distance to the moon in km

	    return {
	        ra: rightAscension(l, b),
	        dec: declination(l, b),
	        dist: dt
	    };
	}

	SunCalc.getMoonPosition = function (date, lat, lng) {

	    var lw  = rad * -lng,
	        phi = rad * lat,
	        d   = toDays(date),

	        c = moonCoords(d),
	        H = siderealTime(d, lw) - c.ra,
	        h = altitude(H, phi, c.dec),
	        // formula 14.1 of "Astronomical Algorithms" 2nd edition by Jean Meeus (Willmann-Bell, Richmond) 1998.
	        pa = atan(sin(H), tan(phi) * cos(c.dec) - sin(c.dec) * cos(H));

	    h = h + astroRefraction(h); // altitude correction for refraction

	    return {
	        azimuth: azimuth(H, phi, c.dec),
	        altitude: h,
	        distance: c.dist,
	        parallacticAngle: pa
	    };
	};


	// calculations for illumination parameters of the moon,
	// based on http://idlastro.gsfc.nasa.gov/ftp/pro/astro/mphase.pro formulas and
	// Chapter 48 of "Astronomical Algorithms" 2nd edition by Jean Meeus (Willmann-Bell, Richmond) 1998.

	SunCalc.getMoonIllumination = function (date) {

	    var d = toDays(date || new Date()),
	        s = sunCoords(d),
	        m = moonCoords(d),

	        sdist = 149598000, // distance from Earth to Sun in km

	        phi = acos(sin(s.dec) * sin(m.dec) + cos(s.dec) * cos(m.dec) * cos(s.ra - m.ra)),
	        inc = atan(sdist * sin(phi), m.dist - sdist * cos(phi)),
	        angle = atan(cos(s.dec) * sin(s.ra - m.ra), sin(s.dec) * cos(m.dec) -
	                cos(s.dec) * sin(m.dec) * cos(s.ra - m.ra));

	    return {
	        fraction: (1 + cos(inc)) / 2,
	        phase: 0.5 + 0.5 * inc * (angle < 0 ? -1 : 1) / Math.PI,
	        angle: angle
	    };
	};


	function hoursLater(date, h) {
	    return new Date(date.valueOf() + h * dayMs / 24);
	}

	// calculations for moon rise/set times are based on http://www.stargazing.net/kepler/moonrise.html article

	SunCalc.getMoonTimes = function (date, lat, lng, inUTC) {
	    var t = new Date(date);
	    if (inUTC) t.setUTCHours(0, 0, 0, 0);
	    else t.setHours(0, 0, 0, 0);

	    var hc = 0.133 * rad,
	        h0 = SunCalc.getMoonPosition(t, lat, lng).altitude - hc,
	        h1, h2, rise, set, a, b, xe, ye, d, roots, x1, x2, dx;

	    // go in 2-hour chunks, each time seeing if a 3-point quadratic curve crosses zero (which means rise or set)
	    for (var i = 1; i <= 24; i += 2) {
	        h1 = SunCalc.getMoonPosition(hoursLater(t, i), lat, lng).altitude - hc;
	        h2 = SunCalc.getMoonPosition(hoursLater(t, i + 1), lat, lng).altitude - hc;

	        a = (h0 + h2) / 2 - h1;
	        b = (h2 - h0) / 2;
	        xe = -b / (2 * a);
	        ye = (a * xe + b) * xe + h1;
	        d = b * b - 4 * a * h1;
	        roots = 0;

	        if (d >= 0) {
	            dx = Math.sqrt(d) / (Math.abs(a) * 2);
	            x1 = xe - dx;
	            x2 = xe + dx;
	            if (Math.abs(x1) <= 1) roots++;
	            if (Math.abs(x2) <= 1) roots++;
	            if (x1 < -1) x1 = x2;
	        }

	        if (roots === 1) {
	            if (h0 < 0) rise = i + x1;
	            else set = i + x1;

	        } else if (roots === 2) {
	            rise = i + (ye < 0 ? x2 : x1);
	            set = i + (ye < 0 ? x1 : x2);
	        }

	        if (rise && set) break;

	        h0 = h2;
	    }

	    var result = {};

	    if (rise) result.rise = hoursLater(t, rise);
	    if (set) result.set = hoursLater(t, set);

	    if (!rise && !set) result[ye > 0 ? 'alwaysUp' : 'alwaysDown'] = true;

	    return result;
	};


	// export as Node module / AMD module / browser variable
	module.exports = SunCalc;

	}());
} (suncalc));

// these aren't really private, but nor are they really useful to document

/**
 * @private
 */
class LuxonError extends Error {}

/**
 * @private
 */
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class ConflictingSpecificationError extends LuxonError {}

/**
 * @private
 */
class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
}

/**
 * @private
 */
class InvalidArgumentError extends LuxonError {}

/**
 * @private
 */
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}

/**
 * @private
 */

const n = "numeric",
  s = "short",
  l = "long";

const DATE_SHORT = {
  year: n,
  month: n,
  day: n,
};

const DATE_MED = {
  year: n,
  month: s,
  day: n,
};

const DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
};

const DATE_FULL = {
  year: n,
  month: l,
  day: n,
};

const DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
};

const TIME_SIMPLE = {
  hour: n,
  minute: n,
};

const TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
};

const TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s,
};

const TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l,
};

const TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23",
};

const TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
};

const TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s,
};

const TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l,
};

const DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
};

const DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n,
};

const DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
};

const DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n,
};

const DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n,
};

const DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s,
};

const DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s,
};

const DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l,
};

const DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l,
};

/**
 * @private
 */

// TYPES

function isUndefined(o) {
  return typeof o === "undefined";
}

function isNumber(o) {
  return typeof o === "number";
}

function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}

function isString(o) {
  return typeof o === "string";
}

function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}

// CAPABILITIES

function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}

// OBJECTS AND ARRAYS

function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}

function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return undefined;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}

function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// NUMBERS AND STRINGS

function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}

// x % n but takes the sign of n instead of x
function floorMod(x, n) {
  return x - n * Math.floor(x / n);
}

function padStart(input, n = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n, "0");
  } else {
    padded = ("" + input).padStart(n, "0");
  }
  return padded;
}

function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseInt(string, 10);
  }
}

function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseFloat(string);
  }
}

function parseMillis(fraction) {
  // Return undefined (instead of 0) in these cases, where fraction is not set
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return undefined;
  } else {
    const f = parseFloat("0." + fraction) * 1000;
    return Math.floor(f);
  }
}

function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits,
    rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}

// DATE BASICS

function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}

function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1,
    modYear = year + (month - modMonth) / 12;

  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}

// covert a calendar object to a local timestamp (epoch, but with the offset baked in)
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );

  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  return +d;
}

function weeksInWeekYear(weekYear) {
  const p1 =
      (weekYear +
        Math.floor(weekYear / 4) -
        Math.floor(weekYear / 100) +
        Math.floor(weekYear / 400)) %
      7,
    last = weekYear - 1,
    p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}

function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > 60 ? 1900 + year : 2000 + year;
}

// PARSING

function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts),
    intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
    };

  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }

  const modified = { timeZoneName: offsetFormat, ...intlOpts };

  const parsed = new Intl.DateTimeFormat(locale, modified)
    .formatToParts(date)
    .find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}

// signedOffset('-5', '30') -> -330
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);

  // don't || this because we want to preserve -0
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }

  const offMin = parseInt(offMinuteStr, 10) || 0,
    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}

// COERCION

function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}

function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === undefined || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}

function formatOffset(offset, format) {
  const hours = Math.trunc(Math.abs(offset / 60)),
    minutes = Math.trunc(Math.abs(offset % 60)),
    sign = offset >= 0 ? "+" : "-";

  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}

function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

const ianaRegex =
  /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

/**
 * @private
 */

const monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December",
];

const monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];

const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];

function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}

const weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday",
];

const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];

function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}

const meridiems = ["AM", "PM"];

const erasLong = ["Before Christ", "Anno Domini"];

const erasShort = ["BC", "AD"];

const erasNarrow = ["B", "A"];

function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}

function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}

function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}

function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}

function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}

function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."],
  };

  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;

  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
    }
  }

  const isInPast = Object.is(count, -0) || count < 0,
    fmtValue = Math.abs(count),
    singular = fmtValue === 1,
    lilUnits = units[unit],
    fmtUnit = narrow
      ? singular
        ? lilUnits[1]
        : lilUnits[2] || lilUnits[1]
      : singular
      ? units[unit][0]
      : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

function stringifyTokens(splits, tokenToString) {
  let s = "";
  for (const token of splits) {
    if (token.literal) {
      s += token.val;
    } else {
      s += tokenToString(token.val);
    }
  }
  return s;
}

const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS,
};

/**
 * @private
 */

class Formatter {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }

  static parseFormat(fmt) {
    let current = null,
      currentFull = "",
      bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: false, val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }

    if (currentFull.length > 0) {
      splits.push({ literal: bracketed, val: currentFull });
    }

    return splits;
  }

  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }

  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }

  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }

  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }

  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.formatToParts();
  }

  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.resolvedOptions();
  }

  num(n, p = 0) {
    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return padStart(n, p);
    }

    const opts = { ...this.opts };

    if (p > 0) {
      opts.padTo = p;
    }

    return this.loc.numberFormatter(opts).format(n);
  }

  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en",
      useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
      string = (opts, extract) => this.loc.extract(dt, opts, extract),
      formatOffset = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }

        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      },
      meridiem = () =>
        knownEnglish
          ? meridiemForDateTime(dt)
          : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"),
      month = (length, standalone) =>
        knownEnglish
          ? monthForDateTime(dt, length)
          : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"),
      weekday = (length, standalone) =>
        knownEnglish
          ? weekdayForDateTime(dt, length)
          : string(
              standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
              "weekday"
            ),
      maybeMacro = (token) => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      },
      era = (length) =>
        knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"),
      tokenToString = (token) => {
        // Where possible: http://cldr.unicode.org/translation/date-time-1/date-time#TOC-Standalone-vs.-Format-Styles
        switch (token) {
          // ms
          case "S":
            return this.num(dt.millisecond);
          case "u":
          // falls through
          case "SSS":
            return this.num(dt.millisecond, 3);
          // seconds
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          // fractional seconds
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          // minutes
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          // hours
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          // offset
          case "Z":
            // like +6
            return formatOffset({ format: "narrow", allowZ: this.opts.allowZ });
          case "ZZ":
            // like +06:00
            return formatOffset({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            // like +0600
            return formatOffset({ format: "techie", allowZ: this.opts.allowZ });
          case "ZZZZ":
            // like EST
            return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
          case "ZZZZZ":
            // like Eastern Standard Time
            return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
          // zone
          case "z":
            // like America/New_York
            return dt.zoneName;
          // meridiems
          case "a":
            return meridiem();
          // dates
          case "d":
            return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
          // weekdays - standalone
          case "c":
            // like 1
            return this.num(dt.weekday);
          case "ccc":
            // like 'Tues'
            return weekday("short", true);
          case "cccc":
            // like 'Tuesday'
            return weekday("long", true);
          case "ccccc":
            // like 'T'
            return weekday("narrow", true);
          // weekdays - format
          case "E":
            // like 1
            return this.num(dt.weekday);
          case "EEE":
            // like 'Tues'
            return weekday("short", false);
          case "EEEE":
            // like 'Tuesday'
            return weekday("long", false);
          case "EEEEE":
            // like 'T'
            return weekday("narrow", false);
          // months - standalone
          case "L":
            // like 1
            return useDateTimeFormatter
              ? string({ month: "numeric", day: "numeric" }, "month")
              : this.num(dt.month);
          case "LL":
            // like 01, doesn't seem to work
            return useDateTimeFormatter
              ? string({ month: "2-digit", day: "numeric" }, "month")
              : this.num(dt.month, 2);
          case "LLL":
            // like Jan
            return month("short", true);
          case "LLLL":
            // like January
            return month("long", true);
          case "LLLLL":
            // like J
            return month("narrow", true);
          // months - format
          case "M":
            // like 1
            return useDateTimeFormatter
              ? string({ month: "numeric" }, "month")
              : this.num(dt.month);
          case "MM":
            // like 01
            return useDateTimeFormatter
              ? string({ month: "2-digit" }, "month")
              : this.num(dt.month, 2);
          case "MMM":
            // like Jan
            return month("short", false);
          case "MMMM":
            // like January
            return month("long", false);
          case "MMMMM":
            // like J
            return month("narrow", false);
          // years
          case "y":
            // like 2014
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
          case "yy":
            // like 14
            return useDateTimeFormatter
              ? string({ year: "2-digit" }, "year")
              : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            // like 0012
            return useDateTimeFormatter
              ? string({ year: "numeric" }, "year")
              : this.num(dt.year, 4);
          case "yyyyyy":
            // like 000012
            return useDateTimeFormatter
              ? string({ year: "numeric" }, "year")
              : this.num(dt.year, 6);
          // eras
          case "G":
            // like AD
            return era("short");
          case "GG":
            // like Anno Domini
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            // like 1
            return this.num(dt.quarter);
          case "qq":
            // like 01
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };

    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }

  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      },
      tokenToString = (lildur) => (token) => {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      },
      tokens = Formatter.parseFormat(fmt),
      realTokens = tokens.reduce(
        (found, { literal, val }) => (literal ? found : found.concat(val)),
        []
      ),
      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
}

class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }

  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}

/**
 * @interface
 */
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }

  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }

  get ianaName() {
    return this.name;
  }

  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }

  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}

let singleton$1 = null;

/**
 * Represents the local zone for this JavaScript environment.
 * @implements {Zone}
 */
class SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton$1 === null) {
      singleton$1 = new SystemZone();
    }
    return singleton$1;
  }

  /** @override **/
  get type() {
    return "system";
  }

  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }

  /** @override **/
  get isValid() {
    return true;
  }
}

let dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short",
    });
  }
  return dtfCache[zone];
}

const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6,
};

function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""),
    parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted),
    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}

function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i];
    const pos = typeToPos[type];

    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}

let ianaZoneCache = {};
/**
 * A zone identified by an IANA identifier, like America/New_York
 * @implements {Zone}
 */
class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }

  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }

  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s) {
    return this.isValidZone(s);
  }

  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }

  constructor(name) {
    super();
    /** @private **/
    this.zoneName = name;
    /** @private **/
    this.valid = IANAZone.isValidZone(name);
  }

  /** @override **/
  get type() {
    return "iana";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    const date = new Date(ts);

    if (isNaN(date)) return NaN;

    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts
      ? partsOffset(dtf, date)
      : hackyOffset(dtf, date);

    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }

    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat
    const adjustedHour = hour === 24 ? 0 : hour;

    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0,
    });

    let asTS = +date;
    const over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }

  /** @override **/
  get isValid() {
    return this.valid;
  }
}

let singleton = null;

/**
 * A zone with a fixed offset (meaning no DST)
 * @implements {Zone}
 */
class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }

  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset) {
    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
  }

  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s) {
    if (s) {
      const r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }

  constructor(offset) {
    super();
    /** @private **/
    this.fixed = offset;
  }

  /** @override **/
  get type() {
    return "fixed";
  }

  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }

  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }

  /** @override **/
  offsetName() {
    return this.name;
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }

  /** @override **/
  get isUniversal() {
    return true;
  }

  /** @override **/
  offset() {
    return this.fixed;
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }

  /** @override **/
  get isValid() {
    return true;
  }
}

/**
 * A zone that failed to parse. You should never need to instantiate this.
 * @implements {Zone}
 */
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    /**  @private */
    this.zoneName = zoneName;
  }

  /** @override **/
  get type() {
    return "invalid";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName() {
    return null;
  }

  /** @override **/
  formatOffset() {
    return "";
  }

  /** @override **/
  offset() {
    return NaN;
  }

  /** @override **/
  equals() {
    return false;
  }

  /** @override **/
  get isValid() {
    return false;
  }
}

function normalizeZone(input, defaultZone) {
  if (isUndefined(input) || input === null) {
    return defaultZone;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default") return defaultZone;
    else if (lowered === "local" || lowered === "system") return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
    else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    // This is dumb, but the instanceof check above doesn't seem to really work
    // so we're duck checking it
    return input;
  } else {
    return new InvalidZone(input);
  }
}

let now = () => Date.now(),
  defaultZone = "system",
  defaultLocale = null,
  defaultNumberingSystem = null,
  defaultOutputCalendar = null,
  throwOnInvalid;

/**
 * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
 */
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }

  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n) {
    now = n;
  }

  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }

  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }

  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }

  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }

  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }

  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }

  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }

  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }

  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }

  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }

  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
}

// todo - remap caching

let intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}

let intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}

let intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}

let intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}

let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}

function parseLocaleString(localeStr) {
  // I really want to avoid writing a BCP 47 parser
  // see, e.g. https://github.com/wooorm/bcp-47
  // Instead, we'll do this:

  // a) if the string has no -u extensions, just leave it alone
  // b) if it does, use Intl to resolve everything
  // c) if Intl fails, try again without the -u

  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    const smaller = localeStr.substring(0, uIndex);
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e) {
      options = getCachedDTF(smaller).resolvedOptions();
    }

    const { numberingSystem, calendar } = options;
    // return the smaller one so that we can append the calendar and numbering overrides to it
    return [smaller, numberingSystem, calendar];
  }
}

function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    localeStr += "-u";

    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }

    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}

function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2016, i, 1);
    ms.push(f(dt));
  }
  return ms;
}

function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}

function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);

  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}

function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return (
      loc.numberingSystem === "latn" ||
      !loc.locale ||
      loc.locale.startsWith("en") ||
      new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn"
    );
  }
}

/**
 * @private
 */

class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;

    const { padTo, floor, ...otherOpts } = opts;

    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }

  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      // to match the browser's numberformatter defaults
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
}

/**
 * @private
 */

class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;

    let z;
    if (dt.zone.isUniversal) {
      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.
      // That is why fixed-offset TZ is set to that unless it is:
      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.
      // 2. Unsupported by the browser:
      //    - some do not support Etc/
      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.
        // So we have to make do. Two cases:
        // 1. The format options tell us to show the zone. We can't do that, so the best
        // we can do is format the date in UTC.
        // 2. The format options don't tell us to show the zone. Then we can adjust them
        // the time and tell the formatter to show it to us in UTC, so that the time is right
        // and the bad zone doesn't show up.
        z = "UTC";
        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);
        }
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }

    const intlOpts = { ...this.opts };
    if (z) {
      intlOpts.timeZone = z;
    }
    this.dtf = getCachedDTF(intl, intlOpts);
  }

  format() {
    return this.dtf.format(this.dt.toJSDate());
  }

  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }

  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}

/**
 * @private
 */
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }

  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }

  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
}

/**
 * @private
 */

class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }

  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }

  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }

  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }

  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);

    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);

    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};

    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }

  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }

    return this.fastNumbersCached;
  }

  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness =
      (this.numberingSystem === null || this.numberingSystem === "latn") &&
      (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }

  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  }

  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }

  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }

  months(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length },
        formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }

  weekdays(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format
          ? { weekday: length, year: "numeric", month: "long", day: "numeric" }
          : { weekday: length },
        formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>
          this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }

  meridiems(defaultOK = true) {
    return listStuff(
      this,
      undefined,
      defaultOK,
      () => meridiems,
      () => {
        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
        // for AM and PM. This is probably wrong, but it's makes parsing way easier.
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }

        return this.meridiemCache;
      }
    );
  }

  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = { era: length };

      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
      // to definitely enumerate them.
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) =>
          this.extract(dt, intl, "era")
        );
      }

      return this.eraCache[length];
    });
  }

  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts),
      results = df.formatToParts(),
      matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }

  numberFormatter(opts = {}) {
    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
    // (in contrast, the rest of the condition is used heavily)
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }

  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }

  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }

  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }

  isEnglish() {
    return (
      this.locale === "en" ||
      this.locale.toLowerCase() === "en-us" ||
      new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")
    );
  }

  equals(other) {
    return (
      this.locale === other.locale &&
      this.numberingSystem === other.numberingSystem &&
      this.outputCalendar === other.outputCalendar
    );
  }
}

/*
 * This file handles parsing for well-specified formats. Here's how it works:
 * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
 * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
 * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
 * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
 * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
 * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
 */

function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}

function combineExtractors(...extractors) {
  return (m) =>
    extractors
      .reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      )
      .slice(0, 2);
}

function parse(s, ...patterns) {
  if (s == null) {
    return [null, null];
  }

  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}

function simpleParse(...keys) {
  return (match, cursor) => {
    const ret = {};
    let i;

    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}

// ISO and SQL parsing
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
const isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/; // dumbed-down version of the ISO one
const sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);

function int(match, pos, fallback) {
  const m = match[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}

function extractISOYmd(match, cursor) {
  const item = {
    year: int(match, cursor),
    month: int(match, cursor + 1, 1),
    day: int(match, cursor + 2, 1),
  };

  return [item, null, cursor + 3];
}

function extractISOTime(match, cursor) {
  const item = {
    hours: int(match, cursor, 0),
    minutes: int(match, cursor + 1, 0),
    seconds: int(match, cursor + 2, 0),
    milliseconds: parseMillis(match[cursor + 3]),
  };

  return [item, null, cursor + 4];
}

function extractISOOffset(match, cursor) {
  const local = !match[cursor] && !match[cursor + 1],
    fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
    zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}

function extractIANAZone(match, cursor) {
  const zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
  return [{}, zone, cursor + 1];
}

// ISO time parsing

const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);

// ISO duration parsing

const isoDuration =
  /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;

function extractISODuration(match) {
  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] =
    match;

  const hasNegativePrefix = s[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";

  const maybeNegate = (num, force = false) =>
    num !== undefined && (force || (num && hasNegativePrefix)) ? -num : num;

  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds),
    },
  ];
}

// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
// and not just that we're in -240 *right now*. But since I don't think these are used that often
// I'm just going to ignore that
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60,
};

function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr),
  };

  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday =
      weekdayStr.length > 3
        ? weekdaysLong.indexOf(weekdayStr) + 1
        : weekdaysShort.indexOf(weekdayStr) + 1;
  }

  return result;
}

// RFC 2822/5322
const rfc2822 =
  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

function extractRFC2822(match) {
  const [
      ,
      weekdayStr,
      dayStr,
      monthStr,
      yearStr,
      hourStr,
      minuteStr,
      secondStr,
      obsOffset,
      milOffset,
      offHourStr,
      offMinuteStr,
    ] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);

  let offset;
  if (obsOffset) {
    offset = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset = 0;
  } else {
    offset = signedOffset(offHourStr, offMinuteStr);
  }

  return [result, new FixedOffsetZone(offset)];
}

function preprocessRFC2822(s) {
  // Remove comments and folding whitespace and replace multiple-spaces with a single space
  return s
    .replace(/\([^)]*\)|[\n\t]/g, " ")
    .replace(/(\s\s+)/g, " ")
    .trim();
}

// http date

const rfc1123 =
    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
  rfc850 =
    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
  ascii =
    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

function extractRFC1123Or850(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}

function extractASCII(match) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}

const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);

const extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);

/*
 * @private
 */

function parseISODate(s) {
  return parse(
    s,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}

function parseRFC2822Date(s) {
  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
}

function parseHTTPDate(s) {
  return parse(
    s,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}

function parseISODuration(s) {
  return parse(s, [isoDuration, extractISODuration]);
}

const extractISOTimeOnly = combineExtractors(extractISOTime);

function parseISOTimeOnly(s) {
  return parse(s, [isoTimeOnly, extractISOTimeOnly]);
}

const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);

const extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);

function parseSQL(s) {
  return parse(
    s,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

const INVALID$2 = "Invalid Duration";

// unit conversion constants
const lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000,
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000,
    },
    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },
    minutes: { seconds: 60, milliseconds: 60 * 1000 },
    seconds: { milliseconds: 1000 },
  },
  casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000,
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000,
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000,
    },

    ...lowOrderMatrix,
  },
  daysInYearAccurate = 146097.0 / 400,
  daysInMonthAccurate = 146097.0 / 4800,
  accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000,
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: (daysInYearAccurate * 24) / 4,
      minutes: (daysInYearAccurate * 24 * 60) / 4,
      seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,
      milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4,
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000,
    },
    ...lowOrderMatrix,
  };

// units ordered by size
const orderedUnits$1 = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds",
];

const reverseUnits = orderedUnits$1.slice(0).reverse();

// clone really means "create another instance just like this one, but with these changes"
function clone$1(dur, alts, clear = false) {
  // deep merge for vals
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...(alts.values || {}) },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
  };
  return new Duration(conf);
}

function antiTrunc(n) {
  return n < 0 ? Math.floor(n) : Math.ceil(n);
}

// NB: mutates parameters
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit],
    raw = fromMap[fromUnit] / conv,
    sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
    // ok, so this is wild, but see the matrix in the tests
    added =
      !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}

// NB: mutates parameters
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}

/**
 * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.
 *
 * Here is a brief overview of commonly used methods and getters in Duration:
 *
 * * **Creation** To create a Duration, use {@link Duration#fromMillis}, {@link Duration#fromObject}, or {@link Duration#fromISO}.
 * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.
 * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.
 * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.
 * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}
 *
 * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
 */
class Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    /**
     * @access private
     */
    this.values = config.values;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.matrix = accurate ? accurateMatrix : casualMatrix;
    /**
     * @access private
     */
    this.isLuxonDuration = true;
  }

  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }

  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${
          obj === null ? "null" : typeof obj
        }`
      );
    }

    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
    });
  }

  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }

  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }

  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }

  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }

    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }

  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds",
    }[unit ? unit.toLowerCase() : unit];

    if (!normalized) throw new InvalidUnitError(unit);

    return normalized;
  }

  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return (o && o.isLuxonDuration) || false;
  }

  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    // reverse-compat since 1.2; we always round down now, never up, and we do it by default
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false,
    };
    return this.isValid
      ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt)
      : INVALID$2;
  }

  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    const l = orderedUnits$1
      .map((unit) => {
        const val = this.values[unit];
        if (isUndefined(val)) {
          return null;
        }
        return this.loc
          .numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) })
          .format(val);
      })
      .filter((n) => n);

    return this.loc
      .listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts })
      .format(l);
  }

  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    // we could use the formatter, but this is an easier way to get the minimum string
    if (!this.isValid) return null;

    let s = "P";
    if (this.years !== 0) s += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s += this.weeks + "W";
    if (this.days !== 0) s += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s += "T";
    if (this.hours !== 0) s += this.hours + "H";
    if (this.minutes !== 0) s += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      // this will handle "floating point madness" by removing extra decimal places
      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken
      s += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
    if (s === "P") s += "T0S";
    return s;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;

    const millis = this.toMillis();
    if (millis < 0 || millis >= 86400000) return null;

    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
    };

    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");

    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";

    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }

    let str = value.toFormat(fmt);

    if (opts.includePrefix) {
      str = "T" + str;
    }

    return str;
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }

  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }

  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;

    const dur = Duration.fromDurationLike(duration),
      result = {};

    for (const k of orderedUnits$1) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }

    return clone$1(this, { values: result }, true);
  }

  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;

    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }

  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hour" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid) return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone$1(this, { values: result }, true);
  }

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }

  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;

    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone$1(this, { values: mixed });
  }

  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem }),
      opts = { loc };

    if (conversionAccuracy) {
      opts.conversionAccuracy = conversionAccuracy;
    }

    return clone$1(this, opts);
  }

  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }

  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone$1(this, { values: vals }, true);
  }

  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;

    if (units.length === 0) {
      return this;
    }

    units = units.map((u) => Duration.normalizeUnit(u));

    const built = {},
      accumulated = {},
      vals = this.toObject();
    let lastUnit;

    for (const k of orderedUnits$1) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;

        let own = 0;

        // anything we haven't boiled down yet should get boiled to this unit
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }

        // plus anything that's already in this unit
        if (isNumber(vals[k])) {
          own += vals[k];
        }

        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1000 - i * 1000) / 1000;

        // plus anything further down the chain that should be rolled up in to this
        for (const down in vals) {
          if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        }
        // otherwise, keep it in the wings to boil it later
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }

    // anything leftover becomes the decimal for the last unit
    // lastUnit must be defined since units is not empty
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] +=
          key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }

    return clone$1(this, { values: built }, true).normalize();
  }

  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone$1(this, { values: negated }, true);
  }

  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }

  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }

  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }

  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }

  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }

  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }

  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }

  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }

  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }

  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    if (!this.loc.equals(other.loc)) {
      return false;
    }

    function eq(v1, v2) {
      // Consider 0 and undefined as equal
      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;
      return v1 === v2;
    }

    for (const u of orderedUnits$1) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
}

const INVALID$1 = "Invalid Interval";

// checks if the start is equal to or before the end
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}

/**
 * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
 *
 * Here is a brief overview of the most commonly used methods and getters in Interval:
 *
 * * **Creation** To create an Interval, use {@link Interval#fromDateTimes}, {@link Interval#after}, {@link Interval#before}, or {@link Interval#fromISO}.
 * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.
 * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.
 * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval#merge}, {@link Interval#xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.
 * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}
 * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.
 */
class Interval {
  /**
   * @private
   */
  constructor(config) {
    /**
     * @access private
     */
    this.s = config.start;
    /**
     * @access private
     */
    this.e = config.end;
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.isLuxonInterval = true;
  }

  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }

    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }

  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start),
      builtEnd = friendlyDateTime(end);

    const validateError = validateStartEnd(builtStart, builtEnd);

    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd,
      });
    } else {
      return validateError;
    }
  }

  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }

  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }

  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s, e] = (text || "").split("/", 2);
    if (s && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s, opts);
        startIsValid = start.isValid;
      } catch (e) {
        startIsValid = false;
      }

      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e) {
        endIsValid = false;
      }

      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }

      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }

  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return (o && o.isLuxonInterval) || false;
  }

  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }

  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }

  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }

  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }

  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(unit = "milliseconds") {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit),
      end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  }

  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }

  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }

  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }

  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }

  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }

  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid) return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }

  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes
        .map(friendlyDateTime)
        .filter((d) => this.contains(d))
        .sort(),
      results = [];
    let { s } = this,
      i = 0;

    while (s < this.e) {
      const added = sorted[i] || this.e,
        next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      i += 1;
    }

    return results;
  }

  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);

    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }

    let { s } = this,
      idx = 1,
      next;

    const results = [];
    while (s < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      idx += 1;
    }

    return results;
  }

  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }

  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }

  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }

  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }

  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }

  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    return this.s.equals(other.s) && this.e.equals(other.e);
  }

  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s = this.s > other.s ? this.s : other.s,
      e = this.e < other.e ? this.e : other.e;

    if (s >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s, e);
    }
  }

  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s = this.s < other.s ? this.s : other.s,
      e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s, e);
  }

  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals
      .sort((a, b) => a.s - b.s)
      .reduce(
        ([sofar, current], item) => {
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        },
        [[], null]
      );
    if (final) {
      found.push(final);
    }
    return found;
  }

  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null,
      currentCount = 0;
    const results = [],
      ends = intervals.map((i) => [
        { time: i.s, type: "s" },
        { time: i.e, type: "e" },
      ]),
      flattened = Array.prototype.concat(...ends),
      arr = flattened.sort((a, b) => a.time - b.time);

    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;

      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }

        start = null;
      }
    }

    return Interval.merge(results);
  }

  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals))
      .map((i) => this.intersection(i))
      .filter((i) => i && !i.isEmpty());
  }

  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID$1;
    return `[${this.s.toISO()} – ${this.e.toISO()})`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }

  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime#toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =  ' – '] - a separator to place between the start and end representations
   * @return {string}
   */
  toFormat(dateFormat, { separator = " – " } = {}) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }

  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }

  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}

/**
 * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
 */
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });

    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }

  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }

  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }

  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}
  ) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }

  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}
  ) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }

  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }

  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null } = {}
  ) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }

  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }

  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }

  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative() };
  }
}

function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(),
    ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}

function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - (days % 7)) / 7;
      },
    ],
    ["days", dayDiff],
  ];

  const results = {};
  let lowestOrder, highWater;

  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;

      let delta = differ(cursor, later);
      highWater = cursor.plus({ [unit]: delta });

      if (highWater > later) {
        cursor = cursor.plus({ [unit]: delta - 1 });
        delta -= 1;
      } else {
        cursor = highWater;
      }

      results[unit] = delta;
    }
  }

  return [cursor, results, highWater, lowestOrder];
}

function diff (earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);

  const remainingMillis = later - cursor;

  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );

  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }

    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }

  const duration = Duration.fromObject(results, opts);

  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts)
      .shiftTo(...lowerOrderUnits)
      .plus(duration);
  } else {
    return duration;
  }
}

const numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d",
};

const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881],
};

const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");

function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);

      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}

function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}

const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";

function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s]) => post(parseDigits(s)) };
}

const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");

function fixListRegex(s) {
  // make dots optional and also make them literal
  // make space and non breakable space characters interchangeable
  return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}

function stripInsensitivities(s) {
  return s
    .replace(/\./g, "") // ignore dots that were made optional
    .replace(spaceOrNBSPRegExp, " ") // interchange space and nbsp
    .toLowerCase();
}

function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s]) =>
        strings.findIndex((i) => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex,
    };
  }
}

function offset(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}

function simple(regex) {
  return { regex, deser: ([s]) => s };
}

function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}

function unitForToken(token, loc) {
  const one = digitRegex(loc),
    two = digitRegex(loc, "{2}"),
    three = digitRegex(loc, "{3}"),
    four = digitRegex(loc, "{4}"),
    six = digitRegex(loc, "{6}"),
    oneOrTwo = digitRegex(loc, "{1,2}"),
    oneToThree = digitRegex(loc, "{1,3}"),
    oneToSix = digitRegex(loc, "{1,6}"),
    oneToNine = digitRegex(loc, "{1,9}"),
    twoToFour = digitRegex(loc, "{2,4}"),
    fourToSix = digitRegex(loc, "{4,6}"),
    literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s]) => s, literal: true }),
    unitate = (t) => {
      if (token.literal) {
        return literal(t);
      }
      switch (t.val) {
        // era
        case "G":
          return oneOf(loc.eras("short", false), 0);
        case "GG":
          return oneOf(loc.eras("long", false), 0);
        // years
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        // months
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true, false), 1);
        case "MMMM":
          return oneOf(loc.months("long", true, false), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false, false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false, false), 1);
        // dates
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        // ordinals
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        // time
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        // meridiem
        case "a":
          return oneOf(loc.meridiems(), 0);
        // weekYear (k)
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        // weekNumber (W)
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        // weekdays
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false, false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false, false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true, false), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true, false), 1);
        // offset/zone
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don't have any way to figure out what they are
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        default:
          return literal(t);
      }
    };

  const unit = unitate(token) || {
    invalidReason: MISSING_FTP,
  };

  unit.token = token;

  return unit;
}

const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy",
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM",
  },
  day: {
    numeric: "d",
    "2-digit": "dd",
  },
  weekday: {
    short: "EEE",
    long: "EEEE",
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh",
  },
  minute: {
    numeric: "m",
    "2-digit": "mm",
  },
  second: {
    numeric: "s",
    "2-digit": "ss",
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ",
  },
};

function tokenForPart(part, locale, formatOpts) {
  const { type, value } = part;

  if (type === "literal") {
    return {
      literal: true,
      val: value,
    };
  }

  const style = formatOpts[type];

  let val = partTypeStyleToTokenVal[type];
  if (typeof val === "object") {
    val = val[style];
  }

  if (val) {
    return {
      literal: false,
      val,
    };
  }

  return undefined;
}

function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}

function match(input, regex, handlers) {
  const matches = input.match(regex);

  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i],
          groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}

function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };

  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }

  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }

  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }

  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }

  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }

  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }

  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }

    return r;
  }, {});

  return [vals, zone, specificOffset];
}

let dummyDateTimeCache = null;

function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }

  return dummyDateTimeCache;
}

function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }

  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);

  if (tokens == null || tokens.includes(undefined)) {
    return token;
  }

  return tokens;
}

function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}

/**
 * @private
 */

function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
    units = tokens.map((t) => unitForToken(t, locale)),
    disqualifyingUnit = units.find((t) => t.invalidReason);

  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units),
      regex = RegExp(regexString, "i"),
      [rawMatches, matches] = match(input, regex, handlers),
      [result, zone, specificOffset] = matches
        ? dateTimeFromMatches(matches)
        : [null, null, undefined];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}

function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}

function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }

  const formatter = Formatter.create(locale, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  return parts.map((p) => tokenForPart(p, locale, formatOpts));
}

const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}

function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));

  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }

  const js = d.getUTCDay();

  return js === 0 ? 7 : js;
}

function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}

function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder,
    month0 = table.findIndex((i) => i < ordinal),
    day = ordinal - table[month0];
  return { month: month0 + 1, day };
}

/**
 * @private
 */

function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj,
    ordinal = computeOrdinal(year, month, day),
    weekday = dayOfWeek(year, month, day);

  let weekNumber = Math.floor((ordinal - weekday + 10) / 7),
    weekYear;

  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }

  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}

function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData,
    weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
    yearInDays = daysInYear(weekYear);

  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
    year;

  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }

  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}

function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}

function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}

function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear),
    validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),
    validWeekday = integerBetween(obj.weekday, 1, 7);

  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}

function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year),
    validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}

function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year),
    validMonth = integerBetween(obj.month, 1, 12),
    validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}

function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour =
      integerBetween(hour, 0, 23) ||
      (hour === 24 && minute === 0 && second === 0 && millisecond === 0),
    validMinute = integerBetween(minute, 0, 59),
    validSecond = integerBetween(second, 0, 59),
    validMillisecond = integerBetween(millisecond, 0, 999);

  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}

const INVALID = "Invalid DateTime";
const MAX_DATE = 8.64e15;

function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}

// we cache week data on the DT object and this intermediates the cache
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}

// clone really means, "make a new object with these modifications". all "setters" really use this
// to create a new object while only changing some of the properties
function clone(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid,
  };
  return new DateTime({ ...current, ...alts, old: current });
}

// find the right offset a given local time. The o input is our guess, which determines which
// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)
function fixOffset(localTS, o, tz) {
  // Our UTC time is just a guess because our offset is just a guess
  let utcGuess = localTS - o * 60 * 1000;

  // Test whether the zone matches the offset for this ts
  const o2 = tz.offset(utcGuess);

  // If so, offset didn't change and we're done
  if (o === o2) {
    return [utcGuess, o];
  }

  // If not, change the ts by the difference in the offset
  utcGuess -= (o2 - o) * 60 * 1000;

  // If that gives us the local time we want, we're done
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }

  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time
  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
}

// convert an epoch timestamp into a calendar object with the given offset
function tsToObj(ts, offset) {
  ts += offset * 60 * 1000;

  const d = new Date(ts);

  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds(),
  };
}

// convert a calendar object to a epoch timestamp
function objToTS(obj, offset, zone) {
  return fixOffset(objToLocalTS(obj), offset, zone);
}

// create a new DT instance by adding a duration, adjusting for DSTs
function adjustTime(inst, dur) {
  const oPre = inst.o,
    year = inst.c.year + Math.trunc(dur.years),
    month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
    c = {
      ...inst.c,
      year,
      month,
      day:
        Math.min(inst.c.day, daysInMonth(year, month)) +
        Math.trunc(dur.days) +
        Math.trunc(dur.weeks) * 7,
    },
    millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds,
    }).as("milliseconds"),
    localTS = objToLocalTS(c);

  let [ts, o] = fixOffset(localTS, oPre, inst.zone);

  if (millisToAdd !== 0) {
    ts += millisToAdd;
    // that could have changed the offset by going over a DST, but we want to keep the ts the same
    o = inst.zone.offset(ts);
  }

  return { ts, o };
}

// helper useful in turning the results of parsing into real dates
// by handling the zone options
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone,
      inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset,
      });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
    );
  }
}

// if you want to output a technical format (e.g. RFC 2822), this helper
// helps handle the details
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid
    ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true,
      }).formatDateTimeFromString(dt, format)
    : null;
}

function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0) c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);

  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}

function toISOTime(
  o,
  extended,
  suppressSeconds,
  suppressMilliseconds,
  includeOffset,
  extendedZone
) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }

  if (o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);

    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }

  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }

  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}

// defaults for unspecified units in the supported calendars
const defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  },
  defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  },
  defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  };

// Units in the supported calendars, sorted by bigness
const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
  orderedWeekUnits = [
    "weekYear",
    "weekNumber",
    "weekday",
    "hour",
    "minute",
    "second",
    "millisecond",
  ],
  orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

// standardize case and plurality in units
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal",
  }[unit.toLowerCase()];

  if (!normalized) throw new InvalidUnitError(unit);

  return normalized;
}

// this is a dumbed down version of fromObject() that runs about 60% faster
// but doesn't do any validation, makes a bunch of assumptions about what units
// are present, and so on.
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone),
    loc = Locale.fromObject(opts),
    tsNow = Settings.now();

  let ts, o;

  // assume we have the higher-order units
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }

    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }

    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }

  return new DateTime({ ts, zone, loc, o });
}

function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round,
    format = (c, unit) => {
      c = roundTo(c, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit);
    },
    differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };

  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }

  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}

function lastOpts(argList) {
  let opts = {},
    args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}

/**
 * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
 *
 * A DateTime comprises of:
 * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
 * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
 * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
 *
 * Here is a brief overview of the most commonly used functionality it provides:
 *
 * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime#local}, {@link DateTime#utc}, and (most flexibly) {@link DateTime#fromObject}. To create one from a standard string format, use {@link DateTime#fromISO}, {@link DateTime#fromHTTP}, and {@link DateTime#fromRFC2822}. To create one from a custom string format, use {@link DateTime#fromFormat}. To create one from a native JS date, use {@link DateTime#fromJSDate}.
 * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},
 * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.
 * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.
 * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.
 * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.
 * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.
 *
 * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
 */
class DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;

    let invalid =
      config.invalid ||
      (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) ||
      (!zone.isValid ? unsupportedZone(zone) : null);
    /**
     * @access private
     */
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;

    let c = null,
      o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);

      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }

    /**
     * @access private
     */
    this._zone = zone;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.invalid = invalid;
    /**
     * @access private
     */
    this.weekData = null;
    /**
     * @access private
     */
    this.c = c;
    /**
     * @access private
     */
    this.o = o;
    /**
     * @access private
     */
    this.isLuxonDateTime = true;
  }

  // CONSTRUCT

  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }

  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }

  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;

    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }

  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }

    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    return new DateTime({
      ts: ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options),
    });
  }

  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options),
      });
    }
  }

  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options),
      });
    }
  }

  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    const tsNow = Settings.now(),
      offsetProvis = !isUndefined(opts.specificOffset)
        ? opts.specificOffset
        : zoneToUse.offset(tsNow),
      normalized = normalizeObject(obj, normalizeUnit),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber,
      loc = Locale.fromObject(opts);

    // cases:
    // just a weekday -> this week's instance of that weekday, no worries
    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
    // (gregorian month or day) + ordinal -> error
    // otherwise just use weeks or ordinals or gregorian, depending on what's specified

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }

    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }

    const useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);

    // configure ourselves to deal with gregorian dates or week stuff
    let units,
      defaultValues,
      objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }

    // set default values for missing stuff
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }

    // make sure the values we have are in range
    const higherOrderInvalid = useWeekData
        ? hasInvalidWeekData(normalized)
        : containsOrdinal
        ? hasInvalidOrdinalData(normalized)
        : hasInvalidGregorianData(normalized),
      invalid = higherOrderInvalid || hasInvalidTimeData(normalized);

    if (invalid) {
      return DateTime.invalid(invalid);
    }

    // compute the actual time
    const gregorian = useWeekData
        ? weekToGregorian(normalized)
        : containsOrdinal
        ? ordinalToGregorian(normalized)
        : normalized,
      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),
      inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc,
      });

    // gregorian data + weekday serves only to validate
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }

    return inst;
  }

  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }

  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }

  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }

  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }

    const { locale = null, numberingSystem = null } = opts,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true,
      }),
      [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }

  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }

  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }

  /**
   * Create an invalid DateTime.
   * @param {DateTime} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }

    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }

  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return (o && o.isLuxonDateTime) || false;
  }

  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => (t ? t.val : null)).join("");
  }

  // INFO

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }

  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }

  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }

  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }

  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }

  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }

  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }

  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }

  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }

  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }

  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }

  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }

  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }

  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }

  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }

  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }

  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }

  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }

  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }

  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }

  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }

  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale,
      });
    } else {
      return null;
    }
  }

  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale,
      });
    } else {
      return null;
    }
  }

  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }

  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return (
        this.offset > this.set({ month: 1, day: 1 }).offset ||
        this.offset > this.set({ month: 5 }).offset
      );
    }
  }

  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }

  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }

  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }

  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }

  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }

  // TRANSFORM

  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset), opts);
  }

  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }

  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone(this, { ts: newTS, zone });
    }
  }

  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone(this, { loc });
  }

  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }

  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;

    const normalized = normalizeObject(values, normalizeUnit),
      settingWeekStuff =
        !isUndefined(normalized.weekYear) ||
        !isUndefined(normalized.weekNumber) ||
        !isUndefined(normalized.weekday),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber;

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }

    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }

    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };

      // if we didn't set the day but we ended up on an overflow date,
      // use the last day of the right month
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }

    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone(this, { ts, o });
  }

  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return clone(this, adjustTime(this, dur));
  }

  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone(this, adjustTime(this, dur));
  }

  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit) {
    if (!this.isValid) return this;
    const o = {},
      normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through
      case "quarters":
      case "months":
        o.day = 1;
      // falls through
      case "weeks":
      case "days":
        o.hour = 0;
      // falls through
      case "hours":
        o.minute = 0;
      // falls through
      case "minutes":
        o.second = 0;
      // falls through
      case "seconds":
        o.millisecond = 0;
        break;
      // no default, invalid units throw in normalizeUnit()
    }

    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }

    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }

    return this.set(o);
  }

  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit) {
    return this.isValid
      ? this.plus({ [unit]: 1 })
          .startOf(unit)
          .minus(1)
      : this;
  }

  // OUTPUT

  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid
      ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt)
      : INVALID;
  }

  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid
      ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this)
      : INVALID;
  }

  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid
      ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this)
      : [];
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false,
  } = {}) {
    if (!this.isValid) {
      return null;
    }

    const ext = format === "extended";

    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }

    return toISODate(this, format === "extended");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended",
  } = {}) {
    if (!this.isValid) {
      return null;
    }

    let c = includePrefix ? "T" : "";
    return (
      c +
      toISOTime(
        this,
        format === "extended",
        suppressSeconds,
        suppressMilliseconds,
        includeOffset,
        extendedZone
      )
    );
  }

  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";

    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }

    return toTechFormat(this, fmt, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }

    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }

  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }

  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }

  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1000 : NaN;
  }

  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1000) : NaN;
  }

  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }

  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};

    const base = { ...this.c };

    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }

  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }

  // COMPARE

  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }

    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };

    const units = maybeArray(unit).map(Duration.normalizeUnit),
      otherIsLater = otherDateTime.valueOf() > this.valueOf(),
      earlier = otherIsLater ? this : otherDateTime,
      later = otherIsLater ? otherDateTime : this,
      diffed = diff(earlier, later, units, durOpts);

    return otherIsLater ? diffed.negate() : diffed;
  }

  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }

  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }

  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;

    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }

  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return (
      this.isValid &&
      other.isValid &&
      this.valueOf() === other.valueOf() &&
      this.zone.equals(other.zone) &&
      this.loc.equals(other.loc)
    );
  }

  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }),
      padding = options.padding ? (this < base ? -options.padding : options.padding) : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = undefined;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit,
    });
  }

  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;

    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true,
    });
  }

  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }

  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }

  // MISC

  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true,
      });
    return explainFromTokens(localeToUse, text, fmt);
  }

  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }

  // FORMAT PRESETS

  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}

/**
 * @private
 */
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

const defaultUpdateCallback = (year, month, day, hour, minute) => { };
class TerrainViewer extends o {
    constructor(container, initvalue) {
        let imageProvider = null;
        switch (initvalue.surface) {
            case "bingmaps":
                imageProvider = new BingMapsImageProvider$1({
                    uriScheme: "https",
                    key: process.env.BINGMAP_ACCESS_TOKEN
                });
                break;
            case "satellite":
                imageProvider = new o$d("https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/", ".jpg", 256, 2, 18);
                break;
            case "street":
                imageProvider = new o$d("https://cyberjapandata.gsi.go.jp/xyz/std/", ".png", 256, 5, 18);
                break;
        }
        super(container, "MTY4NDIyNjYwODllY2U2Njk2YzgyODNjNzliYjE3", {
            debug_stats: new _$3(),
            image_provider: imageProvider,
            atmosphere: new a$2(),
            sun_visualizer: new t(32),
        });
        this._container = container;
        this._init_camera_parameter = {
            fov: 84.0,
        };
        this._enable_sun_animation = false;
        this._current_location = initvalue.location;
        this._sun_speed = initvalue.sun_speed;
        const i = getCameraInfoFromLocation(initvalue.location);
        if (i < 0) {
            return;
        }
        this._setCurrentDateTime(initvalue.date_time.year, initvalue.date_time.month, initvalue.date_time.day, initvalue.date_time.hour, initvalue.date_time.minute, default_config[i].timezone);
        this._updateSunAnimation = defaultUpdateCallback;
        this.selectLocation(initvalue.location);
        this.setCameraParameter(this._init_camera_parameter);
        this.enableURLUpdate(false);
        if (initvalue.enable_atmosphere === false) {
            this.enableAtmosphere(false);
        }
        this.selectSurface(initvalue.surface);
        this.selectLocation(initvalue.location);
        this._getAttribution(initvalue.surface).forEach(attr => {
            var _a;
            (_a = this._viewer) === null || _a === void 0 ? void 0 : _a.attribution_controller.addAttribution(attr);
        });
    }
    onUpdateFrame(delta_time) {
        if (!this._viewer) {
            return;
        }
        if (this._enable_sun_animation) {
            this._animateSun(delta_time);
        }
        super.onUpdateFrame(delta_time);
    }
    selectLocation(location) {
        const i = getCameraInfoFromLocation(location);
        if (i < 0) {
            return;
        }
        this._current_location = location;
        const targetpos = new r$z(default_config[i].target_lng, default_config[i].target_lat, default_config[i].target_altitude);
        this.startFlyCamera({ time: 0.1, iscs_end: targetpos, end_altitude: default_config[i].cam_altitude, end_from_lookat: default_config[i].cam_distance });
        const sunpos = new r$z(default_config[i].target_lng, default_config[i].target_lat, 0.0);
        const dt = this._setCurrentDateTime(default_config[i].year, default_config[i].month, default_config[i].day, default_config[i].hour, default_config[i].minute, default_config[i].timezone);
        this._setSunDirection(sunpos, dt, default_config[i].ray_leigh, default_config[i].mie);
    }
    selectSurface(surface) {
        if (this._viewer) {
            switch (surface) {
                case "wireframe":
                    this._viewer.setVisibility("@@_Viewer.Category.GROUND", true);
                    this._viewer.render_mode = "@@_Viewer.RenderMode.WIREFRAME";
                    break;
                case "hidden":
                    this._viewer.setVisibility("@@_Viewer.Category.GROUND", false);
                    break;
                case "texture":
                    this._viewer.setVisibility("@@_Viewer.Category.GROUND", true);
                    this._viewer.render_mode = "@@_Viewer.RenderMode.SURFACE";
                    break;
            }
        }
    }
    enableAtmosphere(enable) {
        if (this._viewer && this._viewer.atmosphere) {
            if (enable) {
                this._viewer.atmosphere.setSkyVisibility(true);
                this._viewer.atmosphere.setGroundVisibility(true);
            }
            else {
                this._viewer.atmosphere.setSkyVisibility(false);
                this._viewer.atmosphere.setGroundVisibility(false);
            }
        }
    }
    sunAnimation(start, year, month, day, hour, minute, location, callback) {
        if (start) {
            const i = getCameraInfoFromLocation(location);
            if (i < 0) {
                return;
            }
            this._setCurrentDateTime(year, month, day, hour, minute, default_config[i].timezone);
            this._updateSunAnimation = callback;
        }
        else {
            this._updateSunAnimation = defaultUpdateCallback;
        }
        this._enable_sun_animation = start;
    }
    selectDateTime(year, month, day, hour, minute, location) {
        const i = getCameraInfoFromLocation(location);
        if (i < 0) {
            return;
        }
        const sunbasepos = new r$z(default_config[i].target_lng, default_config[i].target_lat, 0.0);
        const dt = this._setCurrentDateTime(year, month, day, hour, minute, default_config[i].timezone);
        this._setSunDirection(sunbasepos, dt, default_config[i].ray_leigh, default_config[i].mie);
    }
    changeSunAnimationSpeed(factor) {
        this._sun_speed = factor;
    }
    _setSunDirection(pos, dt, ray_leigh, mie) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        (_b = (_a = this._viewer) === null || _a === void 0 ? void 0 : _a.atmosphere) === null || _b === void 0 ? void 0 : _b.setRayleigh(ray_leigh);
        (_d = (_c = this._viewer) === null || _c === void 0 ? void 0 : _c.atmosphere) === null || _d === void 0 ? void 0 : _d.setMie(mie);
        if (!dt.isValid) {
            throw new Error("check the date and zone format");
        }
        const positionResult = suncalc.exports.getPosition(new Date(dt.toString()), pos.latitude, pos.longitude);
        const phi = Math.PI * 3 / 2 - positionResult.azimuth;
        const theta = Math.PI * 0.5 - positionResult.altitude;
        const x = Math.sin(theta) * Math.cos(phi);
        const y = Math.sin(theta) * Math.sin(phi);
        const z = Math.cos(theta);
        const geoPoint = new r$z(pos.longitude, pos.latitude, 0);
        const mtog_mat = geoPoint.getMlocsToGocsMatrix(e$z.createMatrix());
        const gocs_xyz = e$z.transformDirection_A(mtog_mat, e$z.createVector3f([x, y, z]), e$z.createVector3());
        const n_gocs_xyz = e$z.normalize3(e$z.createVector3f([gocs_xyz[0], gocs_xyz[1], gocs_xyz[2]]), e$z.createVector3());
        (_e = this._viewer) === null || _e === void 0 ? void 0 : _e.sun.setSunDirection([n_gocs_xyz[0], n_gocs_xyz[1], n_gocs_xyz[2]]);
        (_g = (_f = this._viewer) === null || _f === void 0 ? void 0 : _f.sunVisualizer) === null || _g === void 0 ? void 0 : _g.setVisibility(true);
        (_j = (_h = this._viewer) === null || _h === void 0 ? void 0 : _h.sunVisualizer) === null || _j === void 0 ? void 0 : _j.setRadius(4);
    }
    _setCurrentDateTime(year, month, day, hour, minute, timezone) {
        const dt = DateTime.fromObject({
            year: year,
            month: month,
            day: day,
            hour: hour,
            minute: minute
        }, {
            zone: timezone
        });
        if (!dt.isValid) {
            throw new Error("check the date and zone format");
        }
        this._current_date = dt;
        return dt;
    }
    _animateSun(dt) {
        console.log(dt);
        const newdt = this._current_date.plus({ minute: dt / 60.0 * this._sun_speed });
        const i = getCameraInfoFromLocation(this._current_location);
        if (i < 0) {
            return;
        }
        const sunpos = new r$z(default_config[i].target_lng, default_config[i].target_lat, 0.0);
        this._setSunDirection(sunpos, newdt, default_config[i].ray_leigh, default_config[i].mie);
        this._current_date = newdt;
        this._updateSunAnimation(this._current_date.year, this._current_date.month, this._current_date.day, this._current_date.hour, this._current_date.minute);
    }
    _getAttribution(surface) {
        let attr = [];
        switch (surface) {
            case "satellite":
                attr = [{
                        display: "国土地理院",
                        link: "http://maps.gsi.go.jp/development/ichiran.html"
                    }];
                break;
            case "bingmaps":
                attr = [{
                        display: "© 2018 Microsoft Corporation",
                        link: ""
                    }, {
                        display: "©CNES (2018) Distribution Airbus DS",
                        link: ""
                    }, {
                        display: "© 2018 SK telecom/NGII",
                        link: ""
                    }, {
                        display: "Earthstar Geographics SIO",
                        link: ""
                    }];
                break;
            case "standard":
                attr = [{
                        display: "国土地理院",
                        link: "http://maps.gsi.go.jp/development/ichiran.html"
                    }];
                break;
        }
        return attr;
    }
    onKeyDown(event) {
        super.onKeyDown(event);
    }
}

class App {
    constructor(container, initvalue) {
        this._container = container;
        this._current = new TerrainViewer(this._container, initvalue);
    }
    changeLocation(location) {
        this._current.selectLocation(location);
    }
    changeSurface(initvalue) {
        if (this._current) {
            this._current.destroy();
        }
        this._current = new TerrainViewer(this._container, initvalue);
    }
    changeDateTime(year, month, day, hour, minute, location) {
        this._current.selectDateTime(year, month, day, hour, minute, location);
    }
    enableAtmosphere(enable) {
        this._current.enableAtmosphere(enable);
    }
    destroy() {
    }
    sunAnimation(start, year, month, day, hour, minute, location, callback) {
        this._current.sunAnimation(start, year, month, day, hour, minute, location, callback);
    }
    changeSunAnimationSpeed(factor) {
        this._current.changeSunAnimationSpeed(factor);
    }
}

var appInstance;
const play_icon = "play_circle_filled-24px.svg";
const pause_icon = "pause_circle_filled-24px.svg";
const resource_path = "./resources/icon/";
function startApp(container) {
    if (appInstance) {
        appInstance.destroy();
        appInstance = undefined;
    }
    const surface = document.getElementById("surface");
    const surface_value = surface.value;
    const location = document.getElementById("location");
    const location_value = location.value;
    _setDefaultDateInfo(location.value);
    const atom = document.getElementById("AtmoON");
    const atom_value = atom.checked;
    const elem_range = document.getElementById("range");
    const speed_value = Number(elem_range.value);
    const date_time_info = _getDate();
    if (date_time_info && date_time_info.length == 3) {
        const date_array = date_time_info[0];
        const time_array = date_time_info[1];
        appInstance = new App(container, {
            "location": location_value,
            "surface": surface_value,
            "enable_atmosphere": atom_value,
            "date_time": {
                year: Number(date_array[0]),
                month: Number(date_array[1]),
                day: Number(date_array[2]),
                hour: Number(time_array[0]),
                minute: Number(time_array[1])
            },
            "sun_speed": speed_value
        });
    }
}
function onChangeLocation() {
    const elem_select = document.getElementById("location");
    if (elem_select && appInstance) {
        _setDefaultDateInfo(elem_select.value);
        appInstance.changeLocation(elem_select.value);
    }
}
function onChangeSurface() {
    const elem_surface = document.getElementById("surface");
    const surface = elem_surface.value;
    const elem_location = document.getElementById("location");
    const location = elem_location.value;
    const elem_atom = document.getElementById("AtmoON");
    const isAtom = elem_atom.checked;
    const date_time_info = _getDate();
    const elem_range = document.getElementById("range");
    const speed_value = Number(elem_range.value);
    if (date_time_info && date_time_info.length == 3 && appInstance) {
        const date_array = date_time_info[0];
        const time_array = date_time_info[1];
        appInstance.changeSurface({
            "location": location,
            "surface": surface,
            "enable_atmosphere": isAtom,
            "date_time": {
                year: Number(date_array[0]),
                month: Number(date_array[1]),
                day: Number(date_array[2]),
                hour: Number(time_array[0]),
                minute: Number(time_array[1])
            },
            "sun_speed": speed_value
        });
    }
}
function onClickCheckAtmosphere() {
    const atom = document.getElementById("AtmoON");
    if (atom && appInstance) {
        appInstance.enableAtmosphere(atom.checked);
    }
}
function onChangeDateTime() {
    const date_time_info = _getDate();
    if (date_time_info && date_time_info.length == 3 && appInstance) {
        const date_array = date_time_info[0];
        const time_array = date_time_info[1];
        const location = date_time_info[2];
        appInstance.changeDateTime(Number(date_array[0]), Number(date_array[1]), Number(date_array[2]), Number(time_array[0]), Number(time_array[1]), location);
    }
}
function _setDefaultDateInfo(location) {
    const location_index = getCameraInfoFromLocation(location);
    if (location_index < 0) {
        throw new Error("the initial value of location has any problem");
    }
    const input_date = document.getElementById("simulate-date");
    input_date.value = default_config[location_index].year + '-' + _getDNumber(default_config[location_index].month) + '-' + _getDNumber(default_config[location_index].day);
    const input_time = document.getElementById("simulate-time");
    input_time.value = _getDNumber(default_config[location_index].hour) + ':' + _getDNumber(default_config[location_index].minute);
    const input_timezone = document.getElementById("simulate-timezone");
    input_timezone.value = default_config[location_index].timezone;
}
function _getDNumber(src) {
    return ("0" + src).slice(-2);
}
function _getDate() {
    const input_date = document.getElementById("simulate-date");
    const input_time = document.getElementById("simulate-time");
    const elem_select = document.getElementById("location");
    if (input_date && input_time && elem_select) {
        const location_index = getCameraInfoFromLocation(elem_select.value);
        if (location_index < 0) {
            throw new Error("the initial value of location has any problem");
        }
        const input_timezone = document.getElementById("simulate-timezone");
        input_timezone.value = default_config[location_index].timezone;
        const date_array = input_date.value.split("-");
        const time_array = input_time.value.split(":");
        return [date_array, time_array, elem_select.value];
    }
    return null;
}
function onStartDayAnimation() {
    const icon_img = document.getElementById("sun-player-icon");
    if (icon_img && appInstance) {
        let next_start = true;
        if (icon_img.src.split("/").pop() == play_icon) {
            icon_img.src = resource_path + pause_icon;
        }
        else {
            next_start = false;
            icon_img.src = resource_path + play_icon;
        }
        const date_time_info = _getDate();
        if (date_time_info && date_time_info.length == 3) {
            const date_array = date_time_info[0];
            const time_array = date_time_info[1];
            const location = date_time_info[2];
            appInstance.sunAnimation(next_start, Number(date_array[0]), Number(date_array[1]), Number(date_array[2]), Number(time_array[0]), Number(time_array[1]), location, updateSunAnimation);
        }
    }
}
function updateSunAnimation(year, month, day, hour, minute) {
    const input_date = document.getElementById("simulate-date");
    const input_time = document.getElementById("simulate-time");
    input_date.value = String(year) + "-" + _getDNumber(month) + "-" + _getDNumber(day);
    input_time.value = _getDNumber(hour) + ":" + _getDNumber(minute);
}
const elem_range = document.getElementById("range");
const target_range = document.getElementById("range-output");
let rangeValue = (elem, target) => {
    return function () {
        if (appInstance) {
            appInstance.changeSunAnimationSpeed(Number(elem.value) * 500);
        }
        target.innerHTML = elem.value;
    };
};
elem_range.addEventListener("input", rangeValue(elem_range, target_range));
window.startApp = startApp;
window.onChangeLocation = onChangeLocation;
window.onChangeSurface = onChangeSurface;
window.onClickCheckAtmosphere = onClickCheckAtmosphere;
window.onChangeDateTime = onChangeDateTime;
window.onStartDayAnimation = onStartDayAnimation;

})();
//# sourceMappingURL=bundle.js.map
